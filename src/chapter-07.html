<h1 class="western" style="page-break-before: always;"><font color="#110d06"><font color="#0b0703"><a name="_Chapter_7:_"></a><a class="western" href="#TC07"><font size="5"><b>Chapter
7: Memory Addressing</b></font></a></font></font></h1>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<table border="1" bordercolor="#bfbfbf" cellpadding="4" cellspacing="0" frame="void" rules="groups" width="415">
<col width="401"> <tbody>
<tr>
<td bgcolor="#bfbfbf" width="401">
<p class="western"><b>7.1 </b><a class="western" href="#_DEFINITIONS">DEFINITIONS</a></p>
</td>
</tr>
</tbody> <tbody>
<tr>
<td bgcolor="#bfbfbf" width="401">
<p class="western"><b>7.2 </b><a class="western" href="#_THE_MEMORY_ARCHITECTURE">THE
MEMORY ARCHITECTURE OF THE 8088</a></p>
</td>
</tr>
</tbody> <tbody>
<tr>
<td bgcolor="#bfbfbf" width="401">
<p class="western"><b>7.3 </b><a class="western" href="#_SEGMENTS_AND_OFFSETS">SEGMENTS
AND OFFSETS</a></p>
</td>
</tr>
</tbody> <tbody>
<tr>
<td bgcolor="#bfbfbf" width="401">
<p class="western"><b>7.4 </b><a class="western" href="#_SEGMENT_HANDLING">SEGMENT
HANDLING</a></p>
</td>
</tr>
</tbody> <tbody>
<tr>
<td bgcolor="#bfbfbf" width="401">
<p class="western"><b>7.5 </b><a class="western" href="#_OFFSET_HANDLING">OFFSET
HANDLING</a></p>
</td>
</tr>
</tbody> <tbody>
<tr>
<td bgcolor="#bfbfbf" width="401">
<p class="western"><b>7.6 </b><a class="western" href="#_mod-reg-rm_ADDRESSING"><i>MOD-REG-RM</i>
ADDRESSING</a></p>
</td>
</tr>
</tbody> <tbody>
<tr>
<td bgcolor="#bfbfbf" width="401">
<p class="western"><b>7.7 </b><a class="western" href="#_NON-mod-reg-rm_MEMORY_ADDRESSING">NON-<i>MOD-REG-RM</i>
MEMORY ADDRESSING</a></p>
</td>
</tr>
</tbody> <tbody>
<tr>
<td bgcolor="#bfbfbf" width="401">
<p class="western"><b>7.8 </b><a class="western" href="#_INITIALIZING_MEMORY">INITIALIZING
MEMORY</a></p>
</td>
</tr>
</tbody> <tbody>
<tr>
<td bgcolor="#bfbfbf" valign="top" width="401">
<p class="western"><b>7.9 </b><a class="western" href="#_A_BRIEF_NOTE">A BRIEF NOTE ON
I/O ADDRESSING</a></p>
</td>
</tr>
</tbody>
</table>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
8088's registers
are very powerful, and critically important to writing
high-performance code &#8212; but there are scarcely a dozen of them,
and they certainly can't do the job by themselves. We need more than
seven &#8212; or seventy, or seven hundred or even seven thousand &#8212;
general-purpose storage locations. We need storage that's capable of
storing characters, numbers, and instruction bytes in great
quantities (remember that instruction bytes are just another sort of
data) &#8212; and, of course, that's just what we get by way of the 1
megabyte of memory that the 8088 supports.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">(The PC has only 640
Kb of system RAM, but nonetheless does support a full megabyte of
addressable memory. The memory above the 640 K mark is occupied by
display memory and by BIOS code stored in ROM (read-only memory);
this memory can always be read from and can in some cases &#8212;
display memory, for example &#8212; be written to as well.)</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Not
only does the 8088
support 1 Mb of memory, but it also provides many powerful and
flexible ways to get at that memory. We'll skim through the many
memory addressing modes and instructions quickly, but we're not going
to spend a great deal of time on their basic operation.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Why
not spend more
time describing the memory addressing modes and instructions? One
reason is that I've assumed throughout <i>The Zen of Assembly
Language</i> that you're at least passingly familiar with
assembler,
thereby avoiding a lot of rehashing and explaining &#8212; and memory
addressing is fundamental to almost any sort of assembler
programming. If you really don't know the basic memory addressing
modes, a refresher on assembler in general might be in order before
you continue with <i>The Zen of Assembly Language</i>.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
other reason for
not spending much time on the operation of the memory addressing
modes is that we have another &#8212; and sadly neglected &#8212;
aspect of memory addressing to discuss: performance.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> You
see, while the
8088 lets you address a great deal of memory, it isn't particularly
fast at accessing all that memory. This is especially true when
dealing with blocks of memory larger than 64 Kb, but is <i>always</i>
true to some extent. Memory-accessing instructions are often very
long and are always very slow.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Worse, many people
don't seem to understand the sharp distinction between memory and
registers. Some "experts" would have you view memory
locations as extensions of your register set. With this sort of
thinking, the instructions:</font></font></p>
<p class="western" style="margin-bottom: 0in;">
</p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov dx,ax</b></font></font></font></p>

<p class="western" style="margin-bottom: 0in; margin-left: 40px;"><font color="#110d06"><font color="#0b0703">and:</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-left: 40px;">
</p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov dx,MemVar
</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;">
</p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">are
logically
equivalent. Well, the instructions <i>are</i> logically
equivalent
in the sense that they both move data into DX &#8212; but they're
polar opposites when it comes to performance. The register-only <b>mov</b>
is half the length in bytes and anywhere from two to seven times
faster than the <b>mov</b> from memory...and that's fairly
typical of
the differences between register-only and memory-addressing
instructions.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> So
you see, saying
that memory is logically equivalent to registers is something like
saying that a bus is logically equivalent to a 747. Sure, you can
buy a ticket to get from one place to another with either mode of
transportation...but which would <i>you</i> rather cross
the country
in?</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> As
we'll see in this
chapter, and indeed throughout the rest of the <i>Zen of
Assembly
Language</i>, one key to optimizing 8088 code is using the
registers
heavily while avoiding memory whenever you can. Pick your spots for
such optimizations carefully, though. Optimize instructions in tight
loops and in time-critical code, but let initialization and set-up
code slide; it's just not worth the time and effort to optimize code
that doesn't much affect overall performance or response time.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Slow and lengthy as
memory accessing instructions are, you're going to end up using them
a great deal in your code. (Just try to write a useful program that
doesn't access memory!) In light of that, we're going to review the
memory-addressing architecture and modes of the 8088, then look at
the performance implications of accessing memory. We'll see why
memory accesses are slow, and we'll see that not all memory
addressing modes or memory addressing instructions are created equal
in terms of size and performance. (In truth, the differences between
the various memory-addressing modes and instructions are just about
as large as those between register-only and memory-accessing
instructions.) Along the way, we'll come across a number of useful
techniques for writing high-performance code for the PC, most notably
look-up tables. By the end of this chapter, we'll be ready to dive
into the instruction set in a big way.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">We've got a lot of
ground to cover, so let's get started.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h2 class="western"><font color="#110d06"><font color="#0b0703"><a name="_DEFINITIONS"></a><a class="western" href="#T0701"><font style="font-size: 16pt;" size="4"><b>7.1
DEFINITIONS</b></font></a></font></font></h2>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> I'm
going to take a
moment to define some terms I'll use in this chapter. These terms
will be used to describe operands to various instructions; for
example, <b>mov ax,</b><i><b>segreg</b></i>
refers to copying the
contents of a segment register into AX.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <i><b>reg</b></i>
refers to any 8-or 16-bit general-purpose register. <i>reg8</i>
refers to any 8-bit (byte-sized) general-purpose register, and <i>reg16</i>
refers to any 16-bit (word-sized) general-purpose register.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <i><b>segreg</b></i>
refers to any segment register.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <i><b>mem</b></i>
refers to any 8-, 16-, or 32-bit memory operand. <i>mem8</i>
refers
to any byte-sized memory operand, <i>mem16</i> refers to
any
word-sized memory operand, and <i>mem32</i> refers to any
doublewordsized memory operand.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <i><b>reg/mem</b></i>
refers to any 8-or 16-bit register or memory operand. As you'd
expect, <i>reg/mem8</i> refers to any byte-sized register
or memory
operand, and <i>reg/mem16</i> refers to any word-sized
register or
memory operand.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <i><b>immed</b></i>
refers to any immediate (constant) instruction operand. (Immediate
addressing is discussed in detail below.) <i>immed8</i>
refers to any
byte-sized immediate operand, and <i>immed16</i> refers to
any
word-sized immediate operand.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_SQUARE_BRACKETS_MEAN"></a><a class="western" href="#T0701"><font size="4"><b>SQUARE
BRACKETS MEAN MEMORY ADDRESSING</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
use of square
brackets is optional when a memory location is being addressed by
name. That is, the two following instructions assemble to exactly
the same code:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov dx,MemVar</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov dx,[MemVar]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">However,
addressing
memory without square brackets is an extension of the "memory
and registers are logically equivalent" mindset. I strongly
recommend that you use square brackets on all memory references in
order to keep the distinction between memory and registers clear in
your mind. This practice also helps distinguish between immediate
and memory operands.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h2 class="western"><font color="#110d06"><font color="#0b0703"><a name="_THE_MEMORY_ARCHITECTURE"></a><a class="western" href="#T0702"><font style="font-size: 16pt;" size="4"><b>7.2
THE MEMORY ARCHITECTURE OF THE 8088</b></font></a></font></font></h2>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
ability to address
1 Mb of memory, while unimpressive by today's standards, was quite
remarkable when the PC was first introduced, 64 Kb then being
standard for "serious" microcomputers. In fact, an
argument could be made that the 8088's 1 Mb address space is the
single factor most responsible for the success of the IBM PC and for
the exceptional software that quickly became available for it.
Realistically, the letters "IBM" were probably more
important, but all that memory didn't hurt; quantities of memory make
new sorts of software possible, and can often compensate for limited
processor power in the form of lookup tables, RAM disks, data
caching, and in-line code. All in all, the PC's then-large memory
capacity made possible a quantum leap in software quality.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> On
the other hand, the
8088 actually addresses all that memory in what is perhaps the most
awkward manner ever conceived &#8212; by way of addressing 64 Kb
blocks off each of the four segment registers. This scheme means
that programs must perform complex and time-consuming calculations in
order to access the full 1 Mb of memory in a general way. One of the
ways in which assembler programs can outstrip compiled programs is by
cleverly structuring code and data so that sequential memory accesses
generally involve only memory within the four segments addressable at
any one time, thereby avoiding the considerable overhead associated
with calculating full addresses and frequently reloading the segment
registers.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In
short, the 8088's
memory architecture is the best of worlds and the worst of worlds: the
best because a great deal of memory is addressable (at least by
1981 standards), the worst because it's hard to access all that
memory quickly. That said, let's look at the 8088's memory
architecture in detail. Most likely you know what we're about to
discuss, but bear with me; I want to make sure we're all speaking the
same language before I go on to more advanced subjects.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h2 class="western"><font color="#110d06"><font color="#0b0703"><a name="_SEGMENTS_AND_OFFSETS"></a><a class="western" href="#T0703"><font style="font-size: 16pt;" size="4"><b>7.3
SEGMENTS AND OFFSETS</b></font></a></font></font></h2>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> 20
bits are needed to
address 1 Mb of memory, and every one of the one-million-plus memory
addresses the 8088 can handle can indeed be expressed as a 20-bit
number. However, programs do <i>not</i> address memory
with 20-bit
addresses. There's a good reason for that: 20-bit addresses would
be most impractical. For one thing, the 8088's registers are only 16
bits in size, so they couldn't be used to point to 20-bit addresses.
For another, three rather than two bytes would be needed to store
each address loaded by a program, making for bloated code. In
general, the 8088 just wasn't designed to handle straight 20-bit
addresses.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">(You may well ask why
the 8088 wasn't designed better. "Better" is a slippery
term, and the 8088 certainly has been successful...nonetheless,
that's a good question, which I'll answer in Chapter 8. A hint: much of
the 8088's architecture is derived from the 8080, which could
only address 64 Kb in all. The 8088 strongly reflects long-ago
microcomputer technology, not least in its limitation to 1 Mb in
total.)</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Well, if the PC
doesn't use straight 20-bit addresses, what does it use? It uses
paired segments and offsets, which together form an address denoted
as segment:offset. For example, the address 23F0:1512 is the address
composed of the segment value 23F0 hex and the offset value 1512 hex.
(I'll always show segment:offset pairs in hexadecimal, which is by
far the easiest numbering scheme for memory addressing.) Both
segments and offsets are 16-bit values.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Wait one minute! We're just looking for 20-bit addresses, not 32-bit
addresses. Why
do we need 16 bits of segment and 16 bits of offset?</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Actually, we <i>don't</i>
need 16 bits of segment. We could manage to address 1 Mb perfectly
well with a mere 4 bits of segment, but that's not the way Intel set
up the segment:offset addressing scheme. I might add that there's
some justification for using segments and offsets. The
segment:offset approach is a reasonable compromise between the needs
to use memory efficiently and keep chip costs down that predominated
in the late 1970s and the need to use an architecture that could
stretch to accommodate the far more sophisticated memory demands of
the 8088's successors. The 80286 uses an extension of the
segment:offset approach to address 16 Mb of memory in a fully
protected multitasking environment, and the 80386 goes far beyond
that, as we'll see in Chapter 15.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Anyway, although we
only need 4 bits of segment, we get 16 bits, and none of them are
ignored by the 8088. 20-bit addresses are formed from segment:offset
pairs by shifting the segment 4 bits to the left and adding it to the
offset, as shown in Figure 7.1.</font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_m56831418.jpg" align="bottom" border="0" height="639" width="616"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> I'd
like to take a
moment to note that for the remainder of this book, I'll use light
lines to signify memory addressing in figures and heavy lines to show
data movement, as illustrated by Figure 7.1. In the future, I'll
show segment:offset memory addressing by simply joining the lines
from the segment register and any registers and/or displacements
(fixed values) used to generate an offset, as in Figure 7.7, avoiding
the shift-and-add complications of Figure 7.1(A); the 4-bit left
shift of the segment and the addition to the offset to generate a
20-bit memory address, which occurs whenever a segment:offset address
is used, is implied. Also, when the segment isn't germane to the
discussion at hand, I may omit it and show only the offset component
or components, as in Figure 7.4; although unseen, the segment is
implied, since one segment register must participate in forming
virtually every 20-bit memory address, as we'll see shortly.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Figure 7.1 also
illustrates another practice I'll follow in figures that involve
memory addressing: the shading of registers and memory locations
that change value. This makes it easy to spot the effects of various
operations. In Figure 7.1, only the contents of AL are altered;
consequently, only AL is shaded.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">I'll generally follow
the sequence of Figure 7.1 &#8212; memory address, memory access,
final state of the PC &#8212; in memory addressing figures. While
this detailed, step-by-step approach may seem like a bit of overkill
right now, it will be most useful for illustrating the 8088's more
complex instructions, particularly the string instructions.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Finally, the numbers
in Figure 7.1 &#8212; including both addresses and data &#8212; are
in hexadecimal. Numbers in all figures involving memory addressing
will be in hexadecimal unless otherwise noted.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> To
continue with our
discussion of segment:offset addressing, shifting a segment value
left 4 bits is equivalent to shifting it left 1 hexadecimal digit &#8212;
one reason that hexadecimal is a useful notation for memory
addresses. Put another way, if the segment is the hexadecimal value
<i>ssss</i> and the offset is the hexadecimal value <i>xxxx</i>,
then
the 20-bit memory address <i>mmmmm</i> is calculated as
follows:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> </b></font><font color="#890000"><i><b>ssss</b></i></font><font color="#890000"><b>0</b></font></font></font></p>
<p class="western" style="margin-top: 0in; margin-bottom: 0in; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> + </b></font><font color="#890000"><i><b>xxxx</b></i></font></font></font></p>
<p class="western" style="margin-top: 0in; margin-bottom: 0in; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> --------------</b></font></font></font></p>
<p class="western" style="margin-top: 0in; margin-bottom: 0in; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> =
</b></font><font color="#890000"><i><b>mmmmm</b></i></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">For
example, the 20-bit
memory address corresponding to 23F0:1512 is 25412 (hex) arrived at
as follows:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> 23F00</b></font></font></font></p>
<p class="western" style="margin-top: 0in; margin-bottom: 0in; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> + 1512</b></font></font></font></p>
<p class="western" style="margin-top: 0in; margin-bottom: 0in; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ------------</b></font></font></font></p>
<p class="western" style="margin-top: 0in; margin-bottom: 0in; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> =
25412</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> By
the way, it happens
that the 8088 isn't particularly fast at calculating 20-bit addresses
from segment:offset pairs. Although it only takes the 8088's Bus
Interface Unit 4 cycles to complete a memory access, the fastest
memory-accessing instruction the PC has to offer (<b>xlat</b>)
takes
10 cycles to run. Other memory-accessing instructions take longer,
some much longer. We'll delve into the implications of the 8088's
lack of memory-access performance shortly.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Several questions
should immediately leap into your mind if you've never encountered
segments and offsets before. Where do these odd beasts live? What's
to prevent more than one segment:offset pair from pointing to the
same 20-bit address? What happens when the sum of the two gets too
large to fit in 20 bits?</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> To
answer the first
question first, segment values reside in the four segment registers:
CS, DS, ES, and SS. One (and only one) of these four registers
participates in calculating the address for almost every single
memory access the PC makes. (Interrupts are exceptions to this rule,
since interrupt vectors are read from fixed locations in the first 1
Kb of memory.) Segments are, practically speaking, part of every
memory access your code will ever make.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> CS
is always used for
code addresses, such as addresses involved in instruction fetching
and branching. DS is usually used for accessing memory operands;
most instructions can use any segment to access memory operands, but
DS is generally the most efficient register for data access. SS is
used for maintaining the stack, and is used to access data in stack
frames. Finally, ES is used to access data anywhere in the 8088's
address space; since it's not dedicated to any other purpose, it's
useful for pointing to rarely-used segments. ES is particular useful
in conjunction with the string instructions, as we'll see in Chapter
10. In Chapter 6 we discussed exactly what sort of memory accesses
operate relative to each segment register by default; we'll continue
that discussion later in this chapter, and look at ways to override
the default segment selections in some cases.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Offsets are not so
simple as segments. The 8088 can calculate offsets in a number of
different ways, depending on the addressing mode being used. Both
registers and instructions can contain offsets, and registers and/or
constant values can be added together on the fly by the 8088 in order
to calculate offsets. In various addressing modes, components of
offsets may reside in BX, BP, SI, DI, SP, and AL, and offset
components can be built into instructions as well.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">We'll discuss the
loading and use of the segment registers and the calculation and use
of offsets below. First, though, let's answer our two remaining
questions.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_SEGMENT:OFFSET_PAIRS_AREN'T"></a><a class="western" href="#T0703"><font size="4"><b>SEGMENT:OFFSET
PAIRS AREN'T UNIQUE</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In
answer to question
number two, "What's to prevent more than one segment:offset pair
from pointing to the same 20-bit address?" the answer is: nothing.
There's no rule that says two segment:offset pairs can't
point to the same address, and in fact many segment:offset pairs do
evaluate to any given address &#8212; 4096 segment:offset pairs for
every address, to be precise. For example, the following
segment:offset pairs all point to the 20-bit address 00410: 0000:0410,
0001:0400, 0002:03F0, 0003:03E0, and so on up to
0041:0000.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> You
may have noticed
that we've only accounted for 42h segment:offset pairs, not 4096 of
them, and that leads in neatly to the answer to our third and final
question. When the sum of a segment shifted left 4 bits and an
offset exceeds 20 bits, it wraps back around to address 00000.
Basically, any bits that carry out of bit 19 (into what would be bit
20 if the 8088 had 21 addressing bits) are thrown away. The
segment:offset pair FFFF:0010 points to the address 00000 as follows:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> FFFF0</b></font></font></font></p>
<p class="western" style="margin-top: 0in; margin-bottom: 0in; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> + 0010</b></font></font></font></p>
<p class="western" style="margin-top: 0in; margin-bottom: 0in; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ------------</b></font></font></font></p>
<p class="western" style="margin-top: 0in; margin-bottom: 0in; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> 100000</b></font></font></font></p>
<p class="western" style="margin-top: 0in; margin-bottom: 0in; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ^</b></font></font></font></p>
<p class="western" style="margin-top: 0in; margin-bottom: 0in; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> carry</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> </b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">with
the 1 that carries
out of bit 19 discarded to leave 00000.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Now
we can see what
the other 4,000-odd segment:offset pairs that point to address 00410
are. FFFF:0420 points to 00410, as do FFFE:0430, F042:FFF0, and a
host of segment:offset pairs in between. I doubt you'll want to take
advantage of that knowledge (in fact, there is a user-selectable
trick that can be played on the 80286 and 80386 to disable wrapping
at FFFFF, so you shouldn't count on wrapping if you can help it), but
if you <i>do</i> ever happen to address past the end of
memory,
that's how it works on the 8088.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_GOOD_NEWS_AND"></a><a class="western" href="#T0703"><font size="4"><b>GOOD
NEWS AND BAD NEWS</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Now
that we know how
segments and offsets work, what are the implications for assembler
programs? The obvious implication is that we can address 1 Mb of
memory, and that's good news, since we can use memory in myriad ways
to improve performance. For example, we'll see how look-up tables
can turn extra memory into improved performance later in this
chapter. Likewise, in Chapter 13 we'll see how in-line code lets you
trade off bytes for performance. Much of top-notch assembler
programming involves balancing memory requirements against
performance, so the more memory we have available, the merrier.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
bad news is this: while there's a lot of memory, it's only available in
64 Kb chunks. The four segment registers can only point to four 64 Kb
segments at
any one time, as shown in Figure 7.2. </font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_m40800168.jpg" align="bottom" border="0" height="617" width="616"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">If
you want to access a
memory location that's not in any of the four currently pointed-to
segments, there is <i>no way</i> to do that with a single
instruction. You must first load a segment register to point to a
segment containing the desired memory location, a process which takes
a minimum of 1 and often 2 instructions. Only then can you access
the desired memory location.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Worse, there are
problems dealing with blocks of memory larger than 64 Kb, because
there's no easy way to perform calculations involving full 20-bit
addresses, and because 64 Kb is the largest block of memory that can
be addressed by way of a single segment register without reloading
the segment register. It's easy enough to access a block up to 64 Kb
in size; point a register to the start of the block, and then point
wherever you wish. For example, the following bit of code would
calculate the 16-bit sum of all the bytes in a 64 Kb array:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov bx,seg
TestArray</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ds,bx ;point
to segment:offset of start of</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov bx,offset
TestArray ;array to sum</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> sub cx,cx ;count
64 K bytes</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ax,cx ;set
initial sum to 0</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov dh,ah ;set
DH to 0 for summing later</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>SumLoop:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov dl,[bx] ;get
the next array element</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> add ax,dx ;add
the array element to the sum</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> inc bx ;point
to the next array element</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> loop SumLoop</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Easy enough, eh? Ah,
but it all falls apart when a block of memory is larger than 64 Kb,
or when a block crosses a segment boundary. The problem is that in
either of those cases the segment must change as well as the offset,
for there's simply no way for an offset to reach more than 64 K bytes
away from any given segment register setting. If a register
containing an offset reaches the end of a segment (reaches the value
0FFFFh), then it simply wraps back to zero when it's incremented.
Likewise, the instruction sequence:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov si,0ffffh</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov al,[si+1]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">merely
manages to load
AL with the contents of offset 0. Basically, whenever an offset
exceeds 16 bits in size, the excess bits are ignored, just as the
excess bits are ignored when a segment:offset pair adds up to an
address past the 1 Mb overall limit on 8088 memory.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> So
we need to work
with the whole segment:offset pair in order to handle blocks larger
than 64 Kb. Is that such a problem? Unfortunately, the answer is
yes. The 8088 has no particular aptitude for calculations involving
more than 16 bits, and is very bad at handling segments. There's no
way to increment a segment:offset pair as a unit, and in fact there's
no way to modify a segment register other than copying it to a
general-purpose register, modifying that register, and copying the
result back to the segment register. All in all, it's as difficult
to work with blocks of memory larger than 64 Kb as it is easy to work
with blocks no larger than 64 Kb.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> For
example, here's
typical code to calculate the 16-bit sum of a 128 Kb array, of the
sort that a high-level language might generate (actually, the
following code is a good deal <i>better</i> than most
high-level
languages would generate, but what the heck, let's give them the
benefit of the doubt!):</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov bx,seg
TestArray</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ds,bx ;point
to segment:offset of start of</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov bx,offset
TestArray ;array to sum</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> sub cx,cx ;count
128 K bytes with SI:CX</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov si,2</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ax,cx ;set
initial sum to 0</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov dh,ah ;set
DH to 0 for summing later</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>SumLoop:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov dl,[bx] ;get
the next array element</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> add ax,dx ;add
the array element to the sum</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> inc bx ;point
to the next array element</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> and bx,0fh ;time
to advance the segment?</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jnz SumLoopEnd ;not
yet</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov di,ds ;advance
the segment by 1; since BX has</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> inc di ;
just gone from 15 to 0, we've advanced</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ds,di ;
1 byte in all</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>SumLoopEnd:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> loop SumLoop ;count
down 32-bit counter</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> dec si</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jnz SumLoop</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_MORE_GOOD_NEWS"></a><a class="western" href="#T0703"><font size="4"><b>MORE
GOOD NEWS</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">While the above is
undeniably a mess, things are not quite so grim as they might seem. In
fact, the news is quite good when it comes to handling multiple
segments in assembler. For one thing, assembler is <i>much</i>
better than other languages at handling segments efficiently. Only
in assembler do you have complete control over all your segments;
that means that you can switch the segments as needed in order to
make sure that they are pointing to the data you're currently
interested in. What's more, in assembler you can structure your code
and data so that it falls naturally into 64 Kb blocks, allowing most
of your accesses at any one time to fall within the currently loaded
segments.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In
high-level
languages you almost always suffer both considerable performance loss
and significant increase in code size when you start using multiple
code or data segments, but in assembler it's possible to maintain
near-peak performance even with many segments. In fact,
segment-handling is one area in which assembler truly distinguishes
itself, and we'll see examples of assembler's fine touch with
segments in this chapter, Chapter 14, and Volume II of <i>The
Zen of
Assembly Language</i>.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">There's one more
reason that handling multiple code or data segments isn't much of a
problem in assembler, and that's that the assembler programmer knows
exactly what his code needs to do and can optimize accordingly. For
example, suppose that we know that the array <b>TestArray</b>
in the
last example is guaranteed to start at offset 0 in the initial data
segment. Given that extra knowledge, we can put together the
following version of the above code to sum a 128 Kb array:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov bx,seg
TestArray</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ds,bx ;point
to segment:offset of start of</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> sub bx,bx ;array
to sum, which we know starts</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ;
at offset 0</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov cx,2 ;count
two 64 Kb blocks</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> sub ax,ax ;set
initial sum to 0</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov dh,ah ;set
DH to 0 for summing later</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>SumLoop:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov dl,[bx] ;get
the next array element</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> add ax,dx ;add
the array element to the sum</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> inc bx ;point
to the next array element</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jnz SumLoop ;until
we wrap at the end of a 64 Kb block</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov si,ds</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> add si,1000h ;advance
the segment by 64 K bytes</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ds,si</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> loop SumLoop ;count
off this 64 Kb block</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Compare the code
within the inner loop above to that in the inner loop of the previous
version of this example &#8212; the difference is striking. This
inner loop is every bit as tight as that of the code for handling
blocks 64 Kb-and-less in size; in fact, it's slightly <i>tighter</i>,
as <b>jnz</b> is faster than <b>loop</b>.
Consequently, there
shouldn't be much difference in performance between the last example
and the 64 Kb and less version. Nonetheless, a basic rule of the Zen
of assembler is that we should check our assumptions, so let's toss
the three approaches to summing arrays into the Zen timer and see
what comes out.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <a name="L701R"></a><a class="western" href="#L701">Listing
7-1</a><font color="#000099"> </font>measures
the time required to
calculate the 16-bit sum of a 64 Kb block without worrying about
segments. This code runs in 619 ms, or 9.4 us per byte summed. (Note
that <a class="western" href="#L701">Listings 7-1</a>
through
<a class="western" href="#L703">7-3</a> must
be timed with the
long-period Zen timer &#8212; via LZTIME.BAT &#8212; since they take
more than 54 ms to run.)</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <a name="L702R"></a><a class="western" href="#L702">Listing
7-2</a><font color="#000099"> </font>measures
the time required to
calculate the 16-bit sum of a 128 Kb block. As is always the case
with a memory block larger than 64 Kb, segments must be dealt with,
and that shows in the performance of <a class="western" href="#L702">Listing
7-2</a><font color="#000099">:</font> 2044 ms,
or 15.6 us per byte
summed. In other words, <a class="western" href="#L701">Listing
7-1</a><font color="#000099">,</font>
which doesn't concern itself with segments, sums bytes 66% faster
than <a class="western" href="#L702">Listing 7-2</a><font color="#000099">.</font></font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Finally, <a class="western" href="#L703">Listing
7-3</a> implements 128 Kb-block-handling code that takes
advantage of
the knowledge that the block of memory being summed starts at offset
0 in the initial data segment. We've speculated that <a name="L703R"></a><a class="western" href="#L703">Listing
7-3</a> should perform on a par with <a class="western" href="#L703">Listing
7-3</a>, since their inner loops are similar...and the Zen timer
bears that out, reporting that <a class="western" href="#L703">Listing
7-3</a> runs in 1239 ms &#8212; 9.5 us per byte summed.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Assumptions confirmed.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_NOTES_ON_OPTIMIZATION"></a><a class="western" href="#T0703"><font size="4"><b>NOTES
ON OPTIMIZATION</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">There are several
points to be made about <a class="western" href="#L701">Listings
7-1</a>
through <a class="western" href="#L703">7-3</a>.
First, these
listings graphically illustrate that you should focus your
optimization efforts on inner loops. <a class="western" href="#L703">Listing
7-3</a> is considerably bigger and more complex than <a class="western" href="#L701">Listing
7-1</a><font color="#000099">,</font> but by
moving the complexity
and extra bytes out of the inner loop, we've managed to keep
performance high in <a class="western" href="#L703">Listing
7-3</a>.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Now, you may well
object that in the process of improving the performance of <a class="western" href="#L703">Listing
7-3</a>, we've altered the code so that it will only work under
certain circumstances, and that's my second point. Truly
general-purpose code runs slowly, no matter whether it's written in
assembler, C, BASIC, or COBOL. Your advantage as a programmer &#8212;
and your <i>great</i> advantage as an assembler programmer
&#8212; is
that you know exactly what your code needs to do...so why write code
that wastes cycles and bytes doing extra work? I stipulated that the
start offset was at 0 in the initial data segment, and <a class="western" href="#L703">Listing
7-3</a> is a response to that stipulation. If the conditions to
be
met had been different, then we would have come up with a different
solution.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Do
you see what I'm
driving at? I hope so, for it's central to the Zen of assembler. A
key to good assembler code is to write lean code. Your code should
do everything you need done &#8212; and nothing more.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">I'll finish up by
pointing out that <a class="western" href="#L701">Listings
7-1</a>
through <a class="western" href="#L703">7-3</a>
are excellent
examples of both the hazards of using memory blocks larger than 64 Kb
and of the virtues of using assembler when you must deal with large
blocks. It's rare that you'll be able to handle larger-than-64 Kb
blocks as efficiently as blocks that fit within a single segment;
<a class="western" href="#L703">Listing 7-3</a>
does take advantage
of a very convenient special case. However, it's equally rare that
you won't be able to handle large blocks much more efficiently in
assembler than you ever could in a high-level language.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_A_FINAL_WORD"></a><a class="western" href="#T0703"><font size="4"><b>A
FINAL WORD ON SEGMENT:OFFSET ADDRESSING</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Let's review what
we've learned about segment:offset addressing and assembler. The
architecture of the 8088 limits us to addressing at most four
segments &#8212; 64 Kb blocks of memory &#8212; at any time, with
each segment pointed to by a different segment register. Accessing
data in a segment that is not currently pointed to by any segment
register is a time-consuming, awkward process, as is handling data
that spans multiple blocks. Fortunately, assembler is adept at
handling segments, and gives us considerable freedom to structure our
programs so that we're usually working within the currently loaded
segments at any one time.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> On
balance,
segment:offset addressing is one of the less attractive features of
the 8088. For us, however, it's actually an advantage, since it
allows assembler, with its superb control over the 8088, to far
outstrip high-level languages. We won't deal with segments a great
deal in the remainder of this volume, since we'll be focusing on
detailed optimizations, but the topic will come up from time to time.
In Volume II, we'll tackle the subject of segment management in a
big way.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
remainder of this
chapter will deal only with data addressing &#8212; that is, the
addressing of instruction operands. Code addressing &#8212; in the
forms of instruction fetching and branching &#8212; is a very real
part of PC performance (heck, instruction fetching is perhaps the
single most important performance factor of all!), but it's also very
different from the sort of memory addressing we'll be discussing. We
learned as much as we'll ever need to know (and possibly more) about
instruction fetching back in Chapters 4 and 5, so we won't pursue
that aspect of code addressing any further. However, Chapters 12
through 14 discuss code addressing as it relates to branching in
considerable detail.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h2 class="western"><font color="#110d06"><font color="#0b0703"><a name="_SEGMENT_HANDLING"></a><a class="western" href="#T0704"><font style="font-size: 16pt;" size="4"><b>7.4
SEGMENT HANDLING</b></font></a></font></font></h2>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Now
that we know what
segments are, let's look at ways to handle the segment registers, in
particular how to load them quickly. What we are <i>not</i>
going to
do is discuss the directives that let you create segments and the
storage locations within them.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Why
not discuss the
segment directives? For one thing, there are enough directives,
segment and otherwise, to fill a book by themselves. For another
thing, there are already several such books, including both the
manuals that come with MASM and TASM and the other books in this
series. <i>The Zen of Assembly Language</i> is about
writing
efficient code, not using MASM, so I'll assume you already know how
to use the <b>segment</b>, <b>ends</b>, and <b>assume</b>
directives
to define segments and <b>db</b>, <b>dw</b>,
and the like to create
and reserve storage. If that's not the case, brush up before you
continue reading. We'll use all of the above directives in <i>The
Zen of Assembly Language</i>, and we'll discuss <b>assume</b>
at some
length later in this chapter, but we won't spend time covering the
basic functionality of the segment and data directives.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_WHAT_CAN_YOU"></a><a class="western" href="#T0704"><font size="4"><b>WHAT
CAN YOU DO WITH SEGMENT REGISTERS? NOT MUCH</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Segment registers are
by no means as flexible as general-purpose registers. What can't you
do with segment registers that you can do with general-purpose
registers? Let me answer that question by way of a story.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">There's a peculiar
sort of "find the mistake" puzzle that's standard fare in
children's magazines. Such puzzles typically consist of a drawing
with a few intentional mistakes (a farmer milking a donkey, for
example &#8212; a risky proposition at best), captioned, "What's
wrong with this picture?" Invariably, the answer is printed
upside down at the bottom of the page.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> I
dimly recall from my
childhood a takeoff that <i>MAD</i> magazine did on those
puzzles. <i>MAD</i> showed a picture in which everything &#8212;
and I do mean
<i>everything</i> &#8212; was wrong. Just as with the real McCoy,
this picture was accompanied by the caption, "What's wrong with
this picture?", and by the answer at the bottom of the page.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In <i>MAD</i>,
the
answer was: "Better yet, what's <i>right</i> with this
picture?"</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Segment registers are
sort of like <i>MAD</i>'s puzzles. What can't you do with
segment
registers? Better yet, what <i>can</i> you do with segment
registers? Well, you can use them to address memory &#8212; and
that's about it.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Any
segment register
can be copied to a general-purpose register or memory location. Any
segment register other than CS can be loaded from a general-purpose
register or memory location. Any segment register can be pushed onto
the stack, and any segment register but CS can be popped from the
stack.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> And
that's <i>all</i>.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Segment registers
can't be used for arithmetic. They can't be operands to logical
instructions, and they can't take part in comparisons. One segment
register can't even be copied directly to another segment register.
Basically, segment registers can't do a blessed thing except get
loaded and get copied to a register or memory.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Now, there <i>are</i>
reasons why segments are so hard to work with. For one thing, it's
not all that important that segment registers be manipulated quickly.
Segment registers aren't changed as often as general-purpose
registers &#8212; at least, they shouldn't be, if you're interested
in decent performance. Segment registers rarely need to be
manipulated arithmetically or logically, and when the need does
arise, they can always be copied to general-purpose registers and
manipulated there. Nonetheless, greater flexibility in handling
segment registers would be nice; however, a major expansion of the
8088's instruction set &#8212; requiring additional circuitry inside
the 8088 &#8212; would have been required in order to allow us to
handle segment registers like general-purpose registers, and it seems
likely that the 8088's designers had other, higher-priority uses for
their limited chip space.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">There's another reason
why segments can only be loaded and copied, nothing else, and it has
to do with the protected mode of the 80286 and 80386 processors.
Protected mode, which we'll return to at a bit more length in Chapter
15, is a second mode of the 80286 and 80386 that's not compatible
with either MS-DOS or the 8088, but which makes much more memory
available for program use than the familiar 1 Mb of
MS-DOS/8088-compatible real mode.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In
protected mode, the
segment registers don't contain memory addresses; instead, they
contain segment selectors, which the 80286 and 80386 use to look up
the actual segment information &#8212; location and attributes such
as writability &#8212; in a table. Not only would it make no sense
to perform arithmetic and the like on segment selectors, since
selectors don't correspond directly to memory addresses, but because
the segment registers are central to the memory protection scheme of
the 80286 and 80386, they simply <i>cannot</i> be loaded
arbitrarily
&#8212; the 80286 and 80386 literally don't allow that to happen by
instantly causing a trap whenever an invalid selector is loaded.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">What's more, it can
take quite a while to load a segment register in protected mode. In
real mode, moves to and from segment registers are just as fast as
transfers involving general-purpose registers, but that's not the
case in protected mode. For example, <b>mov es,ax</b>
takes 2 cycles
in real mode and 17 cycles in protected mode.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Given all of the
above, all you'd generally want to do in protected mode is load the
segment registers with known-good segment selectors provided to you
by the operating system. That doesn't affect real mode, which is all
we care about, but since real mode and protected mode share most
instructions, the segment-register philosophy of protected mode
(which Intel no doubt had as a long-range goal even before they
designed the 8088) carries over to real mode.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> And
now you know why
the 8088 offers so little in the way of segment-register manipulation
capability.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_USING_SEGMENT_REGISTERS"></a><a class="western" href="#T0704"><font size="4"><b>USING
SEGMENT REGISTERS FOR TEMPORARY STORAGE</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">That brings us to
another interesting point: the use of segment registers for
temporary storage. The 8088 has just 7 available general-purpose
registers (remember, we can't use SP for anything but the stack most
of the time), and sometimes it would be awfully handy to have
somewhere to store a 16-bit value for a little while. Can we use the
segment registers for that purpose?</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Some people would
answer that "No," because code that uses segments for
temporary storage can't easily be ported to protected mode. I don't
buy that, for reasons I'll explain when we get to <b>les</b>.
My
answer is "Yes...when they're available." Two of the
segment registers are never available, one is occasionally available,
and one may or may not be readily available, depending on your code.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Some segments are
always in use. CS is always busy pointing to the segment of the next
instruction to be executed; if you were to load CS with an arbitrary
value for even 1 instruction, your program would surely crash. Clearly,
it's not a good idea to use CS for temporary storage. (Actually, this
isn't even a potential problem, as Intel has
thoughtfully not implemented the instructions &#8212; <b>mov</b>
and
<b>pop</b> &#8212; that might load CS directly; MASM will simply
generate an error if you try to assemble <b>pop cs</b> or <b>mov
cs,[</b><i><b>mem16</b></i><b>]</b>.
CS can only be loaded by far
branches: far calls, far returns, far jumps, and interrupts.)</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> SS
isn't in use during
every cycle as CS is, but unless interrupts are off, SS <i>might</i>
be used on any cycle. Even if interrupts are off, non-maskable
interrupts can occur, and of course your code will often use the
stack directly. The risks are too great, the rewards too few. Don't
use SS for temporary storage.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> DS
can be used for
temporary storage whenever it's free. However, DS is usually used to
point to the default data segment. It's rare that you'll have a tight
loop in which memory isn't accessed (it's not worth bothering with
such optimizations outside the tightest, most time-critical code),
and memory is usually most efficiently accessed via DS. There
certainly are loops in which DS is free &#8212; loops which use <b>scas</b>
to scan the segment pointed to by ES, for example &#8212; but such
cases are few and far between. Far more common is the case in which
DS is saved and then pointed to another segment, as follows:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> push ds ;preserve
normal DS setting</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov bx,seg
TestArray</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ds,bx ;point
DS:BX to array in which</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov bx,offset
TestArray ; to flip all bits</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov cx,TEST_ARRAY_LENGTH
;# of bytes to flip</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>FlipLoop:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> not byte
ptr [bx] ;flip all bits in current byte</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> inc bx ;point
to next byte</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> loop FlipLoop</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> pop ds ;restore
normal DS setting</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">This
approach allows
instructions within the loop to access memory without the segment
override prefix required when ES is used. (More on segment override
prefixes shortly.)</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In
short, feel free to
use DS for temporary storage if it's free, but don't expect that to
come up too often.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Which brings us to the
use of ES for temporary storage. ES is by far the best segment
register to use for temporary storage; not being dedicated to any
full-time function, it's usually free for any sort of use at all,
including temporary storage.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Let's look at an
example of code that uses ES for temporary storage to good effect. This
sample code sums selected points in a two-dimensional word-sized
array. Let's start by tallying up the registers this code will use. (A
bit backwards, true, but we're focusing on the use of ES for
temporary storage at the moment, and this is the best way to go about
it.)</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In
the sample code,
the list of subscripts of points to be added in the major dimension
will be stored at DI, and the list of subscripts in the minor
dimension will stored at BX. CX will contain the number of points to
be summed, and BP will contain the final sum. AX and DX will be used
for multiplying, and, as usual, SP will be used to point to the
stack. Finally, when the code begins, SI will contain the offset of
the start of the array.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Let's see...that
covers all eight general-purpose registers. Unfortunately, we need
yet another storage location, this one to serve as a working pointer
into the array. There are many possible solutions to this problem,
including using the <b>xchg</b> instruction (which we'll
cover in the
next chapter), storing values in memory (slow), pushing and popping
SI (also slow), or disabling interrupts and using SP (can unduly
delay interrupts and carries some risk). Instead, here's a solution
that uses ES for temporary storage; it's not necessarily the <i>best</i>
solution, but it does nicely illustrate the use of ES for temporary
storage:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;
Sums selected points in a two-dimensional array.</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;
Input:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>; BX
= list of minor dimension coordinates to sum</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>; CX
= number of points to sum</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>; DS:SI
= start address of array</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>; DI
= list of major dimension coordinates to sum</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;
Output:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>; BP
= sum of selected points</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;
Registers altered: AX, BX, CX, DX, SI, DI, BP, ES</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov es,si ;set
aside the array start offset</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> sub bp,bp ;initialize
sum to 0</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>TwoDimArraySumLoop:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ax,ARRAY_WIDTH ;convert
the next major dimension</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mul word
ptr [di] ;coordinate to an offset in the array</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ;
(wipes out DX)</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> add ax,[bx] ;add
in the minor dimension coordinate</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> shl ax,1 ;make
it a word-sized lookup</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov si,es ;point
to the start of the array</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> add si,ax ;point
to the desired data point</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> add bp,[si] ;add
it to the total</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> inc di ;point
to the next major dimension coordinate</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> inc di</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> inc bx ;point
to the next minor dimension coordinate</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> inc bx</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> loop TwoDimArraySumLoop</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> If
you find yourself
running out of registers in a tight loop and you're not using the
segment pointed to by ES, by all means reload one of your registers
from ES if that will help.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_SETTING_AND_COPYING"></a><a class="western" href="#T0704"><font size="4"><b>SETTING
AND COPYING SEGMENT REGISTERS</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> As
I've said, loading
segment registers is one area in which assembler has a tremendous
advantage over high-level languages. High-level languages tend to use
DS to point to a default data segment all the time, loading ES every
single time any other segment is accessed. In assembler, we can
either load a new segment into DS as needed, or we can load ES and
leave it loaded for as long as we need to access a given segment.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">We'll see examples of
efficient segment use throughout <i>The Zen of Assembly Language</i>,
especially when we discuss strings, so I'm not going to go into more
detail here. What I am going to do is discuss the <i>process</i>
of
loading segment registers, because it is by no means obvious what the
most efficient segment-loading mechanism is.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> For
starters, let's
divide segment loading into two categories: setting and copying.
Segment setting refers to loading a segment register to point to a
certain segment, while segment copying refers to loading a segment
register with the contents of another segment register. I'm making
this distinction because the instruction sequences used for the two
sorts of segment loading differ considerably.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Let's tackle segment
copying first. Segment copying is useful when you want two segment
registers to point to the same segment. For example, you'll want ES
to point to the same segment as DS if you're using <b>rep movs</b>
to
copy data within the segment pointed to by DS, because DS and ES are
the default source and destination segments, respectively, for <b>movs</b>.
There are two good ways to load ES to point to the same segment as
DS, given that we can't copy one segment register directly to another
segment register:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> push ds</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> pop es</b></font></font></font></p>

<p class="western" style="margin-bottom: 0in; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"> and:</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ax,ds</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov es,ax</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">(Any
general-purpose
register would serve as well as AX.)</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Each of the above
approaches has its virtues. The <b>push</b>/<b>pop</b>
approach is
extremely compact, at just 2 bytes, and affects no other registers.
Unfortunately, it takes a less-than-snappy 27 cycles to run. By
contrast, the <b>mov</b>/<b>mov</b> approach
officially takes just 4
cycles to run; 16 cycles (4 bytes at 4 cycles to fetch each byte) is
a more realistic figure, but either way, <b>mov</b>/<b>mov</b>
is
clearly faster than <b>push</b>/<b>pop</b>. On
the other hand,
<b>mov</b>/<b>mov</b> takes twice as many bytes
as <b>push</b>/<b>pop</b>,
and destroys the contents of a general-purpose register as well.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">There's no clear
winner here. Use the <b>mov</b>/<b>mov</b>
approach to copy segment
registers when you're interested in speed and can spare a
general-purpose register, and use the <b>push</b>/<b>pop</b>
approach
when bytes and/or registers are at a premium. I'll use both
approaches in this book, generally using <b>push</b>/<b>pop</b>
in
non-time-critical code and <b>mov</b>/<b>mov</b>
when speed really
counts. Why waste the bytes when the cycles don't matter?</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">That brings us to an
important point about assembler programming. There is rarely such a
beast as the "best code" in assembler; instead, there's
code that's good in a given context. In any situation, the choice
between fast code, small code, understandable code, portable code,
maintainable code, structured code, and whatever other sort of code
you can dream up is purely up to you. If you make the right
decisions, your code will beat high-level language code hands down,
because you know more about your code and can think far more flexibly
than any high-level language possibly can.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Now
let's look at ways
to set segment registers. Segment registers can't be loaded directly
with a segment value, but they can be loaded either through a
general-purpose register or from memory. The two approaches aren't
always interchangeable: one requires that the segment name be
available as an immediate operand, while the other requires that a
memory variable be set to the desired segment value. Nonetheless,
you can generally set things up so that either approach can be used,
if you really want to &#8212; so which is best?</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Well, loading a
segment register through a general-purpose register, as in:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ax,DATA</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov es,ax</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">officially
takes 6
cycles. Since the two instructions together are 5 bytes long,
however, this approach could take as much a 20 cycles if the prefetch
queue is empty. By contrast, loading from memory, as in:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov es,[DataSeg]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">officially
takes only
18 cycles, is only 4 bytes long, and doesn't destroy a
general-purpose register. (Note that the last approach assumes that
the memory variable <b>DataSeg</b> has previously been set
to point
to the desired segment.) Loading from memory sounds better, doesn't
it?</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> It
isn't.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Remember, it's not
just the number of instruction byte fetches that affects performance
&#8212; <i>it's the number of memory accesses of all sorts</i>.
When
a segment register is loaded from memory, 2 memory accesses are
performed to read the segment value; together with the 4 instruction
bytes, that means that 6 memory accesses in all are performed when a
segment register is loaded from memory. What that means is that
loading a segment register from memory takes anywhere from 18 to 24
(6 memory accesses at 4 cycles per access) cycles, which stacks up
poorly against the 6 to 20 cycles required to load a segment register
through a general-purpose register.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In
short, it's clearly
fastest to load segment registers through general-purpose registers.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">That's not to say that
there aren't times when you'll want to load a segment register
directly from memory. If you're <i>really</i> tight on
space, you
can save a byte every time you load a segment by using the 4-byte
load from memory rather than the 5-byte load through a
general-purpose register. (This is only worthwhile if there are
multiple segment load instructions, since the memory variable
containing the segment address takes 2 bytes.) Also, if the segment
you want to work with varies as your program runs (for example, if
your code can access either display memory or a display buffer in
system RAM), then loading the segment register from memory is the way
to go. The following code is clearly the best way to load ES to
point to a display buffer that may be at any of several segments:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov es,[DisplayBufferSegment]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">Here,
<b>DisplayBufferSegment</b> is set externally to point to
the segment
in which all screen drawing should be performed at any given time.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Finally, segments are
often passed as stack frame parameters from high-level languages to
assembler subroutines &#8212; to point to far data buffers and the
like &#8212; and in those cases segments can best be loaded directly
from stack frames into segment registers. (We'll discuss stack frames
later in this chapter.) It's easy to forget that segments can be
loaded directly from <i>any</i> addressable memory
location, as we'll
see in Chapter 16; all too many people load segments from stack
frames like this:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ax,[bp+BufferSegment]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov es,ax</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">when
the following is
shorter, faster, and doesn't use any general-purpose registers:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov es,[bp+BufferSegment]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> As
it happens, though,
lone segment values are rarely passed as stack frame parameters.
Instead, segment:offset pairs that provide a full 20-bit pointer to a
specific data element are usually passed. These can be loaded as
follows:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov es,[bp+BufferSegment]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov di,[bp+BufferOffset]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">However,
the designers
of the 8088 anticipated the need for loading 20-bit pointers, and
gave us two most useful instructions for just that purpose: <b>lds</b>
and <b>les</b>.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_LOADING_20-BIT_POINTERS"></a><a class="western" href="#T0704"><font size="4"><b>LOADING
20-BIT POINTERS WITH lds AND les</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <b>lds</b>
loads <i>both</i>
DS and any one general-purpose register from a doubleword of memory,
and <b>les</b> similarly loads <i>both</i> ES
and a general-purpose
register, as shown in Figure 7.3.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_1d3b858a.jpg" align="bottom" border="0" height="502" width="604"></font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">While both
instructions are useful, <b>les</b> is by far the more
commonly used
of the two. Since most programs leave DS pointing to the default
data segment whenever possible, it's rare that we'd want to load DS
as part of a segment:offset pointer. True, it does happen, but
generally only when we want to point to a block of far memory
temporarily for faster processing in a tight loop.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> ES,
on the other hand,
is the segment of choice when a segment:offset pointer is needed,
since it's not generally reserved for any other purpose. Consequently, <b>les</b>
is usually used to load segment:offset
pointers.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <b>lds</b>
and <b>les</b>
actually don't come in for all that much use in pure assembler
programs. The reason for that is that efficient assembler programs
tend to be organized so that segments rarely need to be changed, and
so such programs tend to work with 16-bit pointers most of the time.
After all, while <b>lds</b> and <b>les</b>
are efficient considering
all they do, they're still slow, with official execution times of at
least 29 cycles. If you need to load segment:offset pointers, use
<b>lds</b> and <b>les</b>, but try to load
just offsets whenever you
can.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> One
place where
there's no way to avoid loading segments is in assembler code that's
called from a high-level language, especially when the large data
model (the model that supports more than 64 Kb of data) is used. When a
high-level language passes a far pointer as a parameter to an
assembler subroutine, the full 20-bit pointer must be loaded from
memory before it can be used, and there <b>lds</b> and <b>les</b>
work beautifully.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Suppose that we have a
C statement that calls the assembler subroutine <b>AddTwoFarInts</b>
as follows:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> int
Sum;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> int
far *FarPtr1, far *FarPtr2;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> :</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> Sum
= AddTwoFarInts(FarPtr1, FarPtr2);</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><b>AddTwoFarInts</b>
could be written without <b>les</b> as follows:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>Parms struc</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> dw ? ;pushed
BP</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> dw ? ;return
address</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>Ptr1Offset dw ?</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>Ptr1Segment dw ?</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>Ptr2Offset dw ?</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>Ptr2Segment dw ?</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>Parms ends</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>AddTwoFarInts proc near</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> push bp ;save
caller's BP</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov bp,sp ;point
to stack frame</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov es,[Ptr1Segment] ;load
segment part of Ptr1</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov bx,[Ptr1Offset] ;load
offset part of Ptr1</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ax,es:[bx] ;get
first int to add</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov es,[Ptr2Segment] ;load
segment part of Ptr2</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov bx,[Ptr2Offset] ;load
offset part of Ptr2</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> add ax,es:[bx] ;add
the two ints together</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> pop bp ;restore
caller's BP</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ret</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>AddTwoFarInts endp</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">The
subroutine is
considerably more efficient when <b>les</b> is used,
however:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>Parms struc</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> dw ? ;pushed
BP</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> dw ? ;return
address</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>Ptr1 dd ?</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>Ptr2 dd ?</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>Parms ends</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>AddTwoFarInts proc near</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> push bp ;save
caller's BP</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov bp,sp ;point
to stack frame</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> les bx,[Ptr1] ;load
both segment and offset of Ptr1</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ax,es:[bx] ;get
first int to add</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> les bx,[Ptr2] ;load
both segment and offset of Ptr2</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> add ax,es:[bx] ;add
the two ints together</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> pop bp ;restore
caller's BP</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ret</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>AddTwoFarInts endp</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">(We'll
talk about
<b>struc</b>, stack frames, and segment overrides &#8212; such as
<b>es:</b>
&#8212; later in this chapter.)</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">High-level languages
use <b>les</b> all the time to point to data that's not in
the
default data segment, and that hurts performance significantly. Most
high-level languages aren't very smart about using <b>les</b>,
either. For example, high-level languages tend to load a full 20-bit
pointer into ES:BX every time through a loop, even though ES never
gets changed from the last pass through the loop. That's one reason
why high-level languages don't perform very well with more than 64 Kb
of data.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> You
can usually easily
avoid <b>les</b>-related performance problems in
assembler. Consider
<a name="L704R"></a><a class="western" href="#L704">Listing 7-4</a>,
which adds one far
array to another far array in the same way that most high-level
languages would, storing both far pointers in memory variables and
loading each pointer with <b>les</b> every time it's used.
(Actually,
<a class="western" href="#L704">Listing 7-4</a>
is better than your
average high-level language subroutine because it uses <b>loop</b>,
while most high-level languages use less efficient instruction
sequences to handle looping.) <a class="western" href="#L704">Listing
7-4</a> runs in 43.42 ms, or 43 us per array element addition.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Now
look at <a name="L705R"></a><a class="western" href="#L705">Listing
7-5</a>, which does exactly the same thing that <a class="western" href="#L704">Listing
7-4</a> does...except that it loads the far pointers <i>outside</i>
the loop and keeps them in the registers for the duration of the
loop, using the segment-loading techniques that we learned earlier in
this chapter. How much difference does it make to keep the far
pointers in registers at all times? <a class="western" href="#L705">Listing
7-5</a> runs in 19.69 ms &#8212; <i>more than twice as fast as
</i><a class="western" href="#L704">Listing
7-4</a>.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Now
you know why I
keep saying that assembler can handle segments much better than
high-level languages can. <a class="western" href="#L705">Listing
7-5</a> isn't the ultimate in that regard, however; we can carry
that
concept a step further still, as shown in <a name="L706R"></a><a class="western" href="#L706">Listing
7-6</a>.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <a class="western" href="#L706">Listing
7-6</a> brings the full power of assembler to bear on the task of
adding two arrays. <a class="western" href="#L706">Listing
7-6</a>sets
up the segments so that they never once need to be loaded within the
loop. What's more, <a class="western" href="#L706">Listing
7-6</a>
arranges the registers so that the powerful <b>lodsb</b>
string
instruction can be used in place of a <b>mov</b> and an <b>inc</b>.
(We'll discuss the string instructions in Chapter 10. For now, just
take my word that the string instructions are good stuff.) In short,
<a class="western" href="#L706">Listing 7-6</a>
organizes segment and
register usage so that as much work as possible is moved out of the
loop, and so that the most efficient instructions can be used.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
results are
stunning.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <a class="western" href="#L706">Listing
7-6</a> runs in just 13.79 ms, more than three times as fast as
<a class="western" href="#L704">Listing 7-4</a>,
even though <a class="western" href="#L704">Listing
7-4</a> uses the efficient <b>loop</b> and <b>les</b>
instructions. This example is a powerful reminder of two important
aspects of the
Zen of assembler. First, you must strive to play to the strengths of
the 8088 (such as the string instructions) while sidestepping its
weaknesses (such as the segments and slow memory access speed). Second,
<i>you must always concentrate on moving cycles out of loops</i>.
The <b>lds</b> and <b>les</b> instructions
outside the loop in
<a class="western" href="#L706">Listing 7-6</a>
effectively run 1000
times faster than the <b>les</b> instructions inside the
loop in
<a class="western" href="#L704">Listing 7-4</a>,
since the latter are
executed 1000 times but the former are executed only once.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_LOADING_DOUBLEWORDS_WITH"></a><a class="western" href="#T0704"><font size="4"><b>LOADING
DOUBLEWORDS WITH les</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">While <b>les</b> isn't
often used to load segment:offset pointers in pure assembler
programs, it has another less obvious use: loading doubleword values
into the general-purpose registers.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Normally, a doubleword
value is loaded into two general-purpose registers with two
instructions. Here's the standard way to load DX:AX from the
doubleword memory variable <b>DVar</b>:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ax,word
ptr [DVar]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov dx,word
ptr [DVar+2]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">There's
nothing <i>wrong</i>
with this approach, but it does take between 4 and 8 bytes and
between 34 and 48 cycles. We can cut the time nearly in half, and
can usually reduce the size as well, by using <b>les</b>
in a most
unusual way:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> les ax,[DVar]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov dx,es</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">The
only disadvantage
of using <b>les</b> to load doubleword values is that it
wipes out
the contents of ES; if that isn't a problem, there's simply no reason
to load doubleword values any other way.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Once again, there are
those people who will tell you that it's a bad idea to load ES with
anything but specific segment values, because such code won't work if
you port it to run in protected mode on the 80286 and 80836. While
that's a consideration, it's not an overwhelming one. For one thing,
most code will never be ported to protected mode. For another,
protected mode programming, which we'll touch on in Chapter 15,
differs from normal 8088 assembler programming in a number of ways;
using <b>les</b> to load doubleword values is unlikely to
be the most
difficult part of porting code to protected mode, especially if you
have to rewrite the code to run under a new operating system. Still,
if protected mode concerns you, use a macro such as:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>LOAD_32_BITS macro Address</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>ifdef
PROTECTED_MODE</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ax,word
ptr [Address]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov dx,word
ptr [Address+2]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>else</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> les ax,dword
ptr [Address]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov dx,ax</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>endif</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> endm</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> :</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> LOAD_32_BITS DwordVar</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">to
load 32-bit values.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
<b>les</b>
approach to loading doubleword values is not only fast but has a
unique virtue: it's indivisible. In other words, there's no way an
interrupt can occur after the lower word of a doubleword is read but
before the upper word is read. For example, suppose we want to read
the timer count the BIOS maintains at 0000:046C. We <i>could</i>
read the count like this:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> sub ax,ax</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov es,ax</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ax,es:[46ch]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov dx,es:[46eh]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">There's a problem with
this code, though. Every 54.9 ms, the timer generates an interrupt
which starts the BIOS timer tick handler. The BIOS handler then
increments the timer count. If an interrupt occurs right after <b>mov
ax,es:[46ch]</b> in the above code &#8212; before <b>mov
dx,es:[46eh]</b>
can execute &#8212; we would read half of the value before it's
advanced, and half of the value after it's advanced. If this
happened as an hour or a day turned over, we could conceivably read a
count that's seriously wrong, with potentially disastrous
implications for any program that relies on precise time
synchronization. Over time, such a misread of the timer is bound to
happen if we use the above code.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> We
could solve the
problem by disabling interrupts while we read the count:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> sub ax,ax</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov es,ax</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> cli</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ax,es:[46ch]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov dx,es:[46eh]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> sti</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">but
there's a better
solution. There's no way <b>les</b> can be interrupted as
it reads a
doubleword value, so we'll just load our doubleword thusly:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> sub ax,ax</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov es,ax</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> les ax,es:[46ch]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov dx,es</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">This last bit of code
is shorter, faster, and uninterruptible &#8212; in short, it's
perfect for our needs. In fact, we could have put <b>les</b>
to good
use reading the BIOS timer count in the long-period Zen timer, way
back in <a class="western" href="#L205">Listing 2-5</a>.
Why didn't
I use it there? The truth is that I didn't know about using <b>les</b>
to load doublewords when I wrote the timer (which just goes to show
that there's always more to learn about the 8088). When I did learn
about loading doublewords with <b>les</b>, it didn't make
any sense
to tinker with code that worked perfectly well just to save a few
bytes and cycles, particularly because the timer count load isn't
time-critical.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Remember, it's only
worth optimizing for speed when the cycles you save make a
significant difference...which usually means inside tight loops.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_SEGMENT:OFFSET_AND_BYTE"></a><a class="western" href="#T0704"><font size="4"><b>SEGMENT:OFFSET
AND BYTE ORDERING IN MEMORY</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Our
discussion of <b>les</b>
brings up the topic of how multi-byte values are stored in memory on
the 8088. That's an interesting topic indeed; on occasion we'll need
to load just the segment part of a 20-bit pointer from memory, or
we'll want to modify only the upper byte of a word variable. The
answer to our question is simple but by no means obvious: <i>multi-byte
values are always stored with the least-significant byte at the
lowest address</i>.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> For
example, when you
execute <b>mov ax,[WordVar]</b>, AL is loaded from address
<b>WordVar</b>,
and AH is loaded from address <b>WordVar+1</b>, as shown
in Figure
7.4. Put another way, this:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ax,[WordVar]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">is
logically equivalent
to this:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov al,byte
ptr [WordVar]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ah,byte
ptr [WordVar+1]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">although
the
single-instruction version is much faster and smaller. All
word-sized values (including address displacements, which we'll get
to shortly) follow this least-significant-byte-first memory ordering.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_mb91e59.jpg" align="bottom" border="0" height="740" width="612"></font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Similarly,
segment:offset pointers are stored with the least-significant byte of
the offset at the lowest memory address, the most-significant byte of
the offset next, the least-significant byte of the segment after
that, and the most-significant byte of the segment at the highest
memory address, as shown in Figure 7.5. This:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> les dx,dword
ptr [FarPtr]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">is
logically equivalent
to this:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov dx,word
ptr [FarPtr]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov es,word
ptr [FarPtr+2]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">which
is in turn
logically equivalent to this:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov dl,byte
ptr [FarPtr]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov dh,byte
ptr [FarPtr+1]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov al,byte
ptr [FarPtr+2]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ah,byte
ptr [FarPtr+3]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov es,ax</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_74f8efba.jpg" align="bottom" border="0" height="749" width="607"></font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">This organization
applies to all segment:offset values stored in memory, including
return addresses placed on the stack by far calls, far pointers used
by far indirect calls, and interrupt vectors.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">There's nothing sacred
about having the least-significant byte at the lowest address; it's
just the approach Intel chose. Other processors store values with
most-significant byte at the lowest address, and there's a sometimes
heated debate about which memory organization is better. That debate
is of no particular interest to us; we'll be using an Intel chip, so
we'll always be using Intel's least-significant-byte-first
organization.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> So,
to load just the
segment part of the 20-bit pointer <b>FarPtr</b>, we'd use:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov es,word
ptr [FarPtr+2]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">and
to increment only
the upper byte of the word variable <b>WordPtr</b>, we'd
use:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> inc byte
ptr [WordVar+1]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Remember that the
least-significant byte of any value (the byte that's closest to bit 0
when the value is loaded into a register) is always stored at the
lowest memory address, and that offsets are stored at lower memory
addresses than segments, and you'll be set. </font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_LOADING_SS"></a><a class="western" href="#T0704"><font size="4"><b>LOADING
SS</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> I'd
like to take a
moment to remind you that SP must be loaded whenever SS is loaded,
and that interrupts should be disabled for the duration of the load,
as we discussed in the last chapter. It would have been handy if
Intel had given us an <b>lss</b> instruction, but they
didn't. Instead, we'll load SS and SP with code along the lines of:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> cli</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ss,[NewSS]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov sp,[NewSP]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> sti</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_EXTRACTING_SEGMENT_VALUES"></a><a class="western" href="#T0704"><font size="4"><b>EXTRACTING
SEGMENT VALUES WITH THE seg DIRECTIVE</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Next, we're going to
look <i>very</i> quickly at a MASM operator and a MASM
directive. As
I've said, this is not a book about MASM, but these directives are
closely related to the efficient use of segments.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
<b>seg</b>
operator returns the segment within which the following symbol (label
or variable name) resides. In the following code, <b>seg WordVar</b>
returns the segment <b>Data</b>, which is then loaded into
ES and
used to assume ES to that segment:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>Data segment</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>WordVar dw 0</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>Data ends</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>Code segment</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> assume cs:Code,
es:Nothing</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> :</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ax,seg
WordVar</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov es,ax</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> assume es:seg
WordVar</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> :</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>Code ends</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> You
may well ask why
it's worth bothering with <b>seg</b>, when we could simply
have used
the segment name <b>Data</b> instead. The answer is that
you may not
know or may not have direct access to the segment name for variables
that are declared in other modules. For example, suppose that <b>WordVar</b>
were external in our last example:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> extrn
WordVar:word</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>Code segment</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> assume cs:Code,
es:Nothing</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> :</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ax,seg
WordVar</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov es,ax</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> assume es:seg
WordVar</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> :</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>Code ends</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">This
code still returns
the segment of <b>WordVar</b> properly, even though we
don't
necessarily have any idea at all as to what the name of that segment
might be.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In
short, <b>seg</b>
makes it easier to work with multiple segments in multi-module
programs.</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_JOINING_SEGMENTS"></a><a class="western" href="#T0704"><font size="4"><b>JOINING
SEGMENTS</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Selected assembler
modules can share the same code and/or data segments even when
multiple code and data segments are used. In other words, in
assembler you can choose to share segments between modules or not as
you choose, by contrast with high-level languages, which generally
force you to choose between all or no modules sharing segments. (This
is not always the case, however, as we'll see in Chapter 14.)</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
mechanism for
joining or separating segments is the <b>segment</b>
directive. If
each of two modules has a segment of the same name, and if those
segments are created as public segments (via the <b>public</b>
option
to the <b>segment</b> directive), then those segments will
be joined
into a single, shared segment. If the segments are code segments,
you can use near calls (faster and smaller than far calls) between
the modules. If the segments are data segments, then there's no need
for one module to load segment registers in order to access data in
the other module.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> All
in all, shared
segments allow multiple-module programs to produce code that's as
efficient as single-module code, with the segment registers changed
as infrequently as possible. In the same program in which multiple
modules share a given segment, however, other modules &#8212; or even
other parts of the same modules &#8212; may share segments of
different names, or may have segments that are private (unique to
that module). As a result, assembler programs can strike an
effective balance between performance and available memory: efficient
offset-only addressing most of the time, along with access
to as many segments and as much memory as the PC can handle on an
as-needed basis.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">There are many ways to
join segments, including grouping them and declaring them common, and
there are many options to the <b>segment</b> directive. We
need to
get on with our discussion of memory addressing, so we won't cover
MASM's segment-related directives further, but I strongly suggest
that you carefully read the discussion of those directives in your
assembler's manual. In fact, you should make it a point to read your
assembler's manual cover to cover &#8212; it may not be the most
exciting reading around, but I guarantee that there are tricks and
tips in there that you'll find nowhere else.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">While we won't discuss
MASM's segment-related directives again, we will explore the topic of
effective segment use again in Chapter 10 (as it relates to the
string instructions), Chapter 14 (as it relates to branching), and in
Volume II of <i>The Zen of Assembly Language</i>.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_SEGMENT_OVERRIDE_PREFIXES"></a><a class="western" href="#T0704"><font size="4"><b>SEGMENT
OVERRIDE PREFIXES</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> As
we saw in Chapter
6, all memory accesses default to accessing memory relative to one of
the four segment registers. Instructions come from CS, stack accesses
and memory accesses that use BP as a pointer occur within SS, string
instruction accesses via DI are in ES, and everything else is
normally in DS. In some &#8212; but by no means all &#8212; cases,
segments other than the default segments can be accessed by way of
segment override prefixes, special bytes that can precede &#8212;
prefix &#8212; instructions in order to cause those instructions to
use any one of the four segment registers.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Let's start by listing
the types of memory accesses segment override prefixes <i>can't</i>
affect. Instructions are always fetched from CS; there's no way to
alter that. The stack pointer is always used as a pointer into SS,
no matter what. ES is always the segment to which string instruction
accesses via DI go, regardless of segment override prefixes. Basically,
it's accesses to explicitly named memory operands and
string instruction accesses via SI that are affected by segment
override prefixes. (The segment accessed by the unusual <b>xlat</b>
instruction, which we'll encounter later in this chapter, can also be
overridden.)</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
default segment
for a memory operand is overridden by placing the prefix <b>CS:</b>,
<b>DS:</b>, <b>ES:</b>, or <b>SS:</b>
on that memory operand. For
example:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> sub bx,bx</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ax,es:[bx]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">loads
AX with the word
at offset 0 in ES, as opposed to:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> sub bx,bx</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ax,[bx]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">which
loads AX with the
word at offset 0 in DS.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Segment override
prefixes are handy in a number of situations. They're good for
accessing data out of CS when you're not sure where DS is pointing,
or when DS is temporarily pointing to some segment that doesn't
contain the data you want. (CS is the one segment upon whose setting
you can absolutely rely at any given time, since you know that if a
given instruction is being executed, CS <i>must</i> be
pointing to
the segment containing that instruction. Consequently, CS is a good
place to put jump tables and temporary variables in multi-segment
programs, and is a particularly handy segment in which to stash data
in interrupt handlers, which start up with only CS among the four
segment registers set to a known value.)</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In
many programs,
especially those involving high-level languages, DS and SS normally
point to the same segment, since it's convenient to have both stack
frame variables and static/global variables in the same segment. When
that's the case, <b>ss:</b> prefixes can be used to point
to
data in the default data segment when DS is otherwise occupied. Even
when SS doesn't point to the default data segment, segment override
prefixes still let you address data on the stack using pointer
registers other than BP.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Segment override
prefixes are particularly handy when you need to access data in two
to four segments at once. Suppose, for example, that we need to add
two far word-sized arrays together and store the resulting array in
the default data segment. Assuming that SS and DS both point to the
default data segment, segment override prefixes let us keep all our
pointers and counters in the registers as we add the arrays, as
follows:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> push ds ;save
normal DS</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> les di,[FarPtr2] ;point
ES:DI to one source array</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov bx,[DestPtr] ;point
SS:BX to the destination array</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov cx,[AddLength] ;array
length</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> lds si,[FarPtr1] ;point
DS:SI to the other source array</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> cld ;make
LODSW count up</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>Add3Loop:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> lodsw ;get
the next entry from one array</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> add ax,es:[di] ;add
it to the other array</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ss:[bx],ax ;save
the sum in a third array</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> inc di ;point
to the next entries</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> inc di</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> inc bx</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> inc bx</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> loop Add3Loop</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> pop ds ;restore
normal DS</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">Had
we needed to, we
could also have stored data in CS by using <b>cs:</b>.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Handy as segment
override prefixes are, you shouldn't use them too heavily if you can
help it. They're fine for one-shot instructions such as branching
through a jump table in CS or retrieving a byte from the BIOS data
area by way of ES, but they're to be avoided whenever possible inside
tight loops. The reason: segment override prefixes officially take
2 cycles to execute and, since they're 1 byte long, they can actually
take up to 4 cycles to fetch and execute &#8212; and 4 cycles is a
significant amount of time inside a tight loop.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Whenever you can,
organize your segments outside loops so that segment override
prefixes aren't needed inside loops. For example, consider <a name="L707R"></a><a class="western" href="#L707">Listing
7-7</a>, which uses a segment override prefix while stripping the
high bit of every byte in an array in the segment addressed via ES. <a class="western" href="#L707">Listing 7-7</a>
runs in 2.95 ms.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Now
consider <a name="L708R"></a><a class="western" href="#L708">Listing
7-8</a>, which does the same thing as <a class="western" href="#L707">Listing
7-7</a>, save that DS is set to match ES outside the loop. Since
DS
is the default segment for the memory accesses we perform inside the
loop, there's no longer any need for a segment override prefix...and
that one change improves performance by nearly 14%, reducing total
execution time to 2.59 ms.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
lesson is clear: don't use segment override prefixes in tight loops
unless you have no
choice.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_assume_AND_SEGMENT"></a><a class="western" href="#T0704"><font size="4"><b>assume
AND SEGMENT OVERRIDE PREFIXES</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Segment override
prefixes can find their way into your code even if you don't put them
there, courtesy of the assembler and the <b>assume</b>
directive. <b>assume</b> tells MASM what segments are
currently addressable via
the segment registers. Whenever MASM doesn't think the default
segment register for a given instruction can reach the desired
segment but another segment register can, <i>MASM sticks in a
segment
override prefix without telling you it's doing so</i>. As a
result,
your code can get bigger and slower without you knowing about it.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Take a look at this
code:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>Code segment</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> assume cs:code</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>Start
proc far</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jmp Skip</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>ByteVar db 0</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>Skip:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> push cs</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> pop ds ;set
DS to point to the segment Code</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> inc [ByteVar]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> :</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>Code ends</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">You
know and I know
that DS can be used to address <b>ByteVar</b> in the above
code,
since the first thing the code does is set DS equal to CS, thereby
loading DS to point to the segment <b>Code</b>.
Unfortunately, the
assembler does <i>not</i> know that &#8212; the <b>assume</b>
directive told it only that CS points to <b>Code</b>, and <b>assume</b>
is all the assembler has to go by. Given this correct but not
complete information, the assembler concludes that <b>ByteVar</b>
must be addressed via CS and inserts a <b>cs:</b> segment
override
prefix, so the <b>inc</b> instruction assembles as if <b>inc
cs:[ByteVar]</b> had been used.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
result is a wasted
byte and several wasted cycles. Worse yet, you have no idea that the
segment override prefix has been inserted unless you either generate
and examine a listing file or view the assembled code as it runs in a
debugger. The assembler is just trying to help by taking some of the
burden of segment selection away from you, but the outcome is all too
often code that's invisibly bloated with segment override prefixes.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
solution is
simple. <i>Keep the assembler's segment assumptions correct at
all
times by religiously using the </i><i><b>assume</b></i><i>
directive
every time you load a segment.</i> The above example would have
assembled correctly &#8212; without a segment override prefix &#8212;
if only we had inserted the line:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> assume ds:Code</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">before
we had attempted
to access <b>ByteVar</b>.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h2 class="western"><font color="#110d06"><font color="#0b0703"><a name="_OFFSET_HANDLING"></a><a class="western" href="#T0705"><font style="font-size: 16pt;" size="4"><b>7.5
OFFSET HANDLING</b></font></a></font></font></h2>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> At
long last, we've
completed our discussion of segments. Now it's time to move on to the
other half of the memory-addressing equation: offsets.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Offsets are handled
somewhat differently from segments. Segments are simply loaded into
the segment registers, which are then used to address memory as half
of a segment:offset address. Offsets can also be loaded into
registers and used directly as half of a segment:offset address, but
just as often offsets are built into instructions, and they can also
be calculated on the fly by summing the contents of one or two
registers and/or offsets built into instructions.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> At
any rate, we'll
quickly cover offset loading, and then we'll look at the many ways to
generate offsets for memory addressing. The offset portion of memory
addressing is one area in which the 8088 is very flexible, and, as
we'll see, there's no one best way to address memory.</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_LOADING_OFFSETS"></a><a class="western" href="#T0705"><font size="4"><b>LOADING
OFFSETS</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Offsets are loaded
with the <b>offset</b> operator. <b>offset</b>
is analogous to the
<b>seg</b> operator we encountered earlier; the difference,
of
course, is that <b>offset</b> extracts the offset of a
label or
variable name rather than the segment. For example:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov bx,offset
WordVar</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">loads
BX with the
offset of the variable <b>WordVar</b>. If some segment
register
already points to the segment containing <b>WordVar</b>,
then BX can
be used to address memory, as for example in:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov bx,seg
WordVar</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov es,bx</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov bx,offset
WordVar</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ax,es:[bx]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">We'll
discuss the many
ways in which offsets can be used to address memory next.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Before we get to using
offsets to address memory, there are a couple of points I'd like to
make. The first point is that the <b>lea</b> instruction
can also be
used to load offsets into registers; however, an understanding of <b>lea</b>
requires an understanding of the 8088's addressing modes, so we'll
defer the discussion of <b>lea</b> until later in this
chapter.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
second point is a
shortcoming of MASM that you must be aware of when you use <b>offset</b>
on variables that reside in segment groups. If you are using the
<b>group</b> directive to make segment groups, you must
always
specify the group name as well as the variable name when you use the
offset operator. For example, if the segment <b>_DATA</b>
is in the
group <b>DGROUP</b>, and <b>WordVar</b> is in
<b>_DATA</b>, you <i>must</i>
load the offset of <b>WordVar</b> as follows:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov di,offset
DGROUP:WordVar</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">If
you don't specify
the group name, as in:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov di,offset
WordVar</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">the
offset of <b>WordVar</b>
relative to <b>_DATA</b> rather than <b>DGROUP</b>
is loaded; given
the way segment groups are organized (with all segments in the group
addressed in a single combined segment), an offset relative to <b>_DATA</b>
may not work at all.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> I
realize that the
above discussion won't make much sense if you haven't encountered the
<b>group</b> directive (lucky you!). I've never found
segment groups
to be necessary in pure assembler code, but they are often needed
when sharing segments between high-level language code and assembler.
If you do find yourself using segment groups, all you need to
remember is this: <i>when loading the offset of a variable that
resides within a segment group with the </i><i><b>offset</b></i><i>
operator, always specify the group name along with the variable name</i>.
</font></font></p>
<h2 class="western"><font color="#110d06"><font color="#0b0703"><a name="_mod-reg-rm_ADDRESSING"></a><a class="western" href="#T0706"><font style="font-size: 16pt;" size="4"><b>7.6</b></font><font style="font-size: 16pt;" size="4"><i><b>
mod-reg-rm</b></i></font><font style="font-size: 16pt;" size="4"><b>
ADDRESSING</b></font></a></font></font></h2>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">There are a number of
ways in which the offset of an instruction operand can be specified.
Collectively, the ways of specifying operand offsets are known as
addressing modes. Most of the 8088's addressing modes fall into a
category known as <i>mod-reg-rm</i> addressing modes.
We're going to
discuss <i>mod-reg-rm</i> addressing modes next; later in
the chapter
we'll discuss non-<i>mod-reg-rm</i> addressing modes.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <i>mod-reg-rm</i>
addressing modes are so named because they're specified by a second
instruction byte, known as the <i>mod-reg-rm</i> byte,
that follows
instruction opcodes in order to specify the memory and/or register
operands for many instructions. The <i>mod-reg-rm</i> byte
gets its
name because the various fields within the byte are used to specify
the memory addressing <i>mod</i>e, the <i>reg</i>ister
used for one
operand, and the <i>r</i>egister or <i>m</i>emory
location used for
the other operand, as shown in Figure 7.6. (Figure 7.6 should make
it clear that at most only one <i>mod-reg-rm</i> operand
can be a
memory operand; one or both operands must be register operands, for
there just aren't enough bits in a <i>mod-reg-rm</i> byte
to specify
two memory operands.)</font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_m5ffce0d7.jpg" align="bottom" border="0" height="787" width="637"></font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Simply put, the
<i>mod-reg-rm</i> byte tells the 8088 where to find an
instruction's
operand or operands. (It's up to the opcode byte to specify the data
size, as well as which operand is the source and which is the
destination.) When a memory operand is used, the <i>mod-reg-rm</i>
byte tells the 8088 how to add together the contents of registers (BX
or BP and/or SI or DI) and/or a fixed value built into the
instruction (a displacement) in order to generate the operand's
memory offset. The offset is then combined with the contents of one
of the segment registers to make a full 20-bit memory address, as we
saw earlier in this chapter, and that 20-bit address serves as the
instruction operand. Figure 7.7 illustrates the operation of the
complex base+index+displacement addressing mode, in which an offset
is generated by adding BX or BP, SI or DI, and a fixed displacement.
(Note that displacements are built right into instructions, coming
immediately after <i>mod-reg-rm</i> bytes, as illustrated
by Figure
7.9.)</font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_m3382bc6d.jpg" align="bottom" border="0" height="787" width="608"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> For
example, if the
opcode for <b>mov </b><i><b>reg8</b></i><b>,[</b><i><b>reg/mem8</b></i><b>]</b>
(8Ah) is followed by the <i>mod-reg-rm</i> byte 17h, that
indicates
that the register DL is to be loaded from the memory location pointed
to by BX, as shown in Figure 7.8. Put the other way around, <b>mov
dl,[bx]</b> assembles to the two byte sequence 8Ah 17h, where the
first byte is the opcode for <b>mov </b><i><b>reg8</b></i><b>,[</b><i><b>reg/mem8</b></i><b>]</b>
and the second byte is the <i>mod-reg-rm</i> byte that
selects DL as
the destination and the memory location pointed to by BX as the
source.</font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_12eab0be.jpg" align="bottom" border="0" height="409" width="611"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> You
may well wonder
how the <i>mod-reg-rm</i> byte works with one-operand
instructions,
such as <b>neg word ptr ds:[140h]</b>, or with
instructions that have
constant data as one operand, such as <b>sub [WordVar],1</b>.
The
answer is that in these cases the <i>reg</i> field isn't
used for
source or destination control; instead, it's used as an extension of
the opcode byte. So, for instance, <b>neg [</b><i><b>reg/mem16</b></i><b>]</b>
has an opcode byte of 0F7h and always has bits 5-3 of the <i>mod-reg-rm</i>
byte set to 011b. Bits 7-6 and 2-0 of the <i>mod-reg-rm</i>
byte
still select the memory addressing mode for the single operand, but
bits 5-3, together with the opcode byte, now simply tell the 8088
that the instruction is <b>neg [</b><i><b>reg/mem16</b></i><b>]</b>,
as shown in Figure 7.9. <b>not [</b><i><b>reg/mem16</b></i><b>]</b>
also has an opcode byte of 0F7h, but is distinguished from <b>neg
[</b><i><b>reg/mem16</b></i><b>]</b>
by bits 5-3 of the <i>mod-reg-rm</i>
byte, which are 010b for <b>not</b> and 011b for <b>neg</b>.</font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_m2e5737bd.jpg" align="bottom" border="0" height="555" width="607"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> At
any rate, the
mechanics of <i>mod-reg-rm</i> addressing aren't what we
need to
concern ourselves with; the assembler takes care of such details,
thank goodness. We do, however, need to concern ourselves with the
<i>implications</i> of <i>mod-reg-rm</i>
addressing, particularly
size and performance issues.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_WHAT'S_mod-reg-rm_ADDRESSING"></a><a class="western" href="#T0706"><font size="4"><b>WHAT'S
</b></font><font size="4"><i><b>mod-reg-rm</b></i></font><font size="4"><b>
ADDRESSING GOOD FOR?</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
first thing to ask
is, "What is <i>mod-reg-rm</i> addressing good for?" What
<i>mod-reg-rm</i> addressing does best is address memory in
a very
flexible way. No other addressing mode approaches <i>mod-reg-rm</i>
addressing for sheer number of ways in which memory offsets can be
generated.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Look at Figure 7.6,
and try to figure out how many source/destination combinations are
possible with <i>mod-reg-rm</i> addressing. The answer is
simple,
since there are 8 bits in a <i>mod-reg-rm</i> byte; 256
possible
source/destination combinations are supported. Any general-purpose
register can be one operand, and any general-purpose register or
memory location can be the other operand.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> If
we look at memory
addressing alone, we see that there are 24 distinct ways to generate
a memory offset. (8 of the 32 possible selections that can be made
with bits 7-6 and 3-0 of the <i>mod-reg-rm</i> byte select
general-purpose registers.) Some of those 24 selections differ only
in whether 1 or 2 displacement bytes are present, leaving us with the
following 16 completely distinct memory addressing modes:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; page-break-after: avoid; margin-left: 40px;">
<font color="#110d06"><font color="#0b0703"><font color="#890000"><b>[</b></font><font color="#890000"><i><b>disp16</b></i></font><font color="#890000"><b>] [bp+</b></font><font color="#890000"><i><b>disp</b></i></font><font color="#890000"><b>]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>[bx] [bx+</b></font><font color="#890000"><i><b>disp</b></i></font><font color="#890000"><b>]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>[si] [si+</b></font><font color="#890000"><i><b>disp</b></i></font><font color="#890000"><b>]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>[di] [di+</b></font><font color="#890000"><i><b>disp</b></i></font><font color="#890000"><b>]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>[bp+si] [bp+si+</b></font><font color="#890000"><i><b>disp</b></i></font><font color="#890000"><b>]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>[bp+di] [bp+di+</b></font><font color="#890000"><i><b>disp</b></i></font><font color="#890000"><b>]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>[bx+si] [bx+si+</b></font><font color="#890000"><i><b>disp</b></i></font><font color="#890000"><b>]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>[bx+di] [bx+di+</b></font><font color="#890000"><i><b>disp</b></i></font><font color="#890000"><b>]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">For
two-operand
instructions, each of those memory addressing modes can serve as
either source or destination, with either a constant value or one of
the 8 general-purpose registers as the other operand.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Basically, <i>mod-reg-rm</i>
addressing lets you select a memory offset in any of 16 ways (or a
general-purpose register, if you prefer), and say, "Use this as
an operand." The other operand can't involve memory, but it can
be any general-purpose register or (usually) a constant value. (There's
no inherent support in <i>mod-reg-rm</i> addressing for
constant operands. Special, separate opcodes must used to specify
constant operands for instructions that support such operands, and a
few <i>mod-reg-rm</i> instructions, such as <b>mul</b>,
don't accept
constant operands at all.)</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <i>mod-reg-rm</i>
addressing is flexible indeed.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_DISPLACEMENTS_AND_SIGN-EXTENSION"></a><a class="western" href="#T0706"><font size="4"><b>DISPLACEMENTS
AND SIGN-EXTENSION</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">I've said that
displacements can be either 1 or 2 bytes in size. The obvious
question is: what determines which size is used? That's an
important question, since displacement bytes directly affect program
size, which in turn indirectly affects performance via the prefetch
queue cycle-eater.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Except in the case of
direct addressing, which we'll discuss shortly, displacements in the
range -128 to +127 are stored as one byte, then automatically
sign-extended by the 8088 to a word when the instructions containing
them are executed. (Expressed in unsigned hexadecimal, -128 to +127
covers two ranges: 0 to 7Fh and 0FF80h to 0FFFFh.) Sign-extension
involves copying bit 7 of the byte to bits 15-8, so a byte value of
80h sign-extends to 0FF80h, and a byte value of 7Fh sign-extends to
0007Fh. Basically, sign-extension converts signed byte values to
signed word values; since the maximum range of a signed byte is -128
to +127, that's the maximum range of a 1-byte displacement as well.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
implication of
this should be obvious: you should try to use displacements in the
range -128 to +127 whenever possible, in order to reduce program size
and improve performance. One caution, however: displacements must
be either numbers or symbols equated to numbers in order for the
assembler to be able to assemble them as single bytes. (Numbers and
symbols work equally well. In:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>SAMPLE_DISPLACEMENT equ 1</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> :</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ax,[bx+SAMPLE_DISPLACEMENT]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ax,[bx+9]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">both
<b>mov</b>
instructions assemble with 1-byte displacements.)</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Displacements must be
constant values in order to be stored in sign-extended bytes because
when a named memory variable is used, the assembler has no way of
knowing where in the segment the variable will end up. Other parts
of the segment may appear in other parts of the module or may be
linked in from other modules, and the linker may also align the
segment to various memory boundaries; any of these can have the
effect of moving a given variable in the segment to an offset that
doesn't fit in a sign-extended byte. As a result, the following <b>mov</b>
instruction assembles with a 2-byte displacement, even though it
appears to be at offset 0 in its segment:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>Data segment</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>MemVar db 10
dup (?)</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>Data ends</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> :</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov al,[MemVar+bx]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_NAMING_THE_mod-reg-rm"></a><a class="western" href="#T0706"><font size="4"><b>NAMING
THE </b></font><font size="4"><i><b>mod-reg-rm</b></i></font><font size="4"><b>
ADDRESSING MODES </b></font></a>
</font></font></h3>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
16 distinct memory
addressing modes supported by the <i>mod-reg-rm</i> byte
are often
given a slew of confusing names, such as "implied addressing,"
"based relative addressing," and "direct indexed
addressing." Generally, there's little need to name addressing
modes; you'll find you use them much more than you talk about them.
However, we will need to refer to the modes later in this book, so
let me explain my preferred addressing mode naming scheme.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> I
find it simplest to
give a name to each of the three possible components of a memory
offset &#8212; base for BX or BP, index for SI or DI, displacement
for a 1-or 2-byte fixed value &#8212; and then just refer to an
addressing mode with all the components of that mode. That way, <b>mov
[bx],al</b> uses base addressing, <b>add ax,[si+1]</b>
uses
index+displacement addressing, and <b>mov dl,[bp+di+1000h]</b>
uses
base+index+displacement addressing. The names may be long at times,
but they're never ambiguous or hard to remember.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_DIRECT_ADDRESSING"></a><a class="western" href="#T0706"><font size="4"><b>DIRECT
ADDRESSING</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">There is one exception
to the above naming scheme, and that's direct addressing. Direct
addressing is used when a memory address is referenced with just a
16-bit displacement, as in <b>mov bx,[WordVar]</b> or <b>mov
es:[410h],al</b>. You might expect direct addressing to be called
displacement addressing, but it's not, for three reasons. First, the
address used in direct addressing is not, properly speaking, a
displacement, since it isn't relative to any register. Second,
direct addressing is a time-honored term that came into use long
before the 8088 was around, so experienced programmers are more
likely to speak of "direct addressing" than "displacement
addressing."</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Third, direct
addressing is a bit of an anomaly in <i>mod-reg-rm</i>
addressing. It's pretty obvious why we'd <i>want</i> to
have direct addressing
available; surely you'd rather do this:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov dx,[WordVar]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-left: 40px;"><font color="#110d06"><font color="#0b0703">than
this:</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov bx,offset
WordVar</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov dx,[bx]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">It's
just plain handy
to be able to access a memory location directly by name.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Now
look at Figure 7.6
again. Direct addressing really doesn't belong in that figure at
all, does it? The <i>mod-reg-rm</i> encoding for direct
addressing
should by all rights be taken by base addressing using only BP.
However, there <i>is</i> no addressing mode that can use
only BP &#8212;
if you assemble the instruction <b>mov [bp],al</b>, you'll
find that
it actually assembles as <b>mov [bp+0],al</b>, with a
1-byte
displacement.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In
other words, the
designers of the 8088 rightly considered direct addressing important
enough to build it into <i>mod-reg-rm</i> addressing in
place of a
little-used addressing mode. (BP is designed to point to stack
frames, as we'll see shortly, and there's rarely any use for BP-only
base addressing in stack frames.)</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Along the same lines,
note that direct addressing always uses a 16-bit displacement. Direct
addressing does not use an 8-bit sign-extended displacement
even if the address is in the range -128 to +127.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_MISCELLANEOUS_INFORMATION_ABOUT"></a><a class="western" href="#T0706"><font size="4"><b>MISCELLANEOUS
INFORMATION ABOUT MEMORY ADDRESSING</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Be
aware that all
<i>mod-reg-rm</i> addressing defaults to accessing the
segment
pointed to by DS &#8212; <i>except</i> when BP is used as part
of the
<i>mod-reg-rm</i> address. Any <i>mod-reg-rm</i>
addressing
involving BP accesses the segment pointed to by SS by default. (If DS
and SS point to the same segment, as they often do, you can use
BP-based addressing modes to point to normal data if necessary, and
you can use the other <i>mod-reg-rm</i> addressing modes
to point to
data on the stack.) However, <i>mod-reg-rm</i> addressing
can always
be forced to use any segment register with a segment override prefix.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">There are a few other
addressing terms that I should mention now. Indirect addressing is
commonly used to refer to any sort of memory addressing that uses a
register (BX, BP, SI, or DI, or any of the valid combinations) to
point to memory. We'll also use indirect to refer to branches that
branch to destinations specified by memory operands, as in <b>jmp
word ptr [SubroutinePointer]</b>. We'll discuss indirect
branching
in detail in Chapter 14.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Immediate addressing
is a non-<i>mod-reg-rm</i> form of addressing in which the
operand is
a constant value that's built right into the instruction. We'll
cover immediate addressing when we're done with <i>mod-reg-rm</i>
addressing.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Finally, I'd like to
make it clear that a displacement is nothing more than a fixed
(constant) value that's added into the memory offset calculated by a
<i>mod-reg-rm</i> byte. It's called a displacement because
it
specifies the number of bytes by which the addressed offset should be
displaced from the offset specified by the registers used to point to
memory. In <b>mov si,[bx+1]</b>, the displacement is 1;
the address
from which SI is loaded is displaced 1 byte from the memory location
pointed to by BX. In <b>mov ax,[si+WordVar]</b>, the
displacement is
the offset of <b>WordVar</b>. We won't know exactly what
that offset
is unless we look at the code with a debugger, but it's a constant
value nonetheless.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Don't get caught up
worrying about the exact meaning of the term displacement, or indeed
of any of the memory addressing terms. In a way, the terms are
silly; <b>mov ax,[bx]</b> is base addressing and <b>mov
ax,[si]</b>
is index addressing, but both load AX from the address pointed to by
a register, both are 2 bytes long, and both take 13 cycles to
execute. The difference between the two is purely semantic from a
programmer's perspective.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Notwithstanding, we
needed to establish a common terminology for the <i>mod-reg-rm</i>
memory addressing modes, and we've done so. Now that we understand
how <i>mod-reg-rm</i> addressing works and how wonderfully
flexible
it is, let's look at its dark side.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_mod-reg-rm_ADDRESSING:_"></a><a class="western" href="#T0706"><font size="4"><i><b>mod-reg-rm</b></i></font><font size="4"><b>
ADDRESSING: THE DARK SIDE</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Gee, if <i>mod-reg-rm</i>
addressing is so flexible, why don't we use it for all memory
accesses? For that matter, why does the 8088 even <i>have</i>
any
other addressing modes?</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> One
reason is that
<i>mod-reg-rm</i> addressing doesn't work with all
instructions. For
example, the string instructions can't use <i>mod-reg-rm</i>
addressing, and neither can <b>xlat</b>, which we'll
encounter later
in this chapter. Nonetheless, most instructions, including <b>mov</b>,
<b>add</b>, <b>adc</b>, <b>sub</b>,
<b>sbb</b>, <b>cmp</b>, <b>and</b>,
<b>or</b>, <b>xor</b>, <b>neg</b>,
<b>not</b>, <b>mul</b>, <b>div</b>,
and more, do support <i>mod-reg-rm</i> addressing, so it
would seem
that there must be some other reason for the existence of other
addressing modes.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> And
indeed there is
another reason for the existence of other addressing modes. In fact,
there are two reasons: speed and size. <i>mod-reg-rm</i>
addressing
is more flexible than other addressing modes &#8212; and it also
produces the largest, slowest code around.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">It's easy to
understand why <i>mod-reg-rm</i> addressing produces
larger code than
other memory addressing modes. The bits needed to encode <i>mod-reg-rm</i>
addressing's many possible source, destination, and addressing mode
combinations increase the size of <i>mod-reg-rm</i>
instructions, and
displacement bytes can make <i>mod-reg-rm</i> instructions
larger
still. It stands to reason that the string instruction <b>lods</b>,
which always loads AL from the memory location pointed to by DS:SI,
should have fewer instruction bytes than the <i>mod-reg-rm</i>
instruction <b>mov al,[si]</b>, which selects AL from 8
possible
destination registers, and which selects the memory location pointed
to by SI from among 32 possible source operands.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">It's less obvious why
<i>mod-reg-rm</i> addressing is slower than other memory
addressing
modes. One major reason falls out from the larger size of <i>mod-reg-rm</i>
instructions; we've already established that instructions with more
instruction bytes tend to run more slowly, simply because it takes
time to fetch those extra instruction bytes. That's not the whole
story, however. It takes the 8088 a variable but considerable amount
of time &#8212; 5 to 12 cycles &#8212; to calculate memory addresses
from <i>mod-reg-rm</i> bytes. Those lengthy calculations,
known as
effective address (EA) calculations, are our next topic.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Before we proceed to
EA calculations, I'd like to point out that slow and bulky as
<i>mod-reg-rm</i> addressing is, it's still the workhorse
memory
addressing mode of the 8088. It's also the addressing mode used by
many register-only instructions, such as <b>add dx,bx</b>
and <b>mov
al,dl</b>, with the <i>mod-reg-rm</i> byte selecting
register rather
than memory operands. My goodness, some instructions don't even <i>have</i>
a non-<i>mod-reg-rm</i> addressing mode. Without a doubt,
you'll be
using <i>mod-reg-rm</i> addressing often in your code, so
we'll take
the time to learn how to use it well.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Nonetheless, the
less-flexible addressing modes are generally shorter and faster than
<i>mod-reg-rm</i> addressing. As we'll see throughout <i>The
Zen of
Assembly Language</i>, one key to high-performance code is
avoiding
<i>mod-reg-rm</i> addressing as much as possible.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_WHY_MEMORY_ACCESSES"></a><a class="western" href="#T0706"><font size="4"><b>WHY
MEMORY ACCESSES ARE SLOW</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> As
I've already said,
<i>mod-reg-rm</i> memory accesses are slow partly because
instructions that use <i>mod-reg-rm</i> addressing tend to
have many
instruction bytes. The <i>mod-reg-rm</i> byte itself adds
1 byte
beyond the opcode byte, and a displacement, if used, will add 1 or 2
more bytes. Remember, 4 cycles are required to fetch each and every
one of those instruction bytes.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Taken a step farther,
that line of thinking reveals why <i>all</i> instructions
that access
memory are slow: memory is slow. It takes 4 cycles per byte to
access memory in any way. That means that an instruction like <b>mov
bx,[WordVar]</b>, which is 4 bytes long and reads a word-sized
memory
variable, must perform 6 memory accesses in all; at 4 cycles a pop,
that adds up to a minimum execution time of 24 cycles. Even a 2-byte
memory-accessing instruction spends a minimum of 12 cycles just
accessing memory. By contrast, most register-only operations are 1 to
2 bytes in length and have Execution Unit execution times of 2 to 4
cycles, so the <i>maximum</i> execution times for
register-only
instructions tend to be 4 to 8 cycles.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">I've said it before,
and I'll say it again: <i>avoid accessing memory whenever you can</i>.
Memory is just plain slow.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In
actual use, many
memory-accessing instructions turn out to be even slower than memory
access times alone would explain. For example, the fastest possible
<i>mod-reg-rm</i> memory-accessing instruction, <b>mov
</b><i><b>reg8</b></i><b>,[bx]</b>
(BP, SI, or DI would do as well as BX), has an Execution Unit
execution time of 13 cycles, although only 3 memory accesses
(requiring 12 cycles) are performed. Similarly, string instructions,
<b>xlat</b>, <b>push</b>, and <b>pop</b>
take more cycles than can be
accounted for solely by memory accesses.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
full explanation
for the poor performance of the 8088's memory-accessing instructions
lies in the microcode of the 8088 (the built-in bit patterns that
sequence the 8088 through the execution of each instruction), which
is undeniably slower than it might be. (Check out the execution
times of the 8088's instructions on the 80286 and 80386, and you'll
see that it's possible to execute the 8088's instructions in many
fewer cycles than the 8088 requires.) That's not something we can
change; about all we can do is choose the fastest available
instruction for each task, and we'll spend much of <i>The Zen of
Assembly Language</i> doing just that.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">There is one aspect of
memory addressing that we <i>can</i> change, however, and
that's EA
addressing time &#8212; the amount of time it takes the 8088 to
calculate memory addresses.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_SOME_mod-reg-rm_MEMORY"></a><a class="western" href="#T0706"><font size="4"><b>SOME
</b></font><font size="4"><i><b>mod-reg-rm</b></i></font><font size="4"><b>
MEMORY ACCESSES ARE SLOWER THAN OTHERS</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> A
given instruction
that uses <i>mod-reg-rm</i> addressing doesn't always
execute in the
same number of cycles. The Execution Unit execution time of
<i>mod-reg-rm</i> instructions comes in two parts: a fixed
Execution
Unit execution time and an effective address (EA) execution time that
varies depending on the <i>mod-reg-rm</i> addressing mode
used. The
two times added together determine the overall execution time of each
<i>mod-reg-rm</i> instruction.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Each <i>mod-reg-rm</i>
instruction has its own fixed Execution Unit execution time, which
remains the same for all addressing modes. For example, the fixed
execution time of <b>add bl,[</b><i><b>mem</b></i><b>]</b>
is 9
cycles, as shown in Appendix A; this value is constant, no matter
what <i>mod-reg-rm</i> addressing mode is used.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
EA calculation
time, on the other hand, depends not in the least on which
instruction is being executed. EA calculation time is determined
solely by the <i>mod-reg-rm</i> addressing mode used, and
nothing
else, as shown in Figure 7.10. As you can see from Figure 7.10, the
time it takes the 8088 to calculate an effective address can vary
greatly, ranging from a mere 5 cycles if a single register is used to
point to memory all the way up to 11 or 12 cycles if the sum of two
registers and a displacement is used to point to memory. (Segment
override prefixes require an additional 2 cycles each, as we saw
earlier.) When I discuss the performance of an instruction that uses
<i>mod-reg-rm</i> addressing, I'll often say that it takes
at least a
certain number of cycles to execute. What "at least" means
is that the instruction will take that many cycles if the fastest
<i>mod-reg-rm</i> addressing mode &#8212; base-or index-only &#8212;
is used, and longer if some other <i>mod-reg-rm</i>
addressing mode
is selected.</font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_3bb6d385.jpg" align="bottom" border="0" height="780" width="591"></font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Only <i>mod-reg-rm</i>
memory operands require EA calculations. There is no EA calculation
time for register operands, or for memory operands accessed with
non-<i>mod-reg-rm</i> addressing modes.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In
short, EA
calculation time means that the choice of <i>mod-reg-rm</i>
addressing mode directly affects performance. Let's look more
closely at the performance implications of EA calculations.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_PERFORMANCE_IMPLICATIONS_OF"></a><a class="western" href="#T0706"><font size="4"><b>PERFORMANCE
IMPLICATIONS OF EFFECTIVE ADDRESS CALCULATIONS</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">There are a number of
interesting points to be made about EA calculation time. For
starters, it should be clear that EA calculation time is a big reason
why instructions that use <i>mod-reg-rm</i> addressing are
slow. The
minimum EA calculation time of 5 cycles, on top of 8 or more cycles
of fixed execution time, is no bargain; the maximum EA calculation
time of 12 cycles is a grim prospect indeed.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> For
example, <b>add
bl,[si]</b> takes 13 cycles to execute (8 cycles of fixed
execution
time and 5 cycles of EA calculation time), which is certainly not
terrific by comparison with the 3-cycle execution time of <b>add
bl,dl</b>. (Instruction fetching alters the picture somewhat, as
we'll see shortly.) At the other end of the EA calculation spectrum,
<b>add bl,[bx+di+100h]</b> takes 20 cycles to execute,
which is
horrendous no matter what you compare it to.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
lesson seems
clear: use faster <i>mod-reg-rm</i> addressing modes
whenever you
can. While that's true, it's not necessarily obvious which
<i>mod-reg-rm</i> addressing modes are faster. Base-only
addressing
or index-only addressing are the <i>mod-reg-rm</i>
addressing modes
of choice, because they add only 5 cycles of EA calculation time and
1 byte, the <i>mod-reg-rm</i> byte. For instance, <b>mov
dl,[bp]</b>
is just 2 bytes long and takes a fairly reasonable 13 cycles to
execute.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Direct addressing,
which has an EA calculation time of 6 cycles, is only slightly slower
than base or index addressing so far as official execution time goes.
However, direct addressing requires 2 additional instruction bytes
(the 16-bit displacement) beyond the <i>mod-reg-rm</i>
byte, so it's
actually a good deal slower than base or index addressing. <b>mov
dl,[ByteVar]</b> officially takes 14 cycles to execute, but given
that the instruction is 4 bytes long and performs a memory access, 20
cycles is a more accurate execution time.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Base+index addressing
(<b>mov al,[bp+di]</b> and the like) takes 1 to 2 cycles
more for EA
calculation time than does direct addressing, but is nonetheless
superior to direct addressing in most cases. The key: base+index
addressing requires only the 1 <i>mod-reg-rm</i> byte.
Base+index
addressing instructions are 2 bytes shorter than equivalent direct
addressing instructions, and that translates into a considerable
instruction-fetching/performance advantage.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
rule is: <i>use
displacement-free </i>mod-reg-rm<i> addressing modes
whenever you
can</i>. Instructions that use displacements are always 1 to 2
bytes
longer than those that use displacement-free <i>mod-reg-rm</i>
addressing modes, and that means that there's generally a prefetching
penalty for the use of displacements. There's also a substantial EA
calculation time penalty for base+displacement, index+displacement,
or base+index+displacement addressing. If you must use
displacements, use 1-byte displacements as much as possible; we'll
see an example of this when we get to stack frames later in this
chapter.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Now, bear in mind that
the choice of <i>mod-reg-rm</i> addressing mode really
only matters
inside loops, or in time-critical code. If you're going to load DX
from memory just once in a long subroutine, it really doesn't much
matter if you take a few extra cycles to load it with direct
addressing rather than base or index addressing. It certainly isn't
worth loading, say, BX to point to memory, as in:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov bx,offset
MemVar</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov dx,[bx]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">just
to use base or
index addressing once &#8212; the <b>mov</b> instruction used to
load
BX takes 4 cycles and 3 bytes, more than negating any advantage base
addressing has over direct addressing.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Inside loops, however,
it's well worth using the most efficient addressing mode available. <a name="L709R"></a><a class="western" href="#L709">Listing 7-9</a>,
which adds up the
elements of a byte-sized array using base+index+displacement
addressing every time through the loop, runs in 1.17 ms. <a name="L710R"></a><a class="western" href="#L710">Listing
7-10</a>, which changes the addressing mode to base+index by
adding
the displacement into the base outside the loop, runs in 1.01 ms,
nearly 16% faster than <a class="western" href="#L709">Listing
7-9</a>. Finally, <a name="L711R"></a><a class="western" href="#L711">Listing
7-11</a>, which
performs all the addressing calculations outside the loop and uses
plain old base-only addressing, runs in just 0.95 ms, 6% faster
still. (The string instruction <b>lods</b> is even faster
than <b>mov
al,[bx]</b>, as we'll see in Chapter 10. Always think of your
non-<i>mod-reg-rm</i> alternatives.) Clearly, the choice of
addressing mode matters considerably inside tight loops.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">We've learned two
basic rules, then: 1) <i>use displacement-free mod-reg-rm
addressing
modes whenever you can</i>, and 2) <i>calculate memory
addresses
outside loops and use base-only or index-only addressing whenever
possible</i>. The <b>lea</b> instruction, which
we'll get to
shortly, is most useful for calculating memory addresses outside
loops.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_mod-reg-rm_ADDRESSING:_"></a><a class="western" href="#T0706"><font size="4"><i><b>mod-reg-rm</b></i></font><font size="4"><b>
ADDRESSING: SLOW, BUT NOT </b></font><font size="4"><i><b>QUITE</b></i></font><font size="4"><b>
AS SLOW AS YOU THINK</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">There's no doubt about
it: <i>mod-reg-rm</i> addressing is slow. Still, relative
to
register operands, <i>mod-reg-rm</i> operands might not be
quite so
slow as you think, for a very strange reason &#8212; the prefetch
queue. <i>mod-reg-rm</i> addressing executes so slowly
that it
allows time for quite a few instruction bytes to be prefetched, and
that means that instructions that use <i>mod-reg-rm</i>
addressing
often run at pretty much their official speed.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Consider this. <b>mov
al,bl</b> is a 2-byte, 2-cycle instruction. String a few such
instructions together and the prefetch queue empties, making the
actual execution time 8 cycles &#8212; the time it takes to fetch the
instruction bytes. </font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> By
contrast, <b>mov
al,[bx]</b> is a 2-byte, 13-cycle instruction. Counting both the
memory access needed to read the operand pointed to by BX and the two
instruction fetches, only 3 memory accesses are incurred by this
instruction. Since 3 memory accesses take only 12 cycles, the
13-cycle official execution time of <b>mov al,[bx]</b> is
a fair
reflection of the instruction's true performance.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">That doesn't mean that
<b>mov al,[bx]</b> is <i>faster</i> than <b>mov
al,bl</b>, or that
memory-accessing instructions are faster than register-only
instructions &#8212; they're not. <b>mov al,bl</b> is a minimum
of
about 50% faster than <b>mov al,[bx]</b> under any
circumstances. What it does mean is that memory-accessing instructions
tend to
suffer less from the prefetch queue cycle-eater than do register-only
instructions, because the considerably longer execution times of
memory-accessing instructions often allow a good deal of prefetching
per instruction byte executed. As a result, the performance
difference between the two is often not quite so great as official
execution times would indicate.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In
short,
memory-accessing instructions, especially those that use <i>mod-reg-rm</i>
addressing, generally have a better balance between overall memory
access time and execution time than register-only instructions, and
consequently run closer to their rated speeds. That's a mixed
blessing, since it's a side effect of the slow speed of
memory-accessing instructions, but it does make memory access &#8212;
which is, after all, a necessary evil &#8212; somewhat less
unappealing than it might seem. </font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Let
me emphasize that
the basic reason that instructions that use <i>mod-reg-rm</i>
memory
accesses suffer less from the prefetch queue cycle-eater than do
equivalent register-only instructions is that both sorts of
instructions have <i>mod-reg-rm</i> bytes. True,
register-only
<i>mod-reg-rm</i> instructions don't have EA calculation
times, but
they do have at least 2 bytes, making them as long as the shortest
<i>mod-reg-rm</i> memory-accessing instructions. (A number
of
non-<i>mod-reg-rm</i> instructions are just 1 byte long;
we'll meet
them over the next few chapters.) Since register-only instructions
are much faster than memory-accessing instructions, it's just common
sense that if they're the same length in bytes then they can be hit
much harder by the prefetch queue cycle-eater.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Still and all,
register-only <i>mod-reg-rm</i> instructions are <i>never</i>
longer
than memory-accessing <i>mod-reg-rm</i> instructions, and
are shorter
than memory-accessing instructions that use displacements. What's
more, since memory-accessing instructions must by definition access
memory at least once apart from fetching instruction bytes,
register-only <i>mod-reg-rm</i> instructions must be at
least 50%
faster than their memory-accessing equivalents &#8212; 100% when
word-sized operands are used. To sum up, register-only instructions
are always much faster and often smaller than equivalent <i>mod-reg-rm</i>
memory-accessing instructions. (Register-only instructions are faster
than, although not necessarily shorter than or even as short as,
non-<i>mod-reg-rm</i> instructions &#8212; even the string
instructions &#8212; as well.) </font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <i>Avoid
memory. Use
the registers as much as you possibly can.</i></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_THE_IMPORTANCE_OF"></a><a class="western" href="#T0706"><font size="4"><b>THE
IMPORTANCE OF ADDRESSING WELL</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">When you do use
<i>mod-reg-rm</i> addressing, do so efficiently. As we've
discussed,
that means using base-or index-only addressing whenever possible, and
avoiding displacements when you can, especially inside loops. If
you're only going to access a memory location once and you don't have
a pointer to that location already loaded into BX, BP, SI, or DI,
just use direct addressing; base-and index-only addressing aren't so
much faster than direct addressing that it pays to load a pointer. As
we've seen, however, don't use direct addressing inside a loop if
you can load a pointer register outside the loop and then use base-or
index-only addressing inside the loop.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">It's often surprising
how much more efficient than direct addressing base-and index-only
addressing are. Consider this simple bit of code:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov dl,[ByteVar]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> and dl,0fh</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov [ByteVar],dl</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">You
wouldn't think that
code could be improved upon by <i>adding</i> an
instruction, but we
can cut the code's size from 10 to 9 bytes by using base-only
addressing:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov bx,offset
ByteVar</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov dl,[bx]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> and dl,0fh</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov [bx],dl</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">The
cycle count is 2
higher for the latter version, but a 2-byte advantage in instruction
fetching could well overcome that.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
point is not that
base-only addressing is always the best solution. In fact, the
latter example could be made much more efficient simply by anding 0Fh
directly with memory, as in:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> and [ByteVar],0fh</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">(Always
bear in mind
that memory can serve as the destination operand as well as the
source operand. When only one modification is involved, it's always
faster to modify a memory location directly, as in the last example,
than it is to load a register, modify the register, and store the
register back to memory. However, the scales tip when two or more
modifications to a memory operand are involved, as we'll see in
Chapter 8.) The special accumulator-specific direct-addressing
instructions that we'll discuss in the next chapter make direct
addressing more desirable in certain circumstances as well.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
point is that for
repeated accesses to the same memory location, you should arrange
your code so that the most efficient possible instruction &#8212;
base-only, a string instruction, whatever fills the bill &#8212; can
be used. In the last example, base-only addressing was superior to
direct addressing when just two accesses to the same byte were
involved. Multiply the number of accesses by ten, or a hundred, or a
thousand, as is often the case in a tight loop, and you'll get a feel
for the importance of selecting the correct memory addressing mode in
your time-critical code.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_THE_8088_IS"></a><a class="western" href="#T0706"><font size="4"><b>THE
8088 IS FASTER AT MEMORY ADDRESS CALCULATIONS THAN YOU ARE</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> You
may recall that we
found earlier that when you must access a word-sized memory operand,
it is better to let the 8088 access the second byte than to do it
with a separate instruction; the 8088 is simply faster at accessing
two adjacent bytes than any two instructions can be. Much the same
is true of <i>mod-reg-rm</i> addressing; the 8088 is
faster at
performing memory address calculations than you are. If you must add
registers and/or constant values to address memory, the 8088 can do
it faster during EA calculations than you can with separate
instructions.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Suppose that we have
to initialize a doubleword of memory pointed to by BX to zero. We
could do that with:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov word
ptr [bx],0</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> inc bx</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> inc bx</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov word
ptr [bx],0</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">However,
it's better to
let the 8088 do the addressing calculations, as follows: </font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov word
ptr [bx],0</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov word
ptr [bx+2],0</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">True,
the latter
version involves a 1-byte displacement, but that displacement is
smaller than the 2 bytes required to advance BX in the first version.
Since the incremental cost of base+displacement addressing over
base-only addressing is 4 cycles, exactly the same number of cycles
as two <b>inc</b> instructions, the code that uses
base+displacement
addressing is clearly superior.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Similarly, you're
invariably better off letting EA calculations add one register to
another than you are using <b>add</b>. For example,
consider two
approaches to scanning an array pointed to by BX+SI for the byte in
AL:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov dx,bx ;set
aside the base address</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>ScanLoop:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov bx,dx ;get
back the base address</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> add bx,si ;add
in the index</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> cmp [bx],al ;is
this a match?</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jz ScanFound ;yes,
we're done</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> inc si ;advance
the index to the next byte</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jmp ScanLoop ;scan
the next byte</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>ScanFound:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"> </font></font></p>
<p class="western" style="margin-bottom: 0in; margin-left: 40px;"><font color="#110d06"><font color="#0b0703">and:</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>ScanLoop:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> cmp [bx+si],al ;is
this a match?</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jz ScanFound ;yes,
we're done</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> inc si ;advance
the index to the next byte</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jmp ScanLoop ;scan
the next byte</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>ScanFound:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">It
should be pretty
clear that the approach that lets the 8088 add the two memory
components together is far superior.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">While the point is
perhaps a little exaggerated &#8212; I seriously doubt anyone would
use the first approach &#8212; it is nonetheless valid. The 8088 can
add BX to SI in just 2 extra cycles as part of an EA calculation, and
at the cost of no extra bytes at all. What's more, EA calculations
leave all registers unchanged. By contrast, at least one register
must be changed to hold the final memory address when you perform
memory calculations yourself. That's what makes the first version
above so inefficient; we have to reload BX from DX every time through
the loop because it's altered by the memory-address calculation.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> I
hope you noticed
that neither example above is particularly efficient. We'd be better
off simply adding the two memory components <i>outside</i>
the loop
and using base-or index-only addressing inside the loop. (We'd be
even better off using string instructions, but we'll save that for
another chapter.) To wit:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> add si,bx ;add
together the memory address components</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ;
outside the loop</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>ScanLoop:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> cmp [si],al ;is
this a match?</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jz ScanFound ;yes,
we're done</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> inc si ;point
to the next byte</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jmp ScanLoop ;scan
the next byte</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>ScanFound:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">Although
EA
calculations can add faster than separate instructions can, it's
faster still not to add at all. <i>Whenever you can, perform
your
calculations outside loops.</i></font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Which brings us to
<b>lea</b>.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_CALCULATING_EFFECTIVE_ADDRESSES"></a><a class="western" href="#T0706"><font size="4"><b>CALCULATING
EFFECTIVE ADDRESSES WITH lea</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <b>lea</b>
is
something of an odd bird, as the only <i>mod-reg-rm</i>
memory-addressing instruction that doesn't access memory. <b>lea</b>
calculates the offset of the memory operand...and then loads that
offset into one of the 8 general-purpose registers, without accessing
memory at all. Basically, <b>lea</b> is nothing more than
a means by
which to load the result of an EA calculation into a register.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> For
example, <b>lea
bx,[MemVar]</b> loads the offset of <b>MemVar</b>
into BX. Now, we
wouldn't generally want to use <b>lea</b> to load simple
offsets,
since <b>mov</b> can do that more efficiently; <b>mov
bx,offset
MemVar</b> is 1 byte shorter and 4 cycles faster than <b>lea
bx,[MemVar]</b>. (Since <b>lea</b> involves EA
calculation, it's not
particularly fast; however, it's faster than any <i>mod-reg-rm</i>
memory-accessing instruction, taking only 2 cycles plus the EA
calculation time.)</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <b>lea</b>
shines when
you need to load a register with a complex memory address, preferably
without disturbing any of the registers that make up the memory
address. Suppose that we want to push the address of an array
element that's indexed by BP+SI. We could use:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ax,offset
TestArray</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> add ax,bp</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> add ax,si</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> push ax</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">which
is 8 bytes long. On the other hand, we could simply use:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> lea ax,[TestArray+bp+si]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> push ax</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">which
is only 5 bytes
long. One of the primary uses of <b>lea</b> is loading
offsets of
variables in stack frames, because such variables are addressed with
base+displacement addressing.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Refer back to the
example we examined in the last section. Suppose that we wanted to
scan memory without disturbing either BX or SI. In that case, we
could use DI, with an assist from <b>lea</b>:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> lea di,[bx+si] ;add
together the memory address components</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ;
outside the loop</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>ScanLoop:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> cmp [di],al ;is
this a match?</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jz ScanFound ;yes,
we're done</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> inc di ;point
to the next byte</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jmp ScanLoop ;scan
the next byte</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>ScanFound:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><b>lea</b>
is
particularly handy in this case because it can add two registers &#8212;
BX and SI &#8212; and place the result in a third register &#8212;
DI. That enables us to replace the two instructions:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov di,bx</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> add di,si</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">with
a single <b>lea</b>.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <b>lea</b>
should make
it clear that offsets are just 16-bit numbers. Adding offsets stored
in BX and SI together with <b>lea</b> is no different from
adding any
two 16-bit numbers together with <b>add</b>, because
offsets are just
16-bit numbers. 0 is a valid offset; if we execute:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> sub bx,bx ;load
BX with 0</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov al,[bx] ;load
AL with the byte at offset 0 in DS</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">we'll
read the byte at
offset 0 in the segment pointed to by DS. It's important that you
understand that offsets are just numbers, and that you can manipulate
offsets every bit as flexibly as any other values. </font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
flip side is that
you could, if you wished, add two registers and/or a constant value
together with <b>lea</b> and place the result in a third
register. Of course, the registers would have to be BX or BP and SI or
DI, but
since offsets and numbers are one and the same, there's no reason
that <b>lea</b> couldn't be used for arithmetic under the
right
circumstances. For example, here's one way to add two memory
variables and 52 together and store the result in DX:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov bx,[MemVar1]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov si,[MemVar2]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> lea dx,[bx+si+52]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">That's
not to say this
is a <i>good</i> way to perform this particular task; the
following
is faster and uses fewer registers:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov dx,[MemVar1]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> add dx,[MemVar2]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> add dx,52</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">Nonetheless,
the first
approach does serve to illustrate the flexibility of <b>lea </b>and
the equivalence of offsets and numbers.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_OFFSET_WRAPPING_AT"></a><a class="western" href="#T0706"><font size="4"><b>OFFSET
WRAPPING AT THE ENDS OF SEGMENTS</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Before we take our
leave of <i>mod-reg-rm</i> addressing, I'd like to repeat
a point
made earlier that may have slipped past unnoticed. That point is
that offsets wrap at the ends of segments. Offsets are 16-bit
entities, so they're limited to the range 0 to 64 K-1. However, it
is possible to use two or three <i>mod-reg-rm</i> address
components
that together add up to a number that's larger than 64 K. For
example, the sum of the memory addressing components in the following
code is 18000h:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov bx,4000h</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov di,8000h</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ax,[bx+di+0c000h]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">What happens in such a
case? We found earlier that segments are limited to 64 Kb in length;
is this a clever way to enlarge the effective size of a segment?</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Alas, no. If the sum
of two offset components won't fit in 16 bits, bits 16 and above of
the sum are simply ignored. In other words, <i>mod-reg-rm</i>
address calculations are always performed modulo 64 K (that is,
modulo 10000h), as shown in Figure 7.11. As a result, the last
example will access not the word at offset 18000h but the word at
offset 8000h. Likewise, the following will access the byte at offset
0:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov bx,0ffffh</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov dl,[bx+1]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_m3eec2a84.jpg" align="bottom" border="0" height="641" width="626"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
same rule holds
for all memory-accessing instructions, <i>mod-reg-rm</i>
or
otherwise: <i>offsets are 16-bit values; any additional bits
that
result from address calculations are ignored</i>. Put another
way,
memory addresses that reach past the end of a segment's 64 K limit
wrap back to the start of the segment. This allows the use of
negative displacements, and is the reason a displacement can always
reach anywhere in a segment, including addresses lower than those in
the base and/or index registers, as in <b>mov ax,[bx-1]</b>.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h2 class="western"><font color="#110d06"><font color="#0b0703"><a name="_NON-mod-reg-rm_MEMORY_ADDRESSING"></a><a class="western" href="#T0707"><font style="font-size: 16pt;" size="4"><b>7.7
NON-</b></font><font style="font-size: 16pt;" size="4"><i><b>mod-reg-rm</b></i></font><font style="font-size: 16pt;" size="4"><b>
MEMORY ADDRESSING</b></font></a></font></font></h2>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <i>mod-reg-rm</i>
addressing is the most flexible memory addressing mode of the 8088,
and the most widely-used as well, but it's certainly not the <i>only</i>
addressing mode. The 8088 also offers a number of specialized
addressing modes, including stack addressing and the string
instructions. These addressing modes are supported by fewer
instructions than <i>mod-reg-rm</i> instructions, and are
considerably more restrictive about the operands they'll accept &#8212;
but they're also more compact and/or faster than the <i>mod-reg-rm</i>
instructions.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Why
are instructions
that use the non-<i>mod-reg-rm</i> addressing modes
generally
superior to <i>mod-reg-rm</i> instructions? Simply this:
being less
flexible than <i>mod-reg-rm</i> instructions, they have
fewer
possible operands to specify, and so fewer instruction bits are
needed. Non-<i>mod-reg-rm</i> instructions also don't
require any EA
calculation time, because they don't support the many addressing
modes of the <i>mod-reg-rm</i> byte.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">We'll discuss five
sorts of non-<i>mod-reg-rm</i> memory-addressing
instructions next: special forms of common instructions, string
instructions,
immediate-addressing instructions, stack-oriented instructions, and
<b>xlat</b>, which is in a category all its own. For all
these sorts
of instructions, the rule is that if they're well matched to your
application, they're almost surely worth using in preference to
<i>mod-reg-rm</i> addressing. Some of the non-<i>mod-reg-rm</i>
instructions, especially the string instructions, are so much faster
than <i>mod-reg-rm</i> instructions that they're worth
going out of
your way for, as we'll see throughout <i>The Zen of Assembly
Language</i>.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_SPECIAL_FORMS_OF"></a><a class="western" href="#T0707"><font size="4"><b>SPECIAL
FORMS OF COMMON INSTRUCTIONS</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
8088 offers
special shorter, faster forms of several commonly used <i>mod-reg-rm</i>
instructions, including <b>mov</b>, <b>inc</b>,
and <b>xchg</b>. These special forms are both shorter and
less flexible than the
<i>mod-reg-rm</i> forms. For example, the special form of <b>inc</b>
is just 1 byte long and requires only 2 cycles to execute, but can
only work with 16-bit registers. By contrast, the <i>mod-reg-rm</i>
form of <b>inc</b> is at least 2 bytes long and takes at
least 3
cycles to execute, but can work with 8-or 16-bit registers or memory
locations.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> You
don't have to
specify that a special form of an instruction is to be used; the
assembler automatically selects the shortest possible form of each
instruction it assembles. That doesn't mean that you don't need to be
familiar with the special forms, however. To the contrary, you need
to be well aware of the sorts of instructions that have special
forms, as well as the circumstances under which those special forms
will be assembled. Armed with that knowledge, you can arrange your
code so that the special forms will be assembled as often as
possible.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">We'll get a solid feel
for the various special forms of <i>mod-reg-rm</i>
instructions as we
discuss them individually in Chapters 8 and 9.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_THE_STRING_INSTRUCTIONS"></a><a class="western" href="#T0707"><font size="4"><b>THE
STRING INSTRUCTIONS</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
string
instructions are without question the most powerful instructions of
the 8088. String instructions can initialize, copy, scan, and
compare arrays of data at speeds far beyond those of mortal
<i>mod-reg-rm</i> instructions, and lend themselves well to
almost
any sort of repetitive processing. In fact, string instructions are
so important that they get two full chapters of <i>The Zen of
Assembly Language</i> &#8212; Chapters 10 and 11 &#8212; to
themselves. We'll defer further discussion of these extremely
important instructions until then.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_IMMEDIATE_ADDRESSING"></a><a class="western" href="#T0707"><font size="4"><b>IMMEDIATE
ADDRESSING</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Immediate addressing
is a form of memory addressing in which the constant value of one
operand is built right into the instruction. You should think of
immediate operands as being addressed by IP, since they directly
follow opcode bytes or <i>mod-reg-rm</i> bytes, as shown
in Figure
7.12.</font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_77fb0464.jpg" align="bottom" border="0" height="295" width="626"></font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Instructions that use
immediate addressing are clearly faster than instructions that use
<i>mod-reg-rm</i> addressing. In fact, according to
official
execution times, immediate addressing would seem to be <i>much</i>
faster than <i>mod-reg-rm</i> addressing. For example, <b>add
ax,1</b>
is a 4-cycle instruction, while <b>add ax,[bx]</b> is an
18-cycle
instruction. What's more, <b>add </b><i><b>reg</b></i><b>,</b><i><b>immed</b></i>
is just 1 cycle slower than <b>add </b><i><b>reg</b></i><b>,</b><i><b>reg</b></i>,
so immediate addressing seems to be nearly as fast as register
addressing.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
official cycle
counts are misleading, however. While immediate addressing is
certainly faster than <i>mod-reg-rm</i> addressing, it is
by no means
as fast as register-only addressing, and the reason is a familiar
one: the prefetch queue cycle-eater. You see, immediate operands
are instruction bytes; when we use an immediate operand, we increase
the size of that instruction, and that increases the number of cycles
needed to fetch the instruction's bytes.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Looked at another way,
immediate operands need to be fetched from the memory location
pointed to by IP, so immediate addressing could be considered a
memory addressing mode. Granted, immediate addressing is an efficient
memory addressing mode, with no EA calculation time or the like &#8212;
but memory accesses are nonetheless required, at the inescapable 4
cycles per byte.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
upshot is simply
that register operands are superior to immediate operands in loops
and time-critical code, although immediate operands are still much
better than <i>mod-reg-rm</i> memory operands. Back in <a class="western" href="#L711">Listing
7-11</a>, we set DL to 0 outside the loop so that we could use
register-register <b>adc</b> inside the loop. That
approach allowed
the code to run in 0.95 ms. <a name="L712R"></a><a class="western" href="#L712">Listing
7-12</a> is similar to <a class="western" href="#L711">Listing
7-11</a>,
but is modified to use an immediate operand of 0 rather than a
register operand containing 0. Even though the immediate operand is
only byte-sized, <a class="western" href="#L712">Listing
7-12</a>
slows down to 1.02 ms. In other words, the need to fetch just 1
immediate operand byte every time through the loop slowed the entire
loop by about 7%. What's more, the performance loss would have been
approximately twice as great if we had used a word-sized immediate
operand.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> On
the other hand,
immediate operands are certainly preferable to memory operands. <a name="L713R"></a><a class="western" href="#L713">Listing 7-13</a>,
which adds the
constant value 0 from memory, runs in 1.26 ms. (I should hope you'll
never use code as obviously inefficient as <a class="western" href="#L713">Listing
7-13</a>; I'm just presenting it for illustrative purposes.)</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> To
sum up: when speed
matters, use register operands rather than immediate operands if you
can. If registers are at a premium, however, immediate operands are
reasonably fast, and are certainly better than memory operands. If
bytes rather than cycles are at a premium, immediate operands are
excellent, for it takes fewer bytes to use an immediate operand than
it does to load a register with a constant value and then use that
register. For example:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>LoopTop:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> or byte
ptr [bx],80h</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> loop LoopTop</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">is 1
byte shorter than:
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov al,80h</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>LoopTop:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> or [bx],al</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> loop LoopTop</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">However,
the latter,
register-only version is faster, because it moves 2 bytes out of the
loop.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">There are many
circumstances in which we can substitute register-only instructions
for instructions that use immediate operands <i>without</i>
adding
any extra instructions. The commonest of these cases involve testing
for zero. There's almost never a need to compare a register to zero;
instead, we can simply <b>and</b> or <b>or</b>
the register with
itself and check the resulting flags. We'll discuss ways to handle
zero in the next two chapters, and we'll see similar cases in which
immediate operands can be eliminated throughout <i>The Zen of
Assembly Language</i>.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> By
the way, you should
be aware that you can use an immediate operand even when the other
operand is a memory variable rather than a register. For example,
<b>add [MemVar],16</b> is a valid instruction, as is <b>mov
[MemVar],52</b>. As I mentioned earlier, we're better off
performing
single operations directly to memory than we are loading from memory
into a register, operating on the register, and storing the result
back to memory. However, we're generally better off working with a
register when multiple operations are involved.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Ideally, we'd load a
memory value into a register, perform multiple operations on it
there, store the result back to memory...and then have some
additional use for the value left in the register, thereby getting
double use out of our memory accesses. For example, suppose that we
want to perform the equivalent of the C statement:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> i
= ++j + k;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">We
could do this as
follows:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> inc [j]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ax,[j]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> add ax,[k]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov [i],ax</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">However,
we can
eliminate a memory access by incrementing <b>j</b> in a
register:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ax,[j]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> inc ax</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov [j],ax</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> add ax,[k]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov [i],ax</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">While
the latter
version is one instruction longer than the original version, it's
actually faster and shorter. One reason for this is that we get
double use out of loading <b>j</b> into AX; we increment <b>j</b>
in
AX and store the result to memory, then immediately use the
incremented value left in AX as part of the calculation being
performed.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
other reason the
second example above is superior to the original version is that it
used two of the special, more efficient instruction forms: the
accumulator-specific direct-addressed form of <b>mov</b>
and the
16-bit register-only form of <b>inc</b>. We'll study these
instructions in detail in Chapters 8 and 9.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_SIGN-EXTENSION_OF_IMMEDIATE"></a><a class="western" href="#T0707"><font size="4"><b>SIGN-EXTENSION
OF IMMEDIATE OPERANDS</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">I've already noted
that immediate operands tend to make for compact code. One key to
this property is that like displacements in <i>mod-reg-rm</i>
addressing, word-sized immediate operands can be stored as a byte and
then extended to a word by replicating bit 7 as bits 15-8; that is,
word-sized immediate operands can be sign-extended. Almost all
instructions that support immediate operands allow word-sized
operands in the range -128 to +127 to be stored as single bytes. That
means that while <b>and dx,1000h</b> is a 4-byte
instruction (1
opcode byte, 1 <i>mod-reg-rm</i> byte, and a 2-byte
immediate
operand), <b>and dx,0fffeh</b> is just 3 bytes long; since
the signed
value of the immediate operand 0FFFEh is -2, 0FFFEh is stored as a
single immediate operand byte.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Not
all values of the
form 000<i>nn</i>h and 0FF<i>nn</i>h (where <i>nn</i>
is any two hex
digits) can be stored as a single byte and sign-extended. 0007Fh can
be stored as a single byte; 00080h cannot. 0FF80h can be stored as a
single byte; 0FF7Fh cannot. Watch out for cases where you're using a
word-sized immediate operand that can't be stored as a byte, when a
byte-sized immediate operand would serve as well.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> For
example, suppose
we want to set the lower 8 bits of DX to 0. <b>and dx,0ff00h</b>
is
a 4-byte instruction that accomplishes the desired result. <b>and
dl,000h</b> produces the same result in just 3 bytes. (Of course,
<b>sub dl,dl</b> does the same thing in just 2 bytes &#8212;
there
are <i>many</i> ways to skin a cat in assembler.)
Recognizing when a
word-sized immediate operand can be handled as a byte-sized operand
is still more important when using accumulator-specific
immediate-operand instructions, which we'll explore in the next
chapter.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_mov_DOESN'T_SIGN-EXTEND"></a><a class="western" href="#T0707"><font size="4"><b>mov
DOESN'T SIGN-EXTEND IMMEDIATE OPERANDS</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Along the same lines,
<b>or bh,0ffh</b> does the same thing as <b>or
bx,0ff00h</b> and is
shorter, while <b>mov bh,0ffh</b> is also equivalent and
is shorter
still...and that brings us to the one instruction which cannot
sign-extend immediate operands: <b>mov</b>. Word-sized
operands to
<b>mov</b> are always stored as words, no matter what size
they may
be. However, there's a compensating factor, and that's that there's
a special, non-<i>mod-reg-rm</i> form of <b>mov </b><i><b>reg</b></i><b>,</b><i><b>immed</b></i>
that's 1 byte shorter than the <i>mod-reg-rm</i> form.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Let
me put it this
way. <b>and dx,1000h</b> is a 4-byte instruction, with 1
opcode
byte, 1 <i>mod-reg-rm</i> byte, and a 2-byte immediate
operand. <b>mov
dx,1000h</b>, on the other hand, is only 3 bytes long. There's a
special form of the <b>mov</b> instruction, used only when
a register
is loaded with an immediate value, that requires just the 1 opcode
byte in addition to the immediate value.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">There's also the
standard <i>mod-reg-rm</i> form of <b>mov</b>,
which is 4 bytes long
for word-sized immediate operands. This form does exactly the same
thing as the special form, but is a different instruction, with a
different opcode and a <i>mod-reg-rm</i> byte. The 8088
offers a
number of duplicate instructions, as we'll see in the next chapter.
Don't worry about selecting the right form of <b>mov</b>,
however;
the assembler does that for you automatically.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In
short, you're no
worse off &#8212; and often better off &#8212; moving immediate
values into registers than you are using immediate operands with
instructions such as <b>add</b> and <b>xor</b>.
It takes just 2 or 3
bytes, for byte-or word-sized registers, respectively, to load a
register with an immediate operand. <b>mov al,2</b> is
actually the
same size as <b>mov al,bl</b> (both are 2 bytes), although
the
official execution time of the register-only <b>mov</b> is
2 cycles
shorter.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> On
balance, immediate
operands used with <b>mov </b><i><b>reg</b></i><b>,</b><i><b>immed</b></i>
perform at nearly the speed of register operands, especially when the
register is byte-sized; consequently, there's less need to avoid
immediate operands with <b>mov</b> than with other
instructions.
Nonetheless, register-only instructions are never slower, so you
won't go wrong using register rather than immediate operands.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_DON'T_mov_IMMEDIATE"></a><a class="western" href="#T0707"><font size="4"><b>DON'T
mov IMMEDIATE OPERANDS TO MEMORY IF YOU CAN HELP IT</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> One
final note, and
then we're done with immediate addressing. There is <i>no</i>
special form of <b>mov</b> for moving an immediate operand
to a
memory operand; the special form is limited to register operands
only. What's more, <b>mov [</b><i><b>mem16</b></i><b>],</b><i><b>immed16</b></i>
has no sign-extension capability. This double whammy means that
storing immediate values to memory is the single least desirable way
to use immediate operands. Over the next few chapters, we'll explore
several ways to set memory operands to given values. The one thing
that the various approaches have in common is that they all improve
performance by avoiding immediate operands to <b>mov</b>.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <i>Don't
move
immediate values to memory unless you have no choice.</i></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_STACK_ADDRESSING"></a><a class="western" href="#T0707"><font size="4"><b>STACK
ADDRESSING</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">While SP can't be used
to point to memory by <i>mod-reg-rm</i> instructions, it
is
nonetheless a memory-addressing register. After all, SP is used to
address the top of the stack. Surely you know how the stack works,
so I'll simply note that SP points to the data item most recently
pushed onto the top of the stack that has not yet been popped off the
stack. Consequently, stack data can only be accessed in Last In,
First Out (LIFO) order via SP (that is, the order in which data is
popped off the stack is the reverse of the order in which it was
pushed on). However, other addressing modes &#8212; in particular
<i>mod-reg-rm</i> BP-based addressing &#8212; can be used to
access
stack data in non-LIFO order, as we'll see when we discuss stack
frames.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">What's so great about
the stack? Simply put, the stack is terrific for temporary storage.
Each named memory variable, as in:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>MemVar dw 0</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">takes
up 1 or more
bytes of memory for the duration of the program. That's not the case
with stack data, however; when data is popped from the stack, the
space it occupied is freed up for other use. In other words, stack
memory is a reusable resource. This makes the stack an excellent
place to store temporary data, especially when large data elements
such as buffers and structures are involved.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Space allocated on the
stack is also unique for each invocation of a given subroutine, which
is useful for any subroutine that needs to be capable of being called
directly or indirectly from itself. Stack-based storage is how C
implements automatic (dynamic) variables, which are unique for each
invocation of a given subroutine. In fact, stack-based storage is
the heart of the parameter-passing mechanism used by most C
implementations, as well as the mechanism used for automatic
variables, as we'll see shortly.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Don't underestimate
the flexibility of the stack. I've heard of programs that actually
compile code right into a buffer on the stack, then execute that code
in place, <i>on the stack</i>. While that's a strange
concept, stack
memory is memory like any other, and instruction bytes are data;
obviously, those programs needed a temporary place in which to
compile code, run it, and discard it, and the stack fits those
requirements nicely.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Similarly, suppose
that we need to pass a pointer to a variable from an assembler
program to a C subroutine...but there's no variable to point to in
the assembler code, because we keep the variable in a register. Suppose
also that the C subroutine actually modifies the pointed-to
variable, so we need to retrieve the altered value after the call. The
stack is admirably suited to the job; at the beginning of the
following code, the variable of interest is in DX, and that's just
where the modified result is at the end of the code:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;
Calls: int CSubroutine(int *Count, char *BufferPointer).</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov dx,MAX_COUNT ;store
the maximum # of bytes to handle</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ;
in the count variable</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> push dx ;store
the count variable on the stack</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ;
for the duration of the call</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov dx,sp ;put
a pointer to the just-pushed temporary</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ;
count variable in DX</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ax,offset
TestBuffer</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> push ax ;pass
the buffer pointer parameter</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> push dx ;pass
the count pointer parameter</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> call CSubroutine ;do
the count</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> add sp,4 ;clear
the parameter bytes from the stack</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> pop dx ;get
the actual count back into DX</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
important point in
the above code is that we created a temporary memory variable on the
stack as we needed it; then, when the call was over, we simply popped
the variable back into DX, and its space on the stack was freed up
for other use. The code is compact, and not a single byte of memory
storage had to be reserved permanently.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Compact code without
the need for permanent memory space is the hallmark of stack-based
code. It's often possible to write amazingly complex code without
using <i>mod-reg-rm</i> addressing or named variables
simply by
pushing and popping registers. The code tends to be compact because
<b>push </b><i><b>reg16</b></i>
and <b>pop </b><i><b>reg16</b></i>
are each only 1 byte long. <b>push </b><i><b>reg16</b></i>
and <b>pop
</b><i><b>reg16</b></i> are so compact
because they don't need to
support the complex memory-addressing options of <i>mod-reg-rm</i>
addressing; there are only 8 possible register operands, and each
instruction can only address one location, by way of the stack
pointer, at any one time. (<b>push </b><i><b>mem16</b></i>
and <b>pop
</b><i><b>mem16</b></i> are <i>mod-reg-rm</i>
instructions, and so
they're 2-4 bytes long; <b>push </b><i><b>reg16</b></i>
and <b>pop
</b><i><b>reg16</b></i>, and <b>push
</b><i><b>segreg</b></i> and <b>pop
</b><i><b>segreg</b></i> as well, are
special, shorter forms of <b>push</b>
and <b>pop</b>.)</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> For
once, though,
shorter isn't necessarily better. You see, <b>push</b> and
<b>pop</b>
are memory-accessing instructions, and although they don't require EA
calculation time, they're still slow -like all instructions that
access memory. <b>push</b> and <b>pop</b> are
fast considering that
they are word-sized memory-accessing instructions -<b>push</b>
takes
15 cycles, <b>pop</b> takes just 12 &#8212; and they make for
good
prefetching, since only 3 memory accesses (including instruction
fetches) are performed during an official execution time of 12 to 15
cycles. Nonetheless, they're clearly slower than register-only
instructions. This is basically the same case we studied when we
looked into copying segments; it's faster but takes more bytes and
requires a free register to preserve a register by copying it to
another register:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov dx,ax</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> :</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ax,dx</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">than
it is to preserve
it by pushing and popping it:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> push ax</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> :</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> pop ax</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">What does all this
mean to you? Simply this: use a free register for temporary storage
if speed is of the essence, and <b>push</b> and <b>pop</b>
if code
size is your primary concern, if speed is not an issue, or if no
registers happen to be free. In any case, it's faster and far more
compact to store register values temporarily by pushing and popping
them than it is to store them to memory with <i>mod-reg-rm</i>
instructions. So use <b>push</b> and <b>pop</b>...but
remember that
they come with substantial performance overhead relative to
register-only instructions.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_AN_EXAMPLE_OF"></a><a class="western" href="#T0707"><font size="4"><b>AN
EXAMPLE OF AVOIDING push AND pop</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Let's quickly look at
an example of improving performance by using register-only
instructions rather than <b>push</b> and <b>pop</b>.
When copying
images into display memory, it's common to use code like:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;
Copies an image into display memory.</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;
Input:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>; BX
= width of image in bytes</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>; DX
= height of image in lines</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>; BP
= number of bytes from the start of one line to the</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>; start
of the next</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>; DS:SI
= pointer to image to draw</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>; ES:DI
= display memory address at which to draw image</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>; Direction
flag must be cleared on entry</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;
Output:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>; none</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>DrawLoop:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> push di ;remember
where the line starts</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov cx,bx ;#
of bytes per line</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> rep movsb ;copy
the next line</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> pop di ;get
back the line start offset</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> add di,bp ;point
to the next line in display memory</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> dec dx ;repeat
if there are any more lines</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jnz DrawLoop</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">That's fine, but 1
<b>push</b> and 1 <b>pop</b> are performed per
line, which seems a
shame...all the more so given that we can eliminate those pushes and
pops altogether, as follows:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;
Copies an image into display memory.</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;
Input:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>; BX
= width of image in bytes</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>; DX
= height of image in lines</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>; BP
= number of bytes from the start of one line to the</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>; start
of the next</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>; DS:SI
= pointer to image to draw</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>; ES:DI
= display memory address at which to draw image</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>; Direction
flag must be cleared on entry</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;
Output:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>; none</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> sub bp,bx ;#
of bytes from the end of 1 line of the</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ;
image in display memory to the start of</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ;
the next line of the image</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>DrawLoop:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov cx,bx ;#
of bytes per line</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> rep movsb ;copy
the next line</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> add di,bp ;point
to the next line in display memory</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> dec dx ;repeat
if there are any more lines</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jnz DrawLoop</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Do
you see what we've
done? By converting an obvious solution (advancing 1 full line at a
time) to a less-obvious but fully equivalent solution (advancing only
the remaining portion of the line), we've saved about 27 cycles per
loop...<i>at no cost</i>. Given inputs like the width of
the screen
and instructions like <b>push</b> and <b>pop</b>,
we tend to use
them; it's just human nature to frame solutions in familiar terms. By
rethinking the problem just a little, however, we can often find a
simpler, better solution.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Saving 27 cycles not
by knowing more instructions but by <i>not</i> using two
powerful
instructions is an excellent example indeed of the Zen of assembler. </font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_MISCELLANEOUS_NOTES_ABOUT"></a><a class="western" href="#T0707"><font size="4"><b>MISCELLANEOUS
NOTES ABOUT STACK ADDRESSING</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Before we proceed to
stack frames, I'd like to take a moment to review a few important
points about stack addressing.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> SP
always points to
the next item to be popped from the stack. When you push a value
onto the stack, SP is first decremented by 2, and then the value is
stored at the location pointed to by SP. When you pop a value off of
the stack, the value is read from the location pointed to by SP, and
then SP is incremented by 2. It's useful to know this whenever you
need to point to data stored on the stack, as we did when we created
and pointed to a temporary variable on the stack a few sections back,
and as we will need to do when we work with stack frames.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <b>push</b>
and <b>pop</b>
can work with <i>mod-reg-rm</i>-addressed memory variables
as easily
as with registers, albeit more slowly and with more instruction
bytes. <b>push [WordVar]</b> is perfectly legitimate, as
is <b>pop
word ptr [bx+si+100h]</b>. Bear in mind, however, that only
16-bit
values can be pushed and popped; <b>push bl</b> won't
work, and
neither will <b>pop byte ptr [bx]</b>.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Finally, please
remember that once you've popped a value from the stack, it's gone
from memory. It's tempting to look at the way the stack pointer
works and think that the data is still in memory at the address just
below the new stack pointer, but that's simply not the case, as shown
in Figure 7.13. Sure, <i>sometimes</i> the data is still
there &#8212;
but whenever an interrupt occurs, it uses the top of the stack,
wiping out the values that were most recently popped. Interrupts can
happen at any time, so unless you're willing to disable interrupts,
accessing popped stack memory is a sure way to get intermittent bugs.</font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_m7ad479.jpg" align="bottom" border="0" height="844" width="625"></font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Even if interrupts are
disabled, it's really not a good idea to access popped stack data. Why
bother, when stack frames give you the same sort of access to
stack data, but in a straightforward, risk-free way? Not
coincidentally, stack frames are our next topic, but first let me
emphasize: once you've popped data off the stack, it's gone from
memory. Vanished. Kaput. Extinct. For all intents and purposes,
that data is nonexistent.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <i>Don't
access popped
stack memory.</i> Period.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_STACK_FRAMES"></a><a class="western" href="#T0707"><font size="4"><b>STACK
FRAMES</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Stack frames are
transient data structures, usually local to specific subroutines,
that are stored on the stack. Two sorts of data are normally stored
in stack frames: parameters that are passed from the calling routine
by being pushed on the stack, and variables that are local to the
subroutine using the stack frame.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Why
use stack frames? Well, as we discussed earlier, the stack is an
excellent place to
store temporary data, a category into which both passed parameters
and local storage fall. <b>push</b> and <b>pop</b>
aren't good for
accessing stack frames, which often contain many variables and which
aren't generally accessed in LIFO order; however, there are several
<i>mod-reg-rm</i> addressing modes that are perfect for
accessing
stack frames &#8212; the <i>mod-reg-rm</i> addressing modes
involving
BP. (We can't use SP for two reasons: it can't serve as a memory
pointer with <i>mod-reg-rm</i> addressing modes, and it
changes
constantly during code execution, making offsets from SP hard to
calculate.)</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> If
you'll recall,
BP-based addressing modes are the only <i>mod-reg-rm</i>
addressing
modes that don't access DS by default. BP-based addressing modes
access SS by default, and now we can see why &#8212; in order to
access stack frames. Typically, BP is set to equal the stack pointer
at the start of a subroutine, and is then used to point to data in
the stack frame for the remainder of the subroutine, as in:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> push bp ;save
caller's BP</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov bp,sp ;point
to stack frame</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ax,[bp+4] ;retrieve
a parameter</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> :</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> pop bp ;restore
caller's BP</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ret</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">If
temporary local
storage is needed, SP is moved to allocate the necessary room:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> push bp ;save
caller's BP</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov bp,sp ;point
to stack frame</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> sub sp,10 ;allocate
10 bytes of local storage</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ax,[bp+4] ;retrieve
a parameter</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov [bp-2],ax ;save
it in local storage</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> :</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov sp,bp ;dump
the temporary storage</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> pop bp ;restore
caller's BP</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ret</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> I'm
not going to spend
a great deal of time on stack frames, for one simple reason: they're
not all that terrific in assembler code. Stack frames are ideal for
high-level languages, because they allow regular parameter-passing
schemes and support dynamically allocated local variables. For
assembler code, however, stack frames are quite limiting, in that
they require a single consistent parameter-passing convention and the
presence of code to create and destroy stack frames at the beginning
and end of each subroutine. In particular, the ability of assembler
code to pass pointers and variables in registers (which is much more
efficient than pushing them on the stack) is constrained by standard
stack frames conventions. In addition, the BP register, which is
dedicated to pointing to stack frames, normally cannot be used for
other purposes when stack frames are used; the loss of one of a mere
seven generally-available 16-bit registers is not insignificant.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">High-level language
stack frame conventions also generally mandate the preservation of
several registers &#8212; always BP, usually DS, and often SI and DI
as well &#8212; and that requires time-consuming pushes and pops. Finally,
while stack frame addressing is compact (owing to the heavy
use of <b>bp+</b><i><b>disp</b></i>
addressing with 1-byte
displacements), it is rather inefficient, even as memory-accessing
instructions go; <b>mov ax,[bp+</b><i><b>disp8</b></i><b>]</b>
is
only 3 bytes long, but takes 21 cycles to execute.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In
short, stack frames
are powerful and useful &#8212; but they don't make for the best
possible 8088 code. The best <i>compiled</i> code, yes,
but not the
best assembler code.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">What's more, compilers
handle stack frames very efficiently. If you're going to work within
the constraints of stack frames, you may have a difficult time
out-coding compilers, which rarely miss a trick in terms of
generating efficient stack frame code. Handling stack frames well is
not so simple as it might seem; you have to be sure <i>not</i>
to
insert unneeded stack-frame-related code, such as code to load BP
when there is no stack frame, and you need to be sure that you always
preserve the proper registers when they're altered, but not
otherwise. It's not hard, but it's tedious, and it's easy to make
mistakes that either waste bytes or lead to bugs as a result of
registers that should be preserved but aren't.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">When you work with
stack frames, you're trying to out-compile a compiler while playing
by its rules, and that's hard to do. In pure assembler code, I
generally recommend against the use of stack frames, although there
are surely exceptions to this rule. Personally, I often use C for
the sort of code that requires stack frames, building only the
subroutines that do the time-critical work in pure assembler. Why
not let a compiler do the dirty work, while you focus your efforts on
the code that really makes a difference?</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_WHEN_STACK_FRAMES"></a><a class="western" href="#T0707"><font size="4"><b>WHEN
STACK FRAMES ARE USEFUL</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">That's not to say that
stack frames aren't useful in assembler. Stack frames are not only
useful but mandatory when assembler subroutines are called from
high-level language code, since the stack frame approach is the sole
parameter-passing mechanism for most high-level language
implementations.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Assembler subroutines
for use with high-level languages are most useful; together,
assembler subroutines and high-level languages provide relatively
good performance and fast development time. The <i>best</i>
code is
written in assembler, but the best code within a reasonable time
frame is often written in a high-level language/assembler hybrid. Then,
too, high-level languages are generally better than assembler
for managing the complexities of very large applications.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In
short, stack frames
are generally useful in assembler when assembler is interfaced to a
high-level language. High-level language interfacing and stack frame
organization varies from one language to another, however, so I'm not
going to cover stack frames in detail, although I will offer a few
tips about using stack frames in the next section. Before I do that,
I'd like to point out an excellent way to mix assembler with
high-level language code: in-line assembler. Many compilers offer
the option of embedding assembler code directly in high-level
language code; in many cases, high-level language and assembler
variables and parameters can even be shared. For example, here's a
Turbo C subroutine to set the video mode:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>void
SetVideoMode(unsigned char ModeNumber) {</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> asm mov ah,0</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> asm mov al,byte
ptr [ModeNumber]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> asm int 10h</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>}</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">What makes in-line
assembler so terrific is that it lets the compiler handle all the
messy details of stack frames while freeing you to use assembler. In
the above example, we didn't have to worry about defining and
accessing the stack frame; Turbo C handled all that for us, saving
and setting up BP and substituting the appropriate BP+<i>disp</i>
value for <b>ModeNumber</b>. In-line assembler is harder
to use for
large tasks than is pure assembler, but in most cases where the power
of assembler is needed in a high-level language, in-line assembler is
a very good compromise.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> One
warning: many
compilers turn off some or all code optimization in subroutines that
contain in-line assembler. For that reason, it's often a good idea
<i>not</i> to mix high-level language and in-line assembler
statements when performance matters. Write your time-critical code
either entirely in in-line assembler or entirely in pure assembler;
don't let the compiler insert code of uncertain quality when every
cycle counts.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Still and all, when
you need to create the fastest or tightest code, try to avoid stack
frames except when you must interface your assembler code to a
high-level language. When you must use stack frames, bear in mind
that assembler is infinitely flexible; there are more ways to handle
stack frames than are dreamt of in high-level languages. In Chapter
16 we'll see an unusual but remarkably effective way to handle stack
frames in a Pascal-callable assembler subroutine.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_TIPS_ON_STACK"></a><a class="western" href="#T0707"><font size="4"><b>TIPS
ON STACK FRAMES</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Before we go on to
<b>xlat</b>, I'm going to skim over a few items that you
may find
useful should you need to use stack frames in assembler code.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">MASM provides the
<b>struc</b> directive for defining data structures. Such
data
structures can be used to access stack frames, as in:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>Parms struc</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> dw ? ;pushed
BP</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> dw ? ;return
address</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>X dw ? ;X
coordinate parameter</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>Y dw ? ;Y
coordinate parameter</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>Parms end</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> :</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>DrawXY proc near</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> push bp ;save
caller's stack frame pointer</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov bp,sp ;point
to stack frame</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov cx,[bp+X] ;get
X coordinate</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov dx,[bp+Y] ;get
Y coordinate</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> :</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> pop bp</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ret</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>DrawXY endp</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">MASM
structures have a
serious drawback when used with stack frames, however: they don't
allow for negative displacements from BP, which are generally used to
access local variables stored on the stack. While it is possible to
access local storage by accessing all variables in the stack frames
at positive offsets from BP, as in:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>Parms struc</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>Temp dw ? ;temporary
storage</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>OldBP
dw ? ;pushed BP</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> dw ? ;return
address</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>X dw ? ;X
coordinate parameter</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>Y dw ? ;Y
coordinate parameter</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>Parms end</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> :</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>DrawXY proc near</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> push bp ;save
caller's stack frame pointer</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> sub sp,OldBP ;make
room for temp storage</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov bp,sp ;point
to stack frame</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov cx,[bp+X] ;get
X coordinate</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov dx,[bp+Y] ;get
Y coordinate</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov [bp+Temp],dx
;set aside Y coordinate</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> :</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> add sp,OldBP ;dump
temp storage space</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> pop bp</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ret</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>DrawXY endp</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">this
approach has two
disadvantages. First, it prevents us from dumping temporary storage
with <b>mov sp,bp</b>, requiring instead that we use the
less
efficient <b>add sp,OldBP</b>. Second, and more important,
it makes
it more likely that parameters will be accessed with a 2-byte
displacement.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Why? Remember that a
1-byte displacement can address memory in the range -128 to +127
bytes away from BP. If our entire stack frame is addressed at
positive offsets from BP, then we've lost the use of a full one-half
of the addresses that we can access with 1-byte displacements. </font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Now, we <i>can</i> use
negative stack frame offsets in assembler; it's just a bit more
trouble than we'd like. There are many possible solutions, ranging
from a variety of ways to use equated symbols for stack frame
variables, as in:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>Temp equ -2 ;temporary
storage</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>X equ 4 ;X
coordinate parameter</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>Y equ 6 ;Y
coordinate parameter</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">and:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>Temp equ -2 ;temporary
storage</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>X equ 4 ;X
coordinate parameter</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>Y equ X+2 ;Y
coordinate parameter</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">up
to ways to get the
assembler to adjust structure offsets for us. See my "On
Graphics" column in the July 1987 issue of <i>Programmer's
Journal</i> (issue 5.4) for an elegant solution, provided by John
Navas. (Incidentally, TASM provides special directives &#8212; <b>arg</b>
and <b>local</b> &#8212; that handle many of the complications
of
stack frame addressing and allow negative offsets.)</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">While we're discussing
stack frame displacements, allow me to emphasize that you should
strive to use 1-byte displacements into stack frames as much as
possible. If you have so many parameters or local variables that
2-byte displacements must be used, make an effort to put the least
frequently used variables at those larger displacements. Alternatively,
you may want to put large data elements such as arrays
and structures in the stack frame areas that are addressed with
2-byte displacements, since such data elements are often accessed by
way of pointer registers such as BX and SI, rather than directly via
<b>bp+</b><i><b>disp</b></i>
addressing. Finally, you should avoid
forward references to structures; if you refer to elements of a
structure before the structure itself is defined in the code, you'll
always get 2-byte displacements, as we'll see in Chapter 14.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Whenever you're
uncertain whether 1-or 2-byte displacements are being used, simply
generate a listing file, or look at your code with a debugger.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> By
the way, it's worth
examining the size of your stack frame displacements even in
high-level languages. If you can figure out the order in which your
compiler organizes data in a stack frame, you can often speed up and
shrink your code simply by reorganizing your local variable
declarations so that arrays and structures are at 2-byte offsets,
allowing most variables to be addressed with 1-byte offsets.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_STACK_FRAMES_ARE"></a><a class="western" href="#T0707"><font size="4"><b>STACK
FRAMES ARE OFTEN IN DS</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">While it's not always
the case, often enough the stack segment pointed to by SS and the
default data segment pointed to by DS are one and the same. This is
true in most high-level language memory models, and is standard for
COM programs.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> If
DS and SS are the
same, the implication is clear: <i>all</i> <i>mod-reg-rm</i>
addressing modes can be used to point to stack frames. That's a real
advantage if you need to scan stack frame arrays and the like,
because SI or DI can be loaded with the array start address and used
to address the array without the need for segment override prefixes.
Similarly, BX could be set to point to a stack frame structure, which
could then be accessed by way of <b>bx+</b><i><b>disp</b></i>
addressing without a segment override. In short, be sure to take
advantage of the extra stack frame addressing power that you have at
your disposal when SS equals DS.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_USE_BP_AS"></a><a class="western" href="#T0707"><font size="4"><b>USE
BP AS A NORMAL REGISTER IF YOU MUST</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">When stack frame
addressing is in use, BP is normally dedicated to addressing the
current stack frame. That doesn't mean you can't use BP as a normal
register in a tight loop, though, and use it as a normal register you
should; registers are too scarce to let even one go to waste when
performance matters. Just push BP, use it however you wish in the
loop, then pop it when you're done, as in:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> push bp ;preserve
stack frame pointer</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov bp,LOOP_COUNT ;get
# of times to repeat loop</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>LoopTop:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> :</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> dec bp ;count
off loops</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> loop LoopTop</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> pop bp ;restore
stack frame pointer</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">Of
course, the stack
frame can't be accessed while BP is otherwise occupied, but you don't
want to be accessing memory inside a tight loop anyway if you can
help it.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Using BP as a normal
register in a tight loop can make the difference between a
register-only loop and one that accesses memory operands, and that
can translate into quite a performance improvement. Also, don't
forget that BP can be used in <i>mod-reg-rm</i> addressing
even when
stack frames aren't involved, so BP can come in handy as a
memory-addressing register when BX, SI, and DI are otherwise engaged.
In that usage, however, bear in mind that there is no BP-only memory
addressing mode; either a 1-or 2-byte displacement or an index
register (SI or DI) or both is always involved.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_THE_MANY_WAYS"></a><a class="western" href="#T0707"><font size="4"><b>THE
MANY WAYS OF SPECIFYING </b></font><font size="4"><i><b>mod-reg-rm</b></i></font><font size="4"><b>
ADDRESSING</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">There are, it seems,
more ways of specifying an operand addressed with <i>mod-reg-rm</i>
addressing than you can shake a stick at. For example,
<b>[bp+MemVar+si]</b>, <b>MemVar[bp+si]</b>, <b>MemVar[si][bp]</b>,
and <b>[bp][MemVar+si]</b> are all equivalent. Now stack
frame
addressing introduces us to a new form, involving the dot operator: <b>[bp.MemVar+si]</b>.
Or [<b>bp.MemVar.si].</b> What's the story
with all these <i>mod-reg-rm</i> forms?</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">It's actually fairly
simple. The dot operator does the same thing as the plus operator: it
adds two memory addressing components together. Any
memory-addressing component enclosed in brackets is also added into
the memory address. The order of the operands doesn't matter, since
everything resolves to a <i>mod-reg-rm</i> byte in the
end; <b>mov
al,[bx+si]</b> assembles to exactly the same instruction as <b>mov
al,[si+bx]</b>. All the constant values and symbols (variable
names
and equated values) in an address are added together into a single
displacement, and that's used with whatever memory addressing
registers are present (from among BX, BP, SI, and DI) to form a
<i>mod-reg-rm</i> address. (Of course, only valid
combinations &#8212;
the combinations listed in Figure 7.6 &#8212; will assemble.) Lastly, if
memory addressing registers are present, they must be
inside square brackets, but that's optional for constant values and
symbols.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">There are a few other
rules about constructing memory addressing operands, but I avoid
those complications by making it a practice to use a single simple
<i>mod-reg-rm</i> memory address notation. As I said at the
start of
this chapter, I prefer to put square brackets around all memory
operands, and I also prefer to use only the plus operator. There are
three reasons for this: it's not complicated, it reminds me that I'm
programming in assembler, not in a high-level language where
complications such as array element size are automatically taken care
of, and it reminds me that I'm accessing a memory operand rather than
a register operand, thereby losing performance and gaining bytes.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> You
can use whatever
<i>mod-reg-rm</i> addressing notation you wish. I do
suggest,
however, that you choose a single notation and stick with it. Why
confuse yourself?</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_xlat"></a><a class="western" href="#T0707"><font size="4"><b>xlat</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> At
long last, we come
to the final addressing mode of the 8088. This addressing mode is
unique to the <b>xlat</b> instruction, an odd and rather
limited
instruction that can nonetheless outperform every other 8088
instruction under the proper circumstances.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
operation of <b>xlat</b>
is simple: AL is loaded from the offset addressed by the sum of BX
and AL, as shown in Figure 7. 14. DS is the default data segment,
but a segment override prefix may be used.</font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_70c40265.jpg" align="bottom" border="0" height="767" width="610"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> As
you can see, <b>xlat</b>
bears no resemblance to any of the other addressing modes. It's
certainly limited, and it always wipes out one of the two registers
it uses to address memory (AL). In fact, the first thought that
leaps to mind is: why would we <i>ever</i> want to use <b>xlat</b>?</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> If <b>xlat</b>
were
slow and large, the answer would be never. However, <b>xlat</b>
is
just 1 byte long, and, at 10 cycles, is as fast at accessing a memory
operand as any 8088 instruction. As a result, <b>xlat</b>
is
excellent for a small but often time-critical category of tasks.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <b>xlat</b>
excels
when byte values must be translated from one representation to
another. The most common example occurs when one character set must
be translated to another, as for example when the ASCII character set
used by the PC is translated to the EBCDIC character set used by IBM
mainframes. In such a case <b>xlat</b> can form the heart
of an
extremely efficient loop, along the lines of the following:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;
Converts the contents of an ASCII buffer to an EBCDIC buffer.</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;
Stops when a zero byte is encountered, but copies the zero byte.</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;
Input:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>; DS:SI
= pointer to ASCII buffer.</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;
Output: none</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;
Registers altered: AL, BX, SI, DI, ES</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov di,ds</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov es,di</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov di,si ;point
ES:DI to the ASCII buffer as well</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov bx,offset
ASCIIToEBCDICTable</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ;point
to the table containing the EBCDIC</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ;
equivalents of ASCII codes</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> cld</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>ASCIIToEBCDICLoop:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> lodsb ;get
the next ASCII character</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> xlat ;convert
it to EBCDIC</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> stosb ;put
the result back in the buffer</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> and al,al ;zero
byte is the last byte</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jnz ASCIIToEBCDICLoop</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Besides being small
and fast, <b>xlat</b> has an advantage in that byte-sized
look-up
values don't need to be converted to words before they can be used to
address memory. (Remember, <i>mod-reg-rm</i> addressing
modes allow
only word-sized registers to be used to address memory.) If we were
to implement the look-up in the last example with <i>mod-reg-rm</i>
instructions, the code would become a good deal less efficient no
matter how efficiently we set up for <i>mod-reg-rm</i>
addressing:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> sub bh,bh ;for
use in converting a byte in BL</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ;
to a word in BX</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov si,offset
ASCIIToEBCDICTable</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ;point
to the table containing the EBCDIC</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ;
equivalents of ASCII codes</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>ASCIIToEBCDICLoop:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> lodsb ;get
the next ASCII character</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov bl,al ;get
the character into BX, where</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ;
we can use it to address memory</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov al,[si+bx] ;convert
it to EBCDIC</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> stosb ;put
the result back in the buffer</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> and al,al ;zero
byte is the last byte</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jnz ASCIIToEBCDICLoop</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In
short, <b>xlat</b>
is clearly superior when a byte-sized look-up is performed, so long
as it's possible to put both the look-up value and the result in AL.
Shortly, we'll see how <b>xlat</b> can be used to good
effect in a
case where it certainly isn't the obvious choice.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_MEMORY_IS_CHEAP:"></a><a class="western" href="#T0707"><font size="4"><b>MEMORY
IS CHEAP: YOU COULD LOOK IT UP</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <b>xlat</b>,
simply
put, is a table look-up instruction. A table look-up occurs whenever
you use an index value to look up a result in an array, or table, of
data. A rough analogy might be using the number on a ballplayer's
uniform to look up his name in a program.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Look-up tables are a
superb way to improve performance. The basic premise of look-up
tables is that it's faster to precalculate results, either by letting
the assembler do the work or by calculating the results yourself and
inserting them in the source code, than it is to have the 8088
calculate them at run time. The key factor is this: the 8088 is
relatively fast at looking up data in tables and slow at performing
almost any kind of calculation. Given that, why not perform your
calculations before run time, when speed doesn't matter, and let the
8088 do what it does best at run time?</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Now, look-up tables do
have a significant disadvantage &#8212; they require extra memory. This is a
trade-off we'll see again and again in <i>The Zen of
Assembly Language</i>: cycles for bytes. If you're willing to
expend more memory, you can almost always improve the performance of
your code. One trick to generating top-notch code is knowing when
that trade-off is worth making.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Let's look at an
example that illustrates the power of look-up tables. In the
process, we'll see an unusual but effective use of <b>xlat</b>;
we'll
also see that there are many ways to approach any programming task,
and we'll get a first-hand look at the cycles-for-bytes tradeoff that
arises so often in assembler programming.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_FIVE_WAYS_TO"></a><a class="western" href="#T0707"><font size="4"><b>FIVE
WAYS TO DOUBLE BITS</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
example we're
about to study is based on the article "Optimizing for Speed,"
by Michael Hoyt, which appeared in <i>Programmer's Journal</i>
in
March, 1986 (issue 4.2). This is the article I referred to back in
Chapter 2 as an example of a programmer operating without full
knowledge about code performance on the PC. By no means am I
denigrating Mr. Hoyt; his article simply happens to be an excellent
starting point for examining both look-up tables and the hazards of
the prefetch queue cycle-eater.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
goal of Mr. Hoyt's
article was to expand a byte to a word by doubling each bit, for the
purpose of converting display memory pixels to printer pixels in
order to perform a screen dump. So, for example, the value 01h
(00000001b) would become 0003h (0000000000000011b), the value 02h
(00000010b) would become 000Ch (0000000000001100b), and the value 5Ah
(01011010b) would become 33CCh (0011001111001100b). Now, in general
this isn't a particularly worthy pursuit, given that the speed of the
printer is likely to be the limiting factor; however, speed could
matter if the screen dump code is used by a background print spooler.
At any rate, bit-doubling is an ideal application for look-up tables,
so we're going to spend some time studying it.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Mr.
Hoyt started his
article with code that doubled each bit by testing that bit and
branching accordingly to set the appropriate doubled bit values. He
then optimized the code by eliminating branches entirely, instead
using fast shift and rotate instructions, in a manner similar to that
used by <a name="L714R"></a><a class="western" href="#L714">Listing
7-14</a>.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Eliminating branches
isn't a bad idea in general, since, as we'll see in Chapter 12,
branching is very slow. However, as we've already seen in Chapter 4,
instruction fetching is also very slow...and the code in <a class="western" href="#L714">Listing
7-14</a> requires a <i>lot</i> of instruction
fetching. 70
instruction bytes must be fetched for each byte that's doubled,
meaning that this code can't possibly run in less than about 280 (70
times 4) cycles per byte doubled, even though its official Execution
Unit execution time is scarcely 70 cycles.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
Zen timer confirms
our calculations, reporting that <a class="western" href="#L714">Listing
7-14</a> runs in 6.34 ms, or about 300 cycles per byte doubled.
(The
excess cycles are the result of DRAM refresh.) As a result of this
intensive instruction fetching, Mr. Hoyt's optimized shift-and-rotate
code actually ran slower than his original test-and-jump code, as
discussed in my article "More Optimizing for Speed,"
<i>Programmer's Journal</i>, <i>July, 1986 (issue
4.4).</i></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> So
far, all we've done
is confirm that the prefetch queue cycle-eater can cause code to run
much more slowly than the official execution times would indicate. This
is of course not news to us; in fact, I haven't even bothered to
show the test-and-jump code and contrast it with the shift-and-rotate
code, since that would just restate what we already know. What's
interesting is not that Mr. Hoyt's optimization didn't make his code
faster, but rather that a look-up table approach can make the code
<i>much</i> faster. So let's plunge headlong into look-up
tables,
and see what we can do with this code.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_TABLE_LOOK-UPS_TO"></a><a class="western" href="#T0707"><font size="4"><b>TABLE
LOOK-UPS TO THE RESCUE</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Bit-doubling is
beautifully suited to an approach based on look-up tables. There are
only 256 possible input values, all byte-sized, and only 256 possible
output values, all word-sized. Better yet, each input value maps to
one and only one output value, and all the input values are
consecutive, covering the range 0 to 255, inclusive.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Given those
parameters, it should be clear that we can create a table of 256
words, one corresponding to each possible byte to be bit-doubled. We
can then use each byte to be doubled as a look-up index into that
table, retrieving the appropriate bit-doubled word with just a few
instructions. Granted, 512 bytes would be needed to store the table,
but the 50 or so instruction bytes we would save would partially
compensate for the size of the table. Besides, surely the
performance improvement from eliminating all those shifts, rotates,
and especially instruction fetches would justify the extra
bytes...wouldn't it?</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> It
would indeed. <a name="L715R"></a><a class="western" href="#L715">Listing
7-15</a>, which uses the
table look-up approach I've just described, runs in just 1.32 ms &#8212;
<i>more than four times as fast as </i><a class="western" href="#L714">Listing
7-14</a><i>!</i> When performance matters, trading
less than 500
bytes for a more than four-fold speed increase is quite a deal. <a class="western" href="#L715">Listing 7-15</a>
is so fast that it's
faster than <a class="western" href="#L714">Listing
7-14</a> would be
even if there were no prefetch queue cycle-eater; in other words, the
official execution time of <a class="western" href="#L715">Listing
7-15</a> is faster than that of <a class="western" href="#L714">Listing
7-14</a>. Factor in instruction fetch time, though, and you have
a
fine example of the massive performance improvement that look-up
tables can offer.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
key to <a class="western" href="#L715">Listing
7-15</a>, of course, is that I precalculated all the doubled bit
masks when I wrote the program. As a result, the code doesn't have
to perform any calculation more complex than looking up a
precalculated bit mask at run time. In a little while, we'll see how
MASM can often perform look-up table calculations at assembly time,
relieving us of the drudgery of precalculating results.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_THERE_ARE_MANY"></a><a class="western" href="#T0707"><font size="4"><b>THERE
ARE MANY WAYS TO APPROACH ANY TASK</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Never assume that
there's only one way, or even one "best" way, to approach
any programming task. There are always many ways to solve any given
programming problem in assembler, and different solutions may well be
superior in different situations.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Suppose, for example,
that we're writing bit-doubling code in a situation where size is
more important than speed, perhaps because we're writing a
memory-resident program, or perhaps because the code will be used in
a very large program that's squeezed for space. We'd like to improve
our speed, if we can &#8212; but not at the expense of a single byte. In this
case, <a class="western" href="#L714">Listing 7-14</a>
is
preferable to <a class="western" href="#L715">Listing
7-15</a> &#8212;
but is <a class="western" href="#L714">Listing 7-14</a>
the best we
can do?</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Not
by a long shot.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">What we'd like to do
is somehow shrink <a class="western" href="#L715">Listing
7-15</a> a
good deal. Well, <a class="western" href="#L715">Listing
7-15</a> is
so large because it has a 512-byte table that's used to look up the
bit-doubled words that can be selected by the 256 values that can be
stored in a byte. We can shrink the table a great deal simply by
converting it to a 16-byte table that's used to look up the
bit-doubled <i>bytes</i> that can be selected by the 16
values that
can be stored in a <i>nibble</i> (4 bits), and performing
two
look-ups into that table, one for each half of the byte being
doubled.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <a name="L716R"></a><a class="western" href="#L716">Listing
7-16</a> shows this double table look-up solution in action. This
listing requires only 23 bytes of code for each byte doubled, and
even if you add the 16-byte size of the table in, the total size of
39 bytes is still considerably smaller than the 70 bytes needed to
bit-double each byte in <a class="western" href="#L714">Listing
7-14</a>.
What's more, the table only needs to appear once in any program, so
practically speaking <a class="western" href="#L716">Listing
7-16</a>
is <i>much</i> more compact than <a class="western" href="#L714">Listing
7-14</a>.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <a class="western" href="#L716">Listing
7-16</a> also is more than twice as fast as <a class="western" href="#L714">Listing
7-14</a>, clocking in at 2.52 ms. Of course, <a class="western" href="#L716">Listing
7-16</a> is nearly twice as <i>slow</i> as <a class="western" href="#L715">Listing
7-15</a> &#8212; but then, it's much more compact.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">There's that choice
again: cycles or bytes.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In
truth, there are
both cycles and bytes yet to be saved in <a class="western" href="#L716">Listing
7-16</a>. If we apply our knowledge of <i>mod-reg-rm</i>
addressing
to <a class="western" href="#L716">Listing 7-16</a>,
we'll realize
that it's a waste to use base+displacement addressing with the same
displacement twice in a row; we can save a byte and a few cycles by
loading SI with the displacement and using base+index addressing
instead. <a name="L717R"></a><a class="western" href="#L717">Listing
7-17</a>, which
incorporates this optimization, runs in 2.44 ms, a bit faster than
<a class="western" href="#L716">Listing 7-16</a>.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">There's yet another
optimization to be made, and this one brings us full circle, back to
the start of our discussion of look-up tables. Think about it: <a class="western" href="#L717">Listing 7-17</a>
basically does
nothing more than use two nibble values as look-up indices into a
table of byte values. Sound familiar? It should &#8212; that's an
awful lot like a description of <b>xlat</b>. (<b>xlat</b>
can handle
byte look-up values, but this task is just a subset of that.)</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <a name="L718R"></a><a class="western" href="#L718">Listing
7-18</a> shows an <b>xlat</b>-based version of our
bit-doubling code. This code runs in just 1.94 ms, still about 50%
slower than the
single look-up approach, but a good deal faster than anything else
we've seen. Better yet, this approach takes just 16 instruction
bytes per bit-doubled byte (32 if you count the table) &#8212; which
makes this by far the shortest approach we've seen. Comparing <a class="western" href="#L718">Listing
7-18</a> to <a class="western" href="#L714">Listing
7-14</a> reveals
that we've improved the code to an astonishing degree: <a class="western" href="#L718">Listing
7-18</a> runs more than three times as fast as <a class="western" href="#L714">Listing
7-14</a>, and yet it requires less than one-fourth as many
instruction bytes per bit-doubled byte.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">There are many lessons
here. First, <b>xlat</b> is extremely efficient at
performing the
limited category of tasks it can manage; when you need to use a byte
index into a byte-sized look-up table, <b>xlat</b> is
often your best
bet. Second, the official execution times aren't a particularly good
guide to writing high-performance code. (Of course, you already knew
<i>that</i>!) Third, there is no such thing as the best
code,
because the fastest code is rarely the smallest code, and vice-versa.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Finally, there are an
awful lot of solutions to any given programming problem on the 8088.
Don't fall into the trap of thinking that the obvious solution is the
best one. In fact, we'll see yet another solution to the
bit-doubling problem in Chapter 9; this solution, based on the <b>sar</b>
instruction, isn't like <i>any</i> of the solutions we've
seen so
far.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">We'll see look-up
tables again in Chapter 14, in the form of jump tables.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h2 class="western"><font color="#110d06"><font color="#0b0703"><a name="_INITIALIZING_MEMORY"></a><a class="western" href="#T0708"><font style="font-size: 16pt;" size="4"><b>7.8
INITIALIZING MEMORY</b></font></a></font></font></h2>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Assembler offers
excellent data-definition capabilities, and look-up tables can
benefit greatly from those capabilities. No high-level language even
comes close to assembler so far as flexible definition of data is
concerned, both in terms of arbitrarily mixing different data types
and in terms of letting the assembler perform calculations at
assembly time; given that, why not let the assembler generate your
look-up tables for you?</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> For
example, consider
the multiplication of a word-sized value by 80, a task often
performed in order to calculate row offsets in display memory. <a name="L719R"></a><a class="western" href="#L719">Listing 7-19</a>
does this with the
compact but slow <b>mul</b> instruction, at a pace of
30.17 us per
multiply. <a name="L720R"></a><a class="western" href="#L720">Listing
7-20</a> improves
to 15.08 us per multiply by using a faster shift-and-add approach.
However, the performance of the shift-and-add approach is limited by
the prefetch queue cycle-eater; <a name="L721R"></a><a class="western" href="#L721">Listing
7-21</a>, which looks the multiplication results up in a table,
is
considerably faster yet, at 12.26 us per multiply. Once again, the
look-up approach is faster even than tight register-only code, but
that's not what's most interesting here.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">What's really
interesting about <a class="western" href="#L721">Listing
7-21</a> is
that it's the assembler, not the programmer, that generates the
look-up table of multiples of 80. Back in <a class="western" href="#L715">Listing
7-15</a>, I had to calculate and type each entry in the look-up
table
myself. In <a class="western" href="#L721">Listing
7-21</a>,
however, I've used the <b>rept</b> and <b>=</b>
directives to
instruct the assembler to build the table automatically. That's even
more convenient than you might think; not only does it save the
tedium of a lot of typing, but it avoids the sort of typos that
inevitably creep in whenever a lot of typing is involved.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Another area in which
assembler's data-definition capabilities lend themselves to good code
is in constructing and using mini-interpreters, which are nothing
less than task-specific mini-languages that are easily created and
used in assembler. We'll discuss mini-interpreters at length in
Volume II of <i>The Zen of Assembly Language</i>.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> You
can also take
advantage of assembler's data definition capabilities by assigning
initial values to variables when they're defined, rather than
initializing them with code. In other words:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>MemVar dw 0</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">takes
no time at all at
run time; <b>MemVar</b> simply <i>is</i> 0
when the program starts. By contrast:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>MemVar dw ?</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> :</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov [MemVar],0</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">takes
20 cycles at run
time, and adds 6 bytes to the program as well.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In
general, the rule
is: <i>calculate results and initialize data at or before
assembly
time if you can, rather than at run time</i>. What makes look-up
tables so powerful is simply that they provide an easy way to shift
the overhead of calculations from run time to assembly time.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h2 class="western"><font color="#110d06"><font color="#0b0703"><a name="_A_BRIEF_NOTE"></a><a class="western" href="#T0709"><font style="font-size: 16pt;" size="4"><b>7.9
A BRIEF NOTE ON I/O ADDRESSING</b></font></a></font></font></h2>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> You
may wonder why
we've spent so much time on memory addressing but none on
input/output (I/O) addressing. The answer is simple: I/O addressing
is so limited that there's not much to know about it. There aren't
any profound performance implications or optimizations associated
with I/O addressing simply because there are only two ways to perform
I/O.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <b>out</b>,
which
writes data to a port, always uses the accumulator for the source
operand: AL when writing to byte-sized ports, AX when writing to
word-sized ports. The destination port address may be specified
either by a constant value in the range 0-255 (basically direct port
addressing with a byte-sized displacement) or by the value in DX
(basically indirect port addressing). Here are the two possible ways
to send the value 5Ah to port 99: </font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov al,5ah</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> out 99,al</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov dx,99</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> out dx,al</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Likewise, <b>in</b>,
which reads data from a port, always uses AL or AX for the
destination operand, and may use either a constant port value between
0 and 255 or the port pointed to by DX as the source operand. Here
are the two ways to read a value from port 255 into AL:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> in al,0ffh</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov dx,0ffh</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> in al,dx</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> And
that just about
does it for I/O addressing. As you can see, there's not much
flexibility or opportunity for Zen here. All I/O data must pass
through the accumulator, and if you want to access a port address
greater than 255, you <i>must</i> address the port with
DX. What's
more, there are no substitutes for the I/O instructions; when you
need to perform I/O, what we've just seen is all there is.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">While the I/O
instructions are a bit awkward, at least they aren't particularly
slow, at 8 (DX-indirect) or 10 (direct-addressed) cycles apiece, with
no EA calculation time. Neither are the I/O instructions
particularly lengthy; in fact, <b>in</b> and <b>out</b>
are
considerably more compact than the memory-addressing instructions,
which shouldn't be surprising given that the I/O instructions provide
such limited functionality. The DX-indirect forms of both <b>in</b>
and <b>out</b> are just 1 byte long, while the
direct-addressed forms
are 2 bytes long.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Each I/O access takes
over the bus and thereby briefly prevents prefetching, much as each
memory access does. However, the ratio of total bus accesses
(including instruction byte fetches) to execution time for <b>in</b>
and <b>out</b> isn't bad. In fact, byte-sized DX-indirect
I/O
instructions, which are only 1 byte long and perform only one I/O
access, should actually run in close to the advertised 8 cycles per
out.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Among our limited
repertoire of I/O instructions, which is best? It doesn't make all
<i>that</i> much difference, but given the choice between
DX-indirect
I/O instructions and direct-addressed I/O instructions for heavy I/O,
choose DX-indirect, which is slightly faster and more compact. For
one-shot I/O to ports in the 0-255 range, use direct-addressed I/O
instructions, since it takes three bytes and 4 cycles to set up DX
for a DX-indirect I/O instruction.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> On
balance, though,
don't worry about I/O &#8212; just do it when you must. Rare indeed
is the program that spends an appreciable amount of its time
performing I/O &#8212; and given the paucity of I/O addressing modes,
there's not much to be done about performance in such cases anyway.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_VIDEO_PROGRAMMING_AND"></a><a class="western" href="#T0709"><font size="4"><b>VIDEO
PROGRAMMING AND I/O</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> I'd
like to make one
final point about I/O addressing. This section won't mean much to
you if you haven't worked with video programming, and I'm not going
to explain it further now; we'll return to the topic when we discuss
video programming in Volume II. For those of you who are involved
with video programming, however, here goes.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Word-sized <b>out</b>
instructions &#8212; <b>out dx,ax</b> &#8212; unquestionably provide
the fastest way to set the indexed video registers of the CGA, EGA,
and VGA. Just put the index of the video register you're setting in
AL and the value you're setting the register to in AH, and <b>out
dx,ax</b> sets both the index and the register in a single
instruction. Using byte-sized <b>out</b> instructions,
we'd have to
do all this to achieve the same results:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> out dx,al</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> inc dx</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> xchg ah,al</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> out dx,al</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> dec dx</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> xchg ah,al</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">(Sometimes
you can
leave off the final <b>dec</b> and <b>xchg</b>,
but the word-sized
approach is still much more efficient.)</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">However, there's a
potential pitfall to the use of word-sized <b>out</b>
instructions to
set indexed video registers. The 8088 can't actually perform
word-sized I/O accesses, since the bus is only 8 bits wide.
Consequently, the 8088 breaks 16-bit I/O accesses into two 8-bit
accesses, one sending AL to the addressed port, and a second one
sending AH to the addressed port plus one. (If you think about it,
you'll realize that this is exactly how the 8088 handles word-sized
memory accesses too.)</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> All
well and good. Unfortunately, on computers built around the 8086,
80286, and the
like, the processors do not automatically break up word-sized I/O
accesses, since they're fully capable of outputting 16 bits at once.
Consequently, when word-sized accesses are made to 8-bit adapters
like the EGA by code running on such computers, it's the bus, not the
processor, that breaks up those accesses. Generally, that works
perfectly well &#8212; but on certain PC &#8212; compatible
computers, the bus outputs the byte in AH to the addressed port plus
one first, and <i>then</i> sends the byte in AL to the
addressed
port. The correct values go to the correct ports, but here sequence
is critical; <b>out dx,ax</b> to an indexed video register
relies on
the index in AL being output before the data in AH, and that simply
doesn't happen. As a result, the data goes to the wrong video
register, and the video programming works incorrectly &#8212;
sometimes disastrously so.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> You
may protest that
any computer that gets the sequencing of word-sized <b>out</b>
instructions wrong isn't truly a PC-compatible, and I suppose that's
so. Nonetheless, if a computer runs <i>everything</i>
except your
code that uses word-sized <b>out</b> instructions, you're
going to
have a tough time selling that explanation. Consequently, I
recommend using byte-sized <b>out</b> instructions to
indexed video
registers whenever you can't be sure of the particular PC-compatible
models on which your code will run.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_AVOID_MEMORY!"></a><a class="western" href="#T0709"><font size="4"><b>AVOID
MEMORY!</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">We've come to the end
of our discussion of memory addressing. Memory addressing on the
8088 is no trivial matter, is it? Now that we've familiarized
ourselves with the registers and memory addressing capabilities of
the 8088, we'll start exploring the instruction set, a journey that
will occupy most of the rest of this volume.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Before we leave the
realm of memory addressing, let me repeat: <i>avoid memory</i>.
Use
the registers to the hilt; register-only instructions are shorter and
faster. If you must access memory, try not to use <i>mod-reg-rm</i>
addressing; the special memory-accessing instructions, such as the
string instructions and <b>xlat</b>, are generally shorter
and
faster. When you do use <i>mod-reg-rm</i> addressing, try
not to use
displacements, especially 2-byte displacements.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Last but not least,
choose your spots. Don't waste time optimizing non-critical code;
focus on loops and other chunks of code in which every cycle counts.
Assembler programming is not some sort of game where the object is to
save cycles and bytes blindly. Rather, the goal is a dual one: to
produce whole programs that perform well <i>and to produce those
programs as quickly as possible</i>. The key to doing that is
knowing how to optimize code, and then doing so in time-critical code
&#8212; and <i>only</i> in time-critical code.</font></font></p>
