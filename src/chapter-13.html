<h1 class="western" style="page-break-before: always;"><font color="#110d06"><font color="#0b0703"><a name="_Chapter_13:_"></a><a class="western" href="#TC13"><font size="5"><b>Chapter
13: Not-Branching</b></font></a></font></font></h1>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<table style="width: 635px; height: 307px;" border="1" bordercolor="#bfbfbf" cellpadding="4" cellspacing="0" frame="void" rules="groups">
<col width="658"> <tbody>
<tr>
<td bgcolor="#bfbfbf" width="658">
<p class="western"><b>13.1 </b><a class="western" href="#_THINK_FUNCTIONALLY">THINK
FUNCTIONALLY</a></p>
</td>
</tr>
</tbody> <tbody>
<tr>
<td bgcolor="#bfbfbf" width="658">
<p class="western"><b>13.2 </b><a class="western" href="#_rep:__LOOPING">rep: LOOPING
WITHOUT BRANCHING</a></p>
</td>
</tr>
</tbody> <tbody>
<tr>
<td bgcolor="#bfbfbf" width="658">
<p class="western"><b>13.3 </b><a class="western" href="#_LOOK-UP_TABLES:_">LOOK-UP
TABLES: CALCULATING WITHOUT BRANCHING</a></p>
</td>
</tr>
</tbody> <tbody>
<tr>
<td bgcolor="#bfbfbf" width="658">
<p class="western"><b>13.4 </b><a class="western" href="#_TAKE_THE_BRANCH">TAKE THE
BRANCH LESS TRAVELLED BY</a></p>
</td>
</tr>
<tr>
<td bgcolor="#bfbfbf" width="658">
<p class="western"><b>13.5 </b><a class="western" href="#_YES,_VIRGINIA,_THERE">YES,
VIRGINIA, THERE IS A FASTER 32-BIT NEGATE!</a></p>
</td>
</tr>
<tr>
<td bgcolor="#bfbfbf" width="658">
<p class="western"><b>13.6 </b><a class="western" href="#_ARRANGE_YOUR_CODE">ARRANGE
YOUR CODE TO ELIMINATE BRANCHES</a></p>
</td>
</tr>
<tr>
<td bgcolor="#bfbfbf" width="658">
<p class="western"><b>13.7 </b><a class="western" href="#_loop_MAY_NOT">loop MAY NOT BE
BAD, BUT LORD KNOWS IT'S NOT GOOD: IN-LINE CODE</a></p>
</td>
</tr>
<tr>
<td bgcolor="#bfbfbf" width="658">
<p class="western"><b>13.8 </b><a class="western" href="#C138">A NOTE ON SELF-MODIFYING
CODE</a></p>
</td>
</tr>
</tbody>
</table>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Now
we know <i>why</i>
we don't want to branch, but we haven't a clue as to <i>how</i>
to
manage that trick. After all, decisions still have to be made, loops
still have to be iterated through, and so on. Branching is the way
we've always performed those tasks, and it's certainly not obvious
what the alternatives are, or, for that matter, that alternatives
even exist.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">While alternatives to
branching do indeed exist, they are anything but obvious. Programming
without branches &#8212; <i>not-branching</i>, in
Zen-speak &#8212; is without question one of the stranger arts you
must master in your growth as a Zen programmer.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Strange &#8212; but
most rewarding. So let's get to it!</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h2 class="western"><font color="#110d06"><font color="#0b0703"><a name="_THINK_FUNCTIONALLY"></a><a class="western" href="#T1301"><font style="font-size: 16pt;" size="4"><b>13.1
THINK FUNCTIONALLY</b></font></a></font></font></h2>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
key to
not-branching lies in understanding each programming task strictly in
terms of what that task needs to do, not in terms of how the task
will ultimately be implemented. Put another way, you should not
consider how you might implement a task, even in a general way, until
you have a clear picture of exactly what results the implementation
must produce.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Once you've separated
the objective from the implementation, you're free to bring all the
capabilities of the 8088 &#8212; in their limitless combinations and
permutations &#8212; to bear in designing the implementation, rather
than the limited subset of programming techniques you've grown
accustomed to using. This is one of the areas in which assembler
programmers have a vast advantage over compilers, which can use only
the small and inflexible set of techniques their designers built in.
Compilers operate by translating human-oriented languages to machine
language along a few fixed paths; there's no way such a rigid
code-generation mechanism can properly address the boundless
possibilities of the 8088.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Of
course, separating
the objective and the implementation is more easily said than done,
especially given an instruction set in which almost every instruction
seems to have been designed for a specific purpose. For example,
it's hard not to think of the <b>loop</b> instruction when
you need
to exclusive-or together all the bytes in a block of memory 64 bytes
long, and do so as quickly as possible. (Such a cumulative
exclusive-or might be used as a check against corrupted data in a
block of data about to be transmitted or stored. The speed at which
the cumulative exclusive-or could be generated might well determine
the maximum error-checked transfer rate supported by the program.)</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In
this case, as in
many others, the objective &#8212; a fast cumulative exclusive-or &#8212;
and the implementation &#8212; 64 loops by way of the <b>loop</b>
instruction, with each loop exclusive-oring 1 byte into the
cumulative result &#8212; are inseparable to the experienced non-Zen
programmer.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Why? Consider the
solution shown in <a name="L1301R"></a><a class="western" href="#L1301">Listing
13-1</a><font color="#000099">.</font> <a class="western" href="#L1301">Listing 13-1</a><font color="#000099">
</font>is obviously well-matched to the task of generating the
cumulative exclusive-or for a block of 64 bytes. In fact, it's so
well-matched that few programmers would even contemplate
alternatives. The code in <a class="western" href="#L1301">Listing
13-1</a><font color="#000099"> </font>works,
it's easy to write, and
it runs in just 503 us. Surely that's just about as fast as the 8088
can manage to perform this task &#8212; after all, the loop involves
just three instructions: one <b>lodsb</b> (string
instructions are
the fastest around), one register-register <b>xor</b>
(register-register instructions are short and fast), and one <b>loop</b>
(the 8088's special, fast looping instruction). Who would ever think
that performance could be nearly doubled by literally duplicating the
code inside the loop 64 times and executing that code sequentially &#8212;
thereby eliminating branching <i>entirely</i>?</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Only a Zen programmer
would even consider the possibility, for not-branching simply has no
counterpart in non-Zen programming. Not-branching just plain feels
<i>wrong</i> at first to any programmer raised on
high-level
languages. Not-branching goes against the grain and intent of both
the 8088 instruction set and virtually all computer-science teachings
and high-level languages. That's only to be expected; language
designers and computer-science teachers are concerned with the form
of programs, for they're most interested in making programming more
amenable to people &#8212; that is, matching implementations to the
way people think.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> By
contrast, Zen
programmers are concerned with the functionality of programs. Zen
programmers focus on performance and/or program size, and are most
interested in matching implementations to the way <i>computers</i>
think. The desired application is paramount, but the true Zen comes
in producing the necessary result (the functionality) in the best
possible way given the computer's resources.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Zen
programmers
understand that the objective in generating the cumulative
exclusive-or of 64 bytes actually has nothing whatsoever to do with
looping. The objective is simply to exclusive-or together the 64
bytes in whatever way the PC can most rapidly accomplish the task,
and looping is just one of many possible means to that end. Most
programmers have seen and solved similar problems so many times,
however, that they instinctively &#8212; almost unconsciously &#8212;
select the <b>loop</b> instruction from their bag of
tricks the
moment they see the problem. To these programmers, repetitive
processing and <b>loop</b> are synonymous.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Zen
programmers have a
bigger bag of tricks, however, and a more flexible view of the world. <a class="western" href="#L1302">Listing 13-2</a><font color="#000099">
</font>shows a Zen solution to the array-sum problem. <a name="L1302R"></a><a class="western" href="#L1302">Listing
13-2</a><font color="#000099"> </font>performs
no branches at all,
thanks to the use of in-line code, which we'll discuss in detail
later in this chapter.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Functionally, there's
not much difference between <a class="western" href="#L1301">Listings
13-1</a> and <a class="western" href="#L1302">13-2</a>.
Both
listings leave the same cumulative result in AH, leave the same value
in SI, and even leave the flags set to the same values. <a class="western" href="#L1301">Listing
13-1</a><font color="#000099"> </font>leaves
CX set to zero, while
<a class="western" href="#L1302">Listing 13-2</a><font color="#000099">
</font>doesn't touch CX, but that's really a point in the favor
of
<a class="western" href="#L1302">Listing 13-2</a><font color="#000099">,</font>
and could in any case be remedied simply by placing a <b>sub
cx,cx</b>
at the start of <a class="western" href="#L1302">Listing
13-2</a><font color="#000099">
</font>if necessary.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> No,
there's not much
to choose from between the two listings...until you see them in
action. <a class="western" href="#L1302">Listing
13-2</a><font color="#000099">
</font>calculates the 64-byte cumulative exclusive-or value in
just
275 us &#8212; more than 82% faster than <a class="western" href="#L1301">Listing
13-1</a><font color="#000099">.</font> A 5%
increase might not be
worth worrying about, but we're talking about nearly <i>doubling</i>
the performance of a well-coded three-instruction loop! Clearly,
there's something to this business of Zen programming.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> You
may object that
<a class="western" href="#L1302">Listing 13-2</a><font color="#000099">
</font>is many bytes longer than <a class="western" href="#L1301">Listing
13-1</a><font color="#000099">,</font> and
indeed it is: 184 bytes,
to be exact. If you need speed, though, a couple of hundred bytes is
a small price to pay for nearly doubling performance &#8212;
certainly preferable to requiring a more powerful (and expensive)
processor, such as an 80286. You may also object that <a class="western" href="#L1302">Listing
13-2</a><font color="#000099"> </font>can
only handle blocks that are
exactly 64 bytes in length, while the loop in <a class="western" href="#L1301">Listing
13-1</a><font color="#000099"> </font>can be
made to handle blocks of
any size simply by loading CX with different values. That, too, is
true...but you're missing the point.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <a class="western" href="#L1302">Listing
13-2</a><font color="#000099"> </font>is
constructed to meet a
specific goal as well as possible on the PC. If the goal was
different, then <a class="western" href="#L1302">Listing
13-2</a><font color="#000099">
</font>would be different. If blocks of different sizes were
required, then we would modify our approach accordingly, possibly by
jumping into the series of exclusive-or operations at the appropriate
place. If space was tight, perhaps we would use partial in-line code
(which we'll discuss later in this chapter), combining the
space-saving qualities of loops with the speed of in-line code. If
space was at a premium and performance was not an issue, we might
well decide that <b>loop</b> was the best solution after
all. The
point is that the Zen programmer has a wide range of approaches to
choose from, and in most cases at least one of those choices will
handily outperform any standard, one-size-fits-all solution.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In
the context of
not-branching (which is after all how we got into all this), Zen
programming means replicating the functionality of branches without
branching. That's certainly not a goal we'd want to achieve all the
time &#8212; in many cases branches really are the best (or only)
choice &#8212; but you'll be surprised at how often it's possible to
find good substitutes for branches in time-critical code.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> For
all their
reputation as number-crunching machines, computers typically spend
most of their time moving data, scanning data, and branching. In the
Chapters 10 and 11 we learned how to minimize the time spent moving
and scanning data. Now we're going to attack the other part of the
performance equation by learning how to minimize branching.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h2 class="western"><font color="#110d06"><font color="#0b0703"><a name="_rep:__LOOPING"></a><a class="western" href="#T1302"><font style="font-size: 16pt;" size="4"><b>13.2
rep: LOOPING WITHOUT BRANCHING</b></font></a></font></font></h2>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">It's a popular
misconception that <b>loop</b> is the 8088's fastest
instruction for
looping. Not so. In truth, it's <b>rep</b> that supports
far and
away the most powerful looping possible on the 8088. In Chapters 10
and 11 we saw again and again that repeated string instructions
perform repetitive tasks much, much faster than normal loops do. Not
only do repeated string instructions not empty the prefetch queue on
every repetition as <b>loop</b> and other branching
instructions do,
but they actually eliminate the prefetch queue cycle-eater
altogether, since no instruction fetching at all is required while a
string instruction repeats.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> As
we saw in Chapter
9, shifts and rotates by CL also eliminate the prefetch queue
cycle-eater, although those instructions don't pack quite the punch
that repeated string instructions do, both because they perform
relatively specialized tasks and because there's not much point to
repeating a shift or rotate more than 16 times.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">We've already
discussed repeated string instructions and repeated shifts and
rotates in plenty of detail, so I'm not going to spend much more time
on them here. However, I would like to offer one hint about using
shifts and rotates by CL. As we found in Chapter 9, repeated shifts
and rotates are generally faster than individual shifts and rotates
when a shift or rotate of 3 or more bits is required. Repeated
shifts and rotates are also <i>much</i> faster than
shifting 1 bit at
a time in a loop; the sequence:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>BitShiftLoop:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> shr ax,1</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> loop BitShiftLoop</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">is
far inferior to <b>shr
ax,cl</b>.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Nonetheless, repeated
shifts and rotates still aren't <i>fast</i> &#8212; instead, you
might think of them as less slow than the alternatives. It's easy to
think that shifts and rotates by CL are so fast that they can be used
with impunity, since they avoid looping and prefetching, but that's
just not true. A repeated shift or rotate takes 8 cycles just to
start, and then takes 4 cycles per bit shifted. Even a 4-bit shift
by CL takes 24 cycles, which is not insignificant, and a 16-bit shift
by CL takes a full 72 cycles. Use shifts and rotates by CL
sparingly, and keep them out of loops whenever you can. Look-up
tables, our next topic, are often a faster alternative to multi-bit
shifts and rotates.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h2 class="western"><font color="#110d06"><font color="#0b0703"><a name="_LOOK-UP_TABLES:_"></a><a class="western" href="#T1303"><font style="font-size: 16pt;" size="4"><b>13.3
LOOK-UP TABLES: CALCULATING WITHOUT BRANCHING</b></font></a></font></font></h2>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Like the use of
repeated string instructions, the use of look-up tables is a familiar
technique that can help avoid branching. Whenever you're using
branching code to perform a calculation, see if you can't use a
look-up table instead; tight as your branching code may be, look-up
tables are usually faster still. <a class="western" href="#L1126">Listings
11-26</a> and <a class="western" href="#L1127">11-27</a>
pit a
five-instruction sequence that branches no more than once against an
equivalent table look-up; you can't get branching code that's much
tighter than that, and yet the table look-up is much faster.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In
short, if you have
a calculation to make &#8212; even a simple one &#8212; see if it
isn't faster to precalculate the answer at assembly time and just
look it up at run time.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h2 class="western"><font color="#110d06"><font color="#0b0703"><a name="_TAKE_THE_BRANCH"></a><a class="western" href="#T1304"><font style="font-size: 16pt;" size="4"><b>13.4
TAKE THE BRANCH LESS TRAVELLED BY</b></font></a></font></font></h2>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> One
of the best ways
to avoid branching is to arrange your code so that conditional jumps
rarely jump. Usually you can guess which way a given conditional
test will most often go, and if that's the case, you can save a good
deal of branching simply by arranging your code so that the
conditional jump will fall through &#8212; that is, not branch &#8212;
in the more common case. Sometimes the choice is made on the basis
of which case is most time-critical rather than which is most common,
but the principle remains the same.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Why
is it that falling
through conditional jumps is desirable? Simple: none of the
horrendous speed loss associated with branching applies to
conditional jumps that fall through, <i>because conditional
jumps
don't branch when they fall through</i>.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Let's look at the
statistics. It always takes a conditional jump at least 16 cycles to
branch, and the total cost in cycles is usually somewhat greater
because the prefetch queue is emptied. On the other hand, it takes a
conditional jump a maximum of just 8 cycles <i>not</i> to
jump, that
being the case if the prefetch queue is empty and both bytes of the
instruction must be fetched before they can be executed. The
official execution time of a conditional jump that doesn't branch is
just 4 cycles, so it is particularly fast to fall through a
conditional jump if both bytes of the instruction are waiting in the
prefetch queue when it comes time to execute them.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In
other words,
falling through a conditional jump can be anywhere from 100% to 700%
faster than branching, depending on the exact state and behavior of
the prefetch queue. As you might imagine, it's worth going out of
your way to reap cycle savings of that magnitude...and that's why you
should arrange your conditional jumps so that they fall through as
often as possible.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> For
example, you'll
recall that in Chapter 11 &#8212; in <a class="western" href="#L1120">Listing
11-20</a>, to be precise &#8212; we tested several characters for
inclusion in a small set via repeated <b>cmp</b>/<b>jz</b>
instruction pairs. We arranged the conditional jumps so that a jump
occurred only when a match was made, meaning that at most one branch
was performed during any given inclusion test. Put another way, we
branched out of the main stream of the subroutine on the less common
condition.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> You
may not have
thought much of it at the time, but the arrangement of branches in
<a class="western" href="#L1120">Listing 11-20</a>
was no accident. Tests for four potential matches are involved when
testing for
inclusion in a set of four characters, and no more than one of those
matches can occur during any given test. Given an even distribution
of match characters, matching is clearly less common than not
matching. If we jumped whenever we <i>didn't</i> get a
match (the
more common condition), we'd end up branching as many as three times
during a single test, with significantly worse performance the likely
result.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <a name="L1303R"></a><a class="western" href="#L1303">Listing
13-3</a> shows <a class="western" href="#L1120">Listing
11-20</a>
modified to branch on non-matches rather than matches. The original
branch-on-match version ran in 119 us, and, as predicted, that's
faster than <a class="western" href="#L1303">Listing
13-3</a>, which
runs in 133 us. That's not the two-or three-times performance
improvement we've grown accustomed to seeing (my, how jaded we've
become!), but it's significant nonetheless, especially since we're
talking about a very small number of conditional jumps. We'd see a
more dramatic difference if we were dealing with a long series of
tests.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Another relevant point
is that the <i>worst-case</i> performance of <a class="western" href="#L1303">Listing
13-3</a> is much worse than that of Listing 11-20. <a class="western" href="#L1303">Listing
13-3</a> actually has a shorter best-case time than <a class="western" href="#L1120">Listing
11-20</a>, because no branches at all are performed when the test
character is 'A'. On the other hand, <a class="western" href="#L1303">Listing
13-3</a> performs three branches when the test character is '!'
or is
not in the set, and that's two branches more than <a class="western" href="#L1120">Listing
11-20</a> ever performs. When you're trying to make sure that
code
always responds within a certain time, worst-case performance can
matter more than average performance.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Then, too, if the
characters tested are often not in the set, as may well be the case
with such a small set, the branching-out approach of <a class="western" href="#L1120">Listing
11-20</a> will far outperform the branch-branch-branch approach
of
<a class="western" href="#L1303">Listing 13-3</a>.
When <a class="western" href="#L1120">Listing
11-20</a> is modified so that none of the five test characters is
in
the set, its overall execution time scarcely changes, rising by just
8 us, to 127 us. When <a class="western" href="#L1303">Listing
13-3</a>
is modified similarly, however, its overall execution time rises by a
considerably greater amount &#8212; 26 us &#8212; to 159 us. This
neatly illustrates the potential worst-case problem of repeated
branching that we just discussed. </font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">There are two lessons
here. The first and obvious lesson is that you should arrange your
conditional jumps so that they fall through as often as possible. The
second lesson is that you must understand the conditions under
which your code will operate before you can truly optimize it.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> For
instance, there's
no way you can evaluate the relative merits of the versions of
<b>CheckTestSetInclusion</b> in <a class="western" href="#L1120">Listings
11-20</a> and <a class="western" href="#L1303">13-3</a>
until you
know the mix of characters that will be tested. There's no such
beast as an absolute measure of code speed, only code speed in
context. You've heard that before as it relates to instruction mix
and the prefetch queue, but here we're dealing with a different
aspect of performance. What I mean now is that you must understand
the typical and worst-case conditions under which a block of code
will run before you can get a handle on its performance and consider
possible alternatives.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Your ability to
understand and respond to the circumstances under which your
assembler code will run gives you a big leg up on high-level language
compilers. There's no way for a compiler to know the typical and/or
worst-case conditions under which code will run, let alone which of
those conditions is more important in your application.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> For
instance, suppose
that we have one loop which repeats 10 times on average and another
loop which repeats 10000 times on average, with both loops executed a
variable (not constant) number of times. A C compiler couldn't know
that cycles saved in the second loop would have a 1000-times-greater
payoff than cycles saved in the first loop, so it would have to
approach both loops in the same way, generating the same sort of code
in both cases. What this means is that compiled code is designed for
reasonable performance under all conditions...hardly the ticket for
greatness.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_PUT_THE_LOAD"></a><a class="western" href="#T1304"><font size="4"><b>PUT
THE LOAD ON THE UNIMPORTANT CASE</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">When arranging
branching code to branch on the less critical case, don't be afraid
to heap the cycles on that case if that will help the more critical
case.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> For
example, suppose
that you need to test whether CX is zero at the start of a long
subroutine and return if CX is in fact zero. You'd normally do that
with something like:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>LongSubroutine proc near</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jcxz LongSubroutineEnd</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> :</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;
*** Body of subroutine ***</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> :</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>LongSubroutineEnd:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ret</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>LongSubroutine endp</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">Now,
however, assume
that the body of the subroutine is more than 127 bytes long. In that
case, the 1-byte displacement of <b>jcxz</b> can't reach
<b>LongSubroutineEnd</b>, so the last bit of code won't
work.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Well, then, the
obvious alternative is: </font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>LongSubroutine proc near</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> and cx,cx</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jnz DoLongSubroutine</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jmp LongSubroutineEnd</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>DoLongSubroutine:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> :</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;
*** Body of subroutine ***</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> :</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>LongSubroutineEnd:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ret</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>LongSubroutine endp</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">There's a problem
here, though. Every time CX <i>isn't</i> zero we end up
branching,
and that's surely wrong. The case where CX is zero is most likely
rare, and is probably of no real interest to us anyway, since it's a
do-nothing case for the subroutine. (At any rate, for the purposes
of this example we'll assume that the CX equal to 0 case is rare and
uninteresting.) What's more, whether the CX equal to 0 case is rare
or not, the body of the subroutine is skipped when CX is 0, so that
case is bound to be much faster than the other cases. That means
that the CX equal to zero case is not only unimportant, but also
doesn't affect the worst-case performance of the subroutine. Yet
here we are, adding an extra branch to every single invocation of
this subroutine simply to protect against the quick and unimportant
case of CX equal to zero.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
tail is wagging
the dog.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Instead, let's heap
the branches on the CX equal to zero case, sparing the other, more
important cases as much as possible. One solution is: </font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>LongSubroutineExit proc near</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ret</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>LongSubroutineExit endp</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>LongSubroutine proc near</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jcxz LongSubroutineExit</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> :</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;
*** Body of subroutine ***</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> :</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ret</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>LongSubroutine endp</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">This
restores the code
to its original, saner state, where the shortest possible time &#8212;
6 cycles for a single <b>jcxz</b> that falls through &#8212; is
used
to guard against the case of CX equal to zero.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> If
you prefer that
your subroutines be exited only from the end, as is for example
necessary when a stack frame must be deallocated, there's another
solution:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>LongSubroutineExit proc near</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jmp LongSubroutineEnd</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>LongSubroutineExit endp</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>LongSubroutine proc near</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jcxz LongSubroutineExit</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> :</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;
*** Body of subroutine ***</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> :</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>LongSubroutineEnd:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ret</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>LongSubroutine endp</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">Now
we've <i>really</i>
put the load on the CX equal to zero case, for two branches must be
performed in that case. So what? As far as we're concerned, the CX
equal to zero case can take as long as it pleases, so long as it
doesn't slow down the real work of the subroutine, which is done when
CX isn't equal to zero.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h2 class="western"><font color="#110d06"><font color="#0b0703"><a name="_YES,_VIRGINIA,_THERE"></a><a class="western" href="#T1305"><font style="font-size: 16pt;" size="4"><b>13.5
YES, VIRGINIA, THERE </b></font><font style="font-size: 16pt;" size="4"><i><b>IS</b></i></font><font style="font-size: 16pt;" size="4"><b>
A FASTER 32-BIT NEGATE!</b></font></a></font></font></h2>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In
Chapter 9 we came
across an extremely fast and compact way to negate 32-bit values, as
follows:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> neg dx</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> neg ax</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> sbb dx,0</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">This
very short

sequence involves two register-only negations, one
constant-from-register subtraction &#8212; and no branches. At the
time, I told you that, fast as that code was, at some later point
we'd run across a still faster way to negate a 32-bit value.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">That time has come. Incredibly, we're going to speed up 32-bit negates
by using a
branching instruction. Yes, I know that I've been telling you to
avoid branching like the plague, but there's a trick here: we're not
really going to branch. The branching instruction we're going to use
is a conditional jump, and we're going to fall through the jump
almost every time.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">There's a bit of
history to this trick, and it's worth reviewing for the lesson about
the Zen of assembler it contains. The story goes as follows:</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Having worked out to
my satisfaction how the above 32-bit negation worked, I (somewhat
egotistically, I admit) asked Dan Illowsky if <i>he</i>
knew how to
negate a 32-bit value in three instructions.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Well, it took him a
while, but he did come up with a working three-instruction solution.
Interestingly enough, it wasn't the solution I had found. Instead,
he derived the second solution I mentioned in Chapter 9:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> not dx</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> neg ax</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> sbb dx,-1</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">This
solution is
equivalent to the first solution in functionality, length, and cycle
count.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">That's not the end of
the tale, however. Taken aback because Dan had come up with a
different and equally good solution (demonstrating that my solution
wasn't so profound after all), I commented that while he had managed
to <i>match</i> my solution, he surely could never <i>surpass</i>
it.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <i>Ha!</i></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> If
there's one word
that should set any Zen programmer off like a rocket, it's "never." The
8088 instruction set is so rich and varied that there are dozens
of ways to do just about anything. For any but the simplest task
several of those approaches &#8212; and not necessarily the obvious
ones &#8212; are bound to be good. Whenever you think that you've
found the best possible solution for anything more complex than
incrementing a register, you're most likely in for a humbling
experience.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> At
any rate, "never"
certainly set Dan off. He got a thoughtful look on his face, walked
off, and came back five minutes later with a faster implementation.
Here it is:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> not dx</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> neg ax</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jnc Negate32BitsCarry</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>Negate32BitsDone:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> :</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>Negate32BitsIncDX:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> inc dx</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jmp short
Negate32BitsDone</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">where
the code at
<b>Negate32BitsCarry</b> is somewhere &#8212; anywhere &#8212; within
a 1-byte displacement (+127 to -128 bytes) of the byte after the <b>jnc</b>
instruction.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> It
may not <i>look</i>
like working 32-bit negation code, but working code it is, believe
me. <i>Brilliant</i> working code.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_HOW_32-BIT_NEGATION"></a><a class="western" href="#T1305"><font size="4"><b>HOW
32-BIT NEGATION WORKS</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In
order to understand
the brilliance of Dan's code, we first need to get a firm grasp on
the mechanics of 32-bit negation. The basic principle of two's
complement negation is that the value to be negated is first notted
(that is, all its bits are flipped, from 1 to 0 or 0 to 1), and then
incremented. For a 32-bit value stored in DX:AX, negation would
ideally follow one of the two sequences shown in Figure 13.1, with
all operations performed 32 bits at a time.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_53ec645a.jpg" align="bottom" border="0" height="405" width="608"></font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Unfortunately, the
8088 can only handle data 16 bits at a time, so we must perform
negation with a series of 16-bit operations like:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> not dx</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> neg ax</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> sbb dx,-1</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">as
shown in Figure
13.2. </font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_5ba4e0f7.jpg" align="bottom" border="0" height="591" width="612"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">The
purpose of the
first operation, notting DX with the <b>not</b>
instruction, is
obvious enough: flipping all the bits in the high word of the value.
The purpose of the second operation, negating AX, is equally
obvious: negating the low word of the value with the <b>neg</b>
instruction, which both nots AX and increments it all at once.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">After two
instructions, we've successfully notted the entire 32-bit value in
DX:AX, and we've incremented AX as well. All that remains to be done
is to complete the full 32-bit increment by incrementing DX if
necessary.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">When does DX need to
be incremented? In one case only &#8212; when AX is originally 0, is
notted to 0FFFFh, and is incremented back to 0, with a carry out from
bit 15 of AX indicating that AX has turned over to 0 and so the
notted value in DX must be incremented as well, as shown in Figure
13.3. </font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_m2e37b582.jpg" align="bottom" border="0" height="688" width="607"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">In
all other cases,
incrementing the 32-bit notted value in DX:AX doesn't alter DX at
all, since incrementing AX doesn't cause a carry out of bit 15 unless
AX is 0FFFFh.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">However, due to the
way that <b>neg</b> sets the Carry flag (as if subtraction
from zero
had occurred), the Carry flag is set by <b>neg</b> in all
cases
<i>except</i> the one case in which DX needs to be
incremented. Consequently, after <b>neg ax</b> we subtract
-1 from DX with borrow,
with the 1 value of the Carry flag normally offsetting the -1,
resulting in a subtraction of 0 from DX. In other words, DX remains
unchanged when <b>neg ax</b> sets the Carry flag to 1,
which is to
say in all cases except when AX is originally zero. That's just what
we want; in all those cases the 32-bit negation was actually complete
after the first two instructions, since the increment of the notted
32-bit value doesn't affect DX, as shown in Figure 13.4.</font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_m4052a111.jpg" align="bottom" border="0" height="583" width="608"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In
the case where AX
is originally 0, on the other hand, <b>neg ax</b> doesn't
set the
Carry flag. This is the one case in which DX must be incremented. In
this one case only, <b>sbb dx,-1</b> succeeds in
subtracting -1
from DX, since the Carry flag is 0. Again, that's what we want; in
this one case DX is affected when the 32-bit value is incremented,
and so incrementing DX completes the 32-bit negation, as shown in
Figure 13.5.</font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_m4f4eab0.jpg" align="bottom" border="0" height="581" width="607"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_HOW_FAST_32-BIT"></a><a class="western" href="#T1305"><font size="4"><b>HOW
FAST 32-BIT NEGATION WORKS</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Now
that we understand
what our code has to do, we're in a position to think about
optimizations. We'll do just what Dan did &#8212; look at negation
from a functional perspective, understanding exactly what needs to be
done and tailoring our code to do precisely that and nothing more.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
breakthrough in
Dan's thinking was the realization that DX only needs to be
incremented when AX originally was 0, which normally happens only
once in a blue moon (once out of every 64 K evenly-distributed
values, to be exact). For all other original values of AX, the bits
in DX simply flip in the process of 32-bit negation, and nothing more
needs to be done to DX after the initial <b>not</b>. As we
found
above, the 32-bit negation is actually complete after the first two
instructions for 64 K-1 out of every 64 K possible values to be
negated, with the final <b>sbb</b> almost always leaving
DX
unchanged.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Improving the code is
easy once we've recognized that the first two instructions usually
complete the 32-bit negation. The only question is how to minimize
the overhead taken to check for the rare case in which DX needs to be
incremented. A once-in-64 K-times case is more than rare enough to
absorb a few extra cycles, so we'll branch out to increment DX in the
case where it needs to be adjusted. The payoff for branching in that
one case is that in all other cases a 3-byte, 4-cycle <b>sbb</b>
instruction is replaced by a 2-byte, 4-cycle fall-through of <b>jnc</b>.
In tight code, the 1-byte difference will usually translate into 4
cycles, thanks to the prefetch queue cycle-eater.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Essentially, <b>jnc</b>
is a faster way of doing nothing in the 64 K-1 cases where DX:AX
already contains the negated value than <b>sbb dx,-1</b>
is. Granted, <b>jnc</b> is also a slower way of
incrementing DX in the
one case where that's necessary, but that's so infrequent that we can
readily trade those extra cycles for the cycles we save on the other
cases.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Let's try out the two
32-bit negates to see how they compare in actual use. <a name="L1304R"></a><a class="western" href="#L1304">Listing
13-4</a>, which uses the original nonbranching 32-bit negation
code,
runs in 2264 us. <a name="L1305R"></a><a class="western" href="#L1305">Listing
13-5</a>,
which uses the branch-on-zero-AX approach to 32-bit negation, runs in
2193 us. A small improvement, to be sure &#8212; but it is
nonetheless an improvement, and since the test code's 100:1 ratio of
zero to non-zero values is much less than the real world's ratio of
64 K-1:1 (assuming evenly distributed values), the superiority of the
branch-on-zero-AX approach is somewhat greater than this test
indicates.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> By
itself, speeding
the negation of 32-bit values by a few cycles isn't particularly
noteworthy. On the other hand, you must surely realize that if it
was possible to speed up even the three-instruction, non-branching
sequence that we started off with, then it must be possible to speed
up just about any code, and that perception is important indeed.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Code for almost <i>any</i>
task can be implemented in many different ways, and can in the
process usually be made faster than it currently is. It's not always
worth the cost in programming time and/or bytes to speed up code &#8212;
you must pick your spots carefully, concentrating on loops and other
time-critical code &#8212; but it can almost always be done. The key
to improved performance lies in understanding exactly what the task
at hand requires and understanding the context in which the code
performs, and then matching that understanding to the resources of
the PC.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> My
own experience is
that no matter how many times I study a time-critical sequence of,
say, 20-100 instructions, I can always save at least a few more
cycles &#8212; and sometimes many more &#8212; by viewing the code
differently and reworking it to match the capabilities of the 8088
more closely. That's why way back in Chapter 2 I said that
"optimize" was not a word to be used lightly. When
programming in assembler for the PC, only fools and geniuses consider
their code optimized. As for the rest of us...well, we'll just have
to keep working on our time-critical code, trying new approaches and
timing the results, with the attitude that our code is good and
getting better.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> And
have we finally
found the fastest possible code for 32-bit negation, never to be
topped? Lord knows I don't expect to come across anything faster in
the near future. But <i>never</i>?</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Don't bet on it.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h2 class="western"><font color="#110d06"><font color="#0b0703"><a name="_ARRANGE_YOUR_CODE"></a><a class="western" href="#T1306"><font style="font-size: 16pt;" size="4"><b>13.6
ARRANGE YOUR CODE TO ELIMINATE BRANCHES</b></font></a></font></font></h2>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">There are many, many
ways to arrange your code to eliminate branches. I'm going to
discuss a few here, but don't consider this to be anything like an
exhaustive list. Whenever you use branching instructions where
performance matters, take it as a challenge to arrange those
instructions for maximum performance and minimum code size.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_PRELOADING_THE_LESS"></a><a class="western" href="#T1306"><font size="4"><b>PRELOADING
THE LESS COMMON CASE</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> One
of my favorite
ways to eliminate jumps comes up when a register must be set to one
of two values based on a test condition. For example, suppose that
we want to set AL to 0 if DL is less than or equal to 10, and set AL
to 1 if DL is greater than 10.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
obvious solution
is:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> cmp dl,10 ;is
DL greater than 10?</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ja DLGreaterThan10 ;yes,
so set AL to 1</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> sub al,al ;DL
is less than or equal to 10</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jmp short
DLCheckDone</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>DLGreaterThan10:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov al,1 ;DL
is greater than 10</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>DLCheckDone:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">Here
we either branch
or don't branch to reach the code that sets AL to the appropriate
value; after setting AL, we rejoin the main flow of the code,
branching if necessary. Whether DL is greater than 10 or not, a
branch is always performed.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Now
let's try this
out:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> sub al,al ;assume
DL will not be greater than 10</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> cmp dl,10 ;is
DL greater than 10?</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jbe DLCheckDone ;no,
so AL is already correct</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov al,1 ;DL
is greater than 10</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>DLCheckDone:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">Here
we've loaded AL
with one of the two possible results <i>before</i> the
test. In one
of the two possible cases, we've guessed right and AL is already
correct, so a single branch ends the test-and-set code. In the other
possible case, we've guessed wrong, so the conditional jump falls
through and AL is set properly. (By the way, <b>inc ax</b>
would be
faster than and logically equivalent to <b>mov al,1</b> in
the above
code. Right now, though, we're focusing on a different sort of
optimization, and I've opted for clarity rather than maximum speed; I
also want you to see that the preload approach is inherently faster,
whether or not tricks like <b>inc ax</b> are used.)</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">I'll admit that it's
more than a little peculiar to go out of our way to set AL twice in
some cases; the previous example set AL just once per test-and-set,
and that would logically seem to be the faster approach. While we
sometimes set AL an extra time with the preload approach, however, we
also avoid a good bit of branching, and that's more than enough to
compensate for the extra times AL is set.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Consider this. If DL
is less than or equal to 10, then the first example (the "normal"
test-and-branch code) performs a <b>cmp dl,10</b> (4
cycles/2 bytes),
a <b>ja DLGreaterThan10</b> that falls through (4 cycles/2
bytes), a
<b>sub al,al</b> (3 cycles/2 bytes), and a <b>jmp
short DLCheckDone</b>
(15 cycles/2 bytes). The grand total: 26 cycles, 8 instruction
bytes and one branch, as shown in Figure 13.6a.</font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_m196c7612.jpg" align="bottom" border="0" height="487" width="594"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> On
the other hand, the
preload code of the second example handles the same case with a <b>sub
al,al</b> (3 cycles/2 bytes), a <b>cmp dl,10</b> (4
cycles/2 bytes),
and a <b>jbe DLCheckDone</b> that branches (16 cycles/2
bytes). The
total: 23 cycles, 6 instruction bytes and one branch, as shown in
Figure 13.7a. </font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_461364a8.jpg" align="bottom" border="0" height="422" width="614"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">That's
not much faster
than the normal approach, but it is faster.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Now
let's look at the
case where DL is greater than 10. Here the test-and-branch code of
the first example performs a <b>cmp dl,10</b> (4 cycles/2
bytes), a
<b>ja DLGreaterThan10</b> that branches (16 cycles/2
bytes), and a
<b>mov al,1</b> (4 cycles/2 bytes), for a total of 24
cycles, 6
instruction bytes and one branch, as shown in Figure 13.6b.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
preload code of
the second example handles the same DL greater than 10 case with a
<b>sub al,al</b> (3 cycles/2 bytes), a <b>cmp dl,10</b>
(4 cycles/2
bytes), a <b>jbe DLCheckDone</b> that doesn't branch (4
cycles/2
bytes), and a <b>mov al,1</b> (4 cycles/2 bytes). The
total: 8
instruction bytes -2 bytes more than the test-and-branch code &#8212;
but just 15 cycles...<i>and no branches</i>, as shown in
Figure
13.7b. The lack of a prefetch queue-flushing branch should more than
compensate for the two additional instruction bytes that must be
fetched.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In
other words, the
preload code is either 3 or 9 cycles faster than the more familiar
test-and-branch code, is 2 bytes shorter overall, and sometimes
branches less while never branching more. That's a clean sweep for
the preload code &#8212; all because always performing one extra
register load made it possible to do away with a branch.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Let's run the two
approaches through the Zen timer. <a name="L1306R"></a><a class="western" href="#L1306">Listing
13-6</a>, which times the test-and-branch code when DL is 10
(causing
AL to be set to 0), runs in 10.06 us per test-and-branch. By
contrast, <a name="L1307R"></a><a class="western" href="#L1307">Listing
13-7</a>, which
times the preload code for the same case, runs in just 8.62 us.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">That's a healthy
advantage for the preload code, but perhaps things will change if we
test a case where AL is set to 1, by altering <a class="western" href="#L1306">Listings
13-6</a> and <a class="western" href="#L1307">13-7</a>
to set DL to
11 rather than 10 prior to the tests.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Things do indeed
change when DL is set to 11. <a class="western" href="#L1306">Listing
13-6</a> speeds up to 8.62 ms per test, matching the performance
of
<a class="western" href="#L1307">Listing 13-7</a>
when DL was 10. When DL is 11, however, <a class="western" href="#L1307">Listing 13-7</a>
speeds up to 8.15 us, again comfortably outperforming <a class="western" href="#L1306">Listing
13-6</a>.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In
short, the preload
approach is superior in every respect. While it's counterintuitive to
think that by loading a register an extra time we can actually speed
up code, it does work, and that sort of unorthodox but effective
technique is what the Zen of assembler is all about.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> A
final note on the
preload approach: arrange your preload code so that the more common
case is <i>not</i> preloaded. Once again this is
counterintuitive,
since it seems that we're going out of our way to guess wrong about
the outcome of the test. Remember, however, that it's much faster to
fall through a conditional jump, and you'll see why preloading the
less common value makes sense. It's actually faster to fall through
the conditional jump and load a value than it is just to branch at
the conditional jump, even if the correct value is already loaded.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
results from the
two executions of <a class="western" href="#L1307">Listing
13-7</a>
confirm this. The case where the value preloaded into AL is correct
actually runs a good bit more slowly than the case where the
conditional jump falls through and a new value must be loaded.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <i>Think
of your
assembler programs not just in terms of their logic but also in terms
of how that logic can best be expressed</i> &#8212; <i>in terms
of
cycles and/or bytes</i> &#8212; <i>in the highly irregular
language
of the 8088</i>. The first example in this section &#8212; the
"normal" approach &#8212; seems at first glance to be the
ideal expression of the desired test-and-set sequence in 8088
assembler. However, the poor performance of branching instructions
renders the normal approach inferior to the preload approach on the
8088, even though preloading is counter to common sense and most
programming experience. In short, the best 8088 code can only be
arrived at by thinking in terms of the 8088; superior 8088 solutions
often seem to be lunacy in other logic systems.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Thinking in terms of
the 8088 can be particularly difficult for those of us used to
high-level languages, in which programs are pure abstractions far
removed from the ugly details of the processor. When programming in
a high-level language, it would seem to be faster to preload the
correct value and test than to preload an incorrect value, test, and
load the correct value. In fact, in any high-level language it would
seem most efficient to use an <b>if...then...else</b>
structure to
handle a test-and-set case such as the one above.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">That's not the way it
works on the 8088, though, because not all tests are created equal &#8212;
tests that branch are much slower than tests that fall through. When
you're programming the 8088 in assembler, the maddening and
fascinating capabilities of the processor must become part of your
logic system, however illogical the paths down which that perspective
leads may seem at times to be.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_USE_THE_CARRY"></a><a class="western" href="#T1306"><font size="4"><b>USE
THE CARRY FLAG TO REPLACE SOME BRANCHES</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Unlike the other
flags, the Carry flag can serve as a direct operand to some
arithmetic instructions, such as <b>rcr</b> and <b>adc</b>.
This
gives the Carry flag a unique property &#8212; it can sometimes be
used to alter the value in a register conditionally <i>without
branching</i>.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> For
instance, suppose
that we want to count the number of negative values in a 1000-word
array, maintaining the count in DX. One way to do this is shown in
<a name="L1308R"></a><a class="western" href="#L1308">Listing 13-8</a>,
which runs in
12.29 ms. In this code, each value is anded with itself. The
resulting setting of the Sign flag indicates whether the value is
positive or negative. With the help of a conditional jump, the Sign
flag setting controls whether DX is incremented or not.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Speedy and compact as
it is, <a class="western" href="#L1308">Listing
13-8</a> <i>does</i>
involve a conditional jump that branches about half the time...and by
now you should be developing a distinct dislike for branching. By
using the Carry flag to eliminate branching entirely, we can speed
things up quite a bit.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <a name="L1309R"></a><a class="western" href="#L1309">Listing
13-9</a> does just that, shifting the sign bit of each tested
value
into the Carry flag and then adding it &#8212; along with zero, since
<b>adc</b> requires two source operands &#8212; to DX, as shown
in
Figure 13.8. (Note that the constant zero is stored in BX for speed,
since <b>adc dx,bx</b> is 1 byte shorter and 1 cycle
faster than <b>adc
dx,0</b>.) The result is that DX is incremented only when the
sign
bit of the value being tested is 1 &#8212; that is, only when the
value being tested is negative, which is exactly what we want.</font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_m34f83aab.jpg" align="bottom" border="0" height="639" width="606"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <a class="western" href="#L1309">Listing
13-9</a> runs in 10.80 ms. That's about 14% faster than <a class="western" href="#L1308">Listing
13-8</a>, even though the instruction that increments DX in <a class="western" href="#L1309">Listing
13-9</a> (<b>adc dx,bx</b>) is actually 1 byte longer
and 1 cycle
slower than its counterpart in <a class="western" href="#L1308">Listing
13-8</a> (<b>inc dx</b>). The key to the improved
performance is,
once again, avoiding branching. In this case that's made possible by
recognizing that a Carry flag-based operation can accomplish a task
that we'd usually perform with a conditional jump. You wouldn't
normally think to substitute <b>shl</b>/<b>adc</b>
for <b>and</b>/<b>jns</b>/<b>inc</b>
&#8212; they certainly don't <i>look</i> the least bit similar &#8212;
but in this particular context the two instruction sequences are
equivalent.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
many and varied
parts of the 8088's instruction set are surprisingly interchangeable.
Don't hesitate to mix and match them in unusual ways.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_NEVER_USE_TWO"></a><a class="western" href="#T1306"><font size="4"><b>NEVER
USE TWO JUMPS WHEN ONE WILL DO</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Don't use a
conditional jump followed by an unconditional jump when the
conditional jump can do the job by itself. Generally, a conditional
jump should only be paired with an unconditional jump when the 1-byte
displacement of the conditional jump can't reach the desired offset &#8212;
that is, when the offset to be branched to is more than -128 to +127
bytes away.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> For
example: </font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jz IsZero</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">works
fine unless
<b>IsZero</b> is more than -128 or +127 bytes away from the
first
byte of the instruction immediately following the <b>jz</b>
instruction. (You'll recall that we found in the last chapter that
conditional jumps, like all jumps that use displacements, actually
branch relative to the offset of the start of the following
instruction.) If, however, <b>IsZero</b> <i>is</i>
more than -128 or
+127 bytes away, the polarity of the conditional jump must be
reversed, and the conditional jump must be used to skip around the
unconditional jump:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jnz NotZero</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jmp IsZero</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>NotZero:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">When
the conditional
jump falls through (in the case that resulted in a branch in the
first example), the 2-byte displacement of the unconditional jump can
be used to jump to <b>IsZero</b> no matter where in the
code segment
<b>IsZero</b> may be.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Logically, the two
examples we've just covered are equivalent, branching in exactly the
same cases. There's an obvious difference in the way the two
examples <i>run</i>, though &#8212; the first example branches
in
only one of the two cases, while the second example always branches,
and is larger too.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In
this case, it's
pretty clear which is the code of choice (at least, I <i>hope</i>
it
is!) &#8212; you'd only use a conditional jump around an
unconditional jump when a conditional jump alone can't reach the
target label. However, paired jumps can also be eliminated in a
number of less obvious situations.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> For
example, suppose
that you want to scan a string until you come to either a character
that matches the character in AH or a zero byte, whichever comes
first. You might conceptualize the solution as follows:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> 1)
Get the next byte.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> 2)
If the next byte
matches the desired byte, we've got a match and we're done.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> 3)
If the next byte is
zero, we're done without finding a match.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> 4)
Repeat 1).</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">That sort of thinking
is likely to produce code like that shown in <a name="L1310R"></a><a class="western" href="#L1310">Listing
13-10</a>, which is a faithful line-by-line reproduction of the
above
sequence.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <a class="western" href="#L1310">Listing
13-10</a> works perfectly well, finishing in 431 us. However, the
loop in <a class="western" href="#L1310">Listing
13-10</a> ends with
a conditional jump followed by an unconditional jump. With a little
code rearrangement, the conditional jump can be made to handle both
the test-for-zero and repeat-loop functions, and the unconditional
jump can be done away with entirely. All we need do is put the
"no-match" handling code right after the conditional jump
and change the polarity of the jump from <b>jz</b> to <b>jnz</b>,
so
that the one conditional jump can either fall through if the
terminating zero is found or repeat the loop otherwise.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Back in Chapter 11 we
saw <a class="western" href="#L1111">Listing 11-11</a>,
which
features just such rearranged code. (<a class="western" href="#L1310">Listing
13-10</a> is actually <a class="western" href="#L1111">Listing
11-11</a>
modified to illustrate the perils of using two jumps when one will
do.) <a class="western" href="#L1111">Listing 11-11</a>
runs in just
375 us. Not only is <a class="western" href="#L1111">Listing
11-11</a>
faster than <a class="western" href="#L1310">Listing
13-10</a>, it's
also shorter by two bytes &#8212; the length of the eliminated jump.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Look to streamline
your code whenever you see a short unconditional jump paired with a
conditional jump. Of course, it's not always possible to eliminate
paired jumps, but you'd be surprised at how often loops can be
compacted and speeded up with a little rearrangement.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_JUMP_TO_THE"></a><a class="western" href="#T1306"><font size="4"><b>JUMP
TO THE LAND OF NO RETURN</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">It's not uncommon that
the last action before returning at the end of a subroutine is to
call another subroutine, as follows:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> call SaveNewSymbol</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ret</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>PromptForSymbol endp</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">What's
wrong with this
picture? That's easy: there's a branch to a branch here. The <b>ret</b>
that ends <b>SaveNewSymbol</b> branches directly to the <b>ret</b>
that follows the call to <b>SaveNewSymbol</b> at the end
of
<b>PromptForSymbol</b>. Surely there's a better way!</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Indeed there is a
better way, and that is to end <b>PromptForSymbol</b> by
jumping to
<b>SaveNewSymbol</b> rather than calling it. To wit:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jmp SaveNewSymbol</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>PromptForSymbol endp</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">The <b>ret</b>
at the
end of <b>SaveNewSymbol</b> will serve perfectly well to
return to
the code that called <b>PromptForSymbol</b>, and by doing
this we'll
save one complete <b>ret</b> plus the performance
difference between
<b>jmp</b> and <b>call</b> &#8212; all without
changing the logic of
the code in the least.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> One
<i>caveat</i>
regarding <b>jmp</b> in the place of <b>call</b>/<b>ret</b>:
make
sure that the types &#8212; near or far &#8212; of the two
subroutines match. If <b>SaveNewSymbol</b> is
near-callable but
<b>PromptForSymbol</b> happens to be far-callable, then the
<b>ret</b>
instructions at the ends of the two subroutines are <i>not</i>
equivalent, since near and far <b>ret</b> instructions
perform
distinctly different actions. Mismatch <b>ret</b>
instructions in
this way and you'll unbalance the stack, in the process most likely
crashing your program &#8212; so exercise caution when replacing
<b>call</b>/<b>ret</b> with <b>jmp</b>.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_DON'T_BE_AFRAID"></a><a class="western" href="#T1306"><font size="4"><b>DON'T
BE AFRAID TO DUPLICATE CODE</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Whenever you use an
unconditional jump, ask yourself, "Do I <i>really</i> need
that
jump?" Often the answer is yes...but not always.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">What are unconditional
jumps used for? Generally, they're used to allow a
conditionally-executed section of code to rejoin the main flow of
program execution. For example, consider the following:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;
Subroutine to set AH to 1 if AL contains the</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;
character 'Y', AH to 0 otherwise.</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;
Input:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>; AL
= character to check</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;
Output;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>; AH
= 1 if AL contains 'Y', 0 otherwise</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;
Registers altered: AH</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>CheckY proc near</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> cmp al,'Y'</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jnz CheckYNo</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ah,1 ;it
is indeed 'Y'</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jmp short
CheckYDone</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>CheckYNo:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> sub ah,ah ;it's
not 'Y'</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>CheckYDone:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ret</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>CheckY endp</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">(You'll
instantly
recognize that the whole subroutine could be speeded up simply by
preloading one of the values, as we learned a few sections back. In
this particular case, however, we have a still better option
available.) You'll notice that <b>jmp short CheckYDone</b>,
the one
unconditional jump in the above subroutine, doesn't actually serve
much purpose. Sure, it rejoins the rest of the code after handling
the case where AL is 'Y', but all that happens at that point is a
return to the calling code. Surely it doesn't make sense to expend
the time and 2 bytes required by a <b>jmp short</b> just
to get to a
<b>ret</b> instruction. Far better to simply replace the <b>jmp
short</b> with a <b>ret</b>:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>CheckY proc near</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> cmp al,'Y'</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jnz CheckYNo</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ah,1 ;it
is indeed 'Y'</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ret</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>CheckYNo:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> sub ah,ah ;it's
not 'Y'</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>CheckYDone:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ret</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>CheckY endp</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">The
net effect: the
code is 1 byte shorter, the time required for a branch is saved about
half the time &#8212; <i>and there is absolutely no change in the
logic of the code</i>. It's important that you understand that <b>jmp
short</b> was basically a <b>nop</b> instruction in
the first
example, since all it did was unconditionally branch to another
branching instruction, as shown in Figure 13.9. </font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_m4683d02a.jpg" align="bottom" border="0" height="425" width="598"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">We
removed the
unconditional jump simply by replacing it with a copy of the code
that it branched to.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
basic principle
here is that of duplicating code. Many unconditional jumps can be
eliminated by replacing the jump with a copy of the code at the jump
destination. (Unconditional jumps used for looping are an exception. As
we found earlier, however, unconditional jumps used to end loops
can often be replaced by conditional jumps, improving both
performance and code size in the process.) Often the destination
code is many bytes long, and in such cases code duplication doesn't
pay. However, in many other cases, such as the example shown above,
code duplication is an unqualified winner, saving both cycles and
bytes.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">There are also cases
where code duplication saves cycles but costs bytes, and then you'll
have to decide which of the two matters more on a case-by-case basis.
For instance, suppose that the last example required that AL be
anded with 0DFh (not 20h) after the test for 'Y'. The standard code
would be:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;
Subroutine to set AH to 1 if AL contains the</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;
character 'Y', AH to 0 otherwise. AL is then forced to</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;
uppercase. (AL must be a letter.)</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;
Input:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>; AL
= character to check (must be a letter)</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;
Output;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>; AH
= 1 if AL contains 'Y', 0 otherwise</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>; AL
= character to check forced to uppercase</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;
Registers altered: AX</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>;</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>CheckY proc near</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> cmp al,'Y'</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jnz CheckYNo</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ah,1 ;it
is indeed 'Y'</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jmp short
CheckYDone</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>CheckYNo:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> sub ah,ah ;it's
not 'Y'</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>CheckYDone:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> and al,not
20h ;make it uppercase</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ret</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>CheckY endp</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">The
duplicate-code
implementation would be:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>CheckY proc near</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> cmp al,'Y'</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jnz CheckYNo</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov ah,1 ;it
is indeed 'Y'</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> and al,not
20h ;make it uppercase</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ret</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>CheckYNo:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> sub ah,ah ;it's
not 'Y'</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>CheckYDone:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> and al,not
20h ;make it uppercase</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ret</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>CheckY endp</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">with
both <b>and</b>
and <b>ret</b> duplicated at the end of each of the two
possible
paths through the subroutine.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
decision as to
which of the two above implementations is preferable is by no means
cut and dried. The duplicated-code implementation is certainly
faster, since it still avoids a branch in half the cases. On the
other hand, the duplicated-code implementation is also 1 byte longer,
since a 2-byte <b>jmp short</b> is replaced with a 3-byte
sequence of
<b>and</b> and <b>ret</b>. Neither sequence is
superior on all
counts, so the choice between the two depends on context and your own
preferences.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Duplicated code is
counter to all principles of structured programming. As we've
learned, that's not inherently a bad thing &#8212; when you need
performance, it can be most useful to discard conventions and look
for fresh approaches.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Nonetheless, it's
certainly possible to push the duplicated-code approach too far. As
the code to be duplicated becomes longer and/or more complex, the
duplicated-code approach becomes less appealing. In addition to the
bytes that duplicating longer code can cost, there's also the risk
that you'll modify the code at only one of the duplicated locations
as you alter the program. For this reason, duplicated code sequences
longer than a <b>ret</b> and perhaps one other instruction
should be
used only when performance is at an absolute premium.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_INSIDE_LOOPS_IS"></a><a class="western" href="#T1306"><font size="4"><b>INSIDE
LOOPS IS WHERE BRANCHES REALLY HURT</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Branches always hurt
performance, but where they really hurt is inside loops. There, the
performance loss incurred by a single branching instruction is
magnified by the number of loop repetitions. It's important that you
understand that not all branches are created equal, so that you can
focus on eliminating or at least reducing the branches that most
affect performance &#8212; and those branches are usually inside
loops.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> How
can we apply this
knowledge? By making every effort to use techniques such as
duplicated code, in-line code (which we'll see shortly), and
preloading values inside loops, and by simply moving decision-making
out of loops whenever we can. Let's take a look at an example of
using duplicated code within a loop, in order to see how easily
cycle-saving inside a loop can pay off.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_TWO_LOOPS_CAN"></a><a class="western" href="#T1306"><font size="4"><b>TWO
LOOPS CAN BE BETTER THAN ONE</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Suppose that we want
to determine whether there are more negative or non-negative values
in an array of 8-bit signed values. <a name="L1311R"></a><a class="western" href="#L1311">Listing
13-11</a> does that in 3.60 ms for the sample array by using a
straightforward and compact test-and-branch approach. </font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">There's nothing wrong
with <a class="western" href="#L1311">Listing 13-11</a>,
but there <i>is</i>
an unconditional jump. We'd just as soon do away with that
unconditional jump, especially since it's in a loop. Unfortunately,
the instruction the unconditional jump branches to isn't a simple <b>ret</b>
&#8212; it's a <b>loop</b> instruction, and we all know that
loops
must end in one place, at the loop bottom.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <i>Hmmmm.</i>
Why
must loops end in one place? There's no particular reason that I can
think of, apart from habit, so let's try duplicating some code and
ending the loop in <i>two</i> places. <a name="L1312R"></a><a class="western" href="#L1312">Listing
13-12</a>, which does exactly that, runs in just 3.05 ms. That's
an
improvement of 18% &#8212; quite a return for the 1 byte the
duplicated-code approach adds.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">It's evident that
eliminating branching instructions inside loops can result in
handsome performance gains for relatively little effort. That's why
I urge you to focus your optimization efforts on loops. While we're
on this important topic, let's look at another way to eliminate
branches inside loops.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_MAKE_UP_YOUR"></a><a class="western" href="#T1306"><font size="4"><b>MAKE
UP YOUR MIND ONCE AND FOR ALL</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> If
you find yourself
making a decision inside a loop, for heaven's sake see if you can
manage to make that decision <i>before</i> the loop. Why
decide
every time through the loop when you can decide just once at the
outset?</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Consider <a name="L1313R"></a><a class="western" href="#L1313">Listing
13-13</a>, in which the contents of DL are used to decide whether
to
convert each character to uppercase while copying one string to
another string. <a class="western" href="#L1313">Listing
13-13</a>,
which runs in 3.03 ms for the sample string, is representative of the
situation in which a parameter passed to a subroutine selects between
different modes of operation.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
failing of <a class="western" href="#L1313">Listing
13-13</a> is that the decision as to whether to convert to
uppercase
is made over and over, once for each character. We'd be much better
off if we could make the decision just once at the start of the
subroutine, moving the decision-making (particularly the branching)
out of the loop.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">There are a number of
ways to do this. One is shown in <a name="L1314R"></a><a class="western" href="#L1314">Listing
13-14</a>. Here, a single branch outside the loop is used to
force
the test for inclusion in the lowercase to function also as the test
for whether conversion is desired. If conversion isn't desired, AH,
which normally contains the start of the lowercase range, is set to
0FFh. This has the effect of causing the lowercase test always to
fail on the first conditional jump if conversion isn't desired, just
as was the case in <a class="western" href="#L1313">Listing
13-13</a>.
Consequently, performance stays just about the same when conversion
to uppercase isn't desired.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">However, when
lowercase conversion <i>is</i> desired, <a class="western" href="#L1314">Listing
13-14</a> performs one less test each time through the loop than
does
<a class="western" href="#L1313">Listing 13-13</a>,
because a
separate test to find out whether conversion is desired is no longer
needed. We've already performed the test for whether conversion is
desired at the start of the subroutine &#8212; outside the loop &#8212;
so the code inside the loop can sail through the copy-and-convert
process at full speed. The result is that <a class="western" href="#L1314">Listing
13-14</a> runs in 2.76 ms, significantly faster than <a class="western" href="#L1313">Listing
13-13</a>.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In <a class="western" href="#L1314">Listing
13-14</a>, we've really only moved the test as to whether
conversion
is desired out of the loop in the case where conversion is indeed
desired. When conversion isn't desired, a branch is still performed
every time through the loop, just as in <a class="western" href="#L1313">Listing
13-13</a>. If we're willing to duplicate a bit of code, we can
also
move the branch out of the loop when conversion isn't desired, as
shown in <a name="L1315R"></a><a class="western" href="#L1315">Listing
13-15</a>. There's
a cost in size for this optimization &#8212; 7 bytes &#8212; but
execution time is cut to just 2.35 us, a 29% improvement over <a class="western" href="#L1313">Listing
13-13</a>.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Moreover, <a class="western" href="#L1315">Listing
13-15</a> could easily be speeded up further by using the
word-at-a-time or <b>scas</b>/<b>movs</b>
techniques we encountered
in Chapter 11. Why is it easier to do this to <a class="western" href="#L1315">Listing
13-15</a> than to <a class="western" href="#L1313">Listing
13-13</a>? It's easier because we've completely separated the
instruction
sequences for the two modes of operation of the subroutine, so we
have fewer instructions and simpler code to optimize in whichever
case we try to speed up.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Remember, not all
branches are created equal. If you have a choice between branching
once before a loop and branching once every time through the loop,
it's really like choosing between one branch and dozens or hundreds
(however many times the loop is repeated) of branches. Even when it
costs a few extra bytes, that's not a particularly hard choice to
make, is it?</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_DON'T_COME_CALLING"></a><a class="western" href="#T1306"><font size="4"><b>DON'T
COME CALLING</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Jumps aren't the
8088's only branching instructions. Calls, returns, and interrupts
branch as well. Interrupts aren't usually repeated unnecessarily
inside loops, although you should try to handle data obtained through
DOS interrupts in large blocks, rather than a character at a time, as
we'll see in the next chapter.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> By
definition, returns
can't be executed repeatedly inside loops, since a return branches
out of a loop back to the calling code.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">That leaves
calls...and calls in loops are in fact among the great cycle-wasters
of the 8088.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Consider what the <b>call</b>
instruction does. First it pushes the Instruction Pointer onto the
stack, and then it branches. That's like pairing a <b>push</b>
and a
<b>jmp</b> &#8212; a gruesome prospect from a performance
perspective. Actually, things aren't <i>that</i> bad; the
official
execution time of <b>call</b>, at 23 cycles, is only 8
cycles longer
than that of <b>jmp</b>. Nonetheless, you should cast a
wary eye on
any instruction that takes 23 cycles to execute <i>and</i>
empties
the prefetch queue.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
cycles spent
executing <b>call</b> aren't the end of the performance
loss
associated with calling a subroutine, however. Once you're done with
a subroutine, you have to branch back to the calling code. The
instruction that does that, <b>ret</b>, takes another 20
cycles and
empties the prefetch queue again. On balance, then, a subroutine
call expends 43 cycles on overhead operations and empties the
prefetch queue not once but <i>twice</i>!</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Fine, you say, but
what's the alternative? After all, subroutines are fundamental to
good programming &#8212; we can't just do away with them altogether.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> By
and large, that's
true, but inside time-critical loops there's no reason why we can't
eliminate calls simply by moving the called code into the loop.
Replacing the subroutine call with a macro is the simplest way to do
this. For example, suppose that we have a subroutine called
<b>IsPrintable</b>, which tests whether the character in AL
is a
printable character (in the range 20h to 7Eh). <a class="western" href="#L1316">Listing
13-16</a> shows a loop that calls this subroutine in the process
of
copying only printable characters from one string to another string.
Call and all, <a class="western" href="#L1316">Listing
13-16</a> runs
in 3.48 ms for the test string.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <a name="L1317R"></a><a class="western" href="#L1317">Listing
13-17</a> is functionally identical to <a name="L1316R"></a><a class="western" href="#L1316">Listing
13-16</a>. In <a class="western" href="#L1317">Listing
13-17</a>,
however, the call to the subroutine <b>IsPrintable</b> has
been
converted to the expansion of the macro <b>IS_PRINTABLE</b>,
eliminating the <b>call</b> and <b>ret</b>
instructions. How much
difference does that change from call to macro expansion make? <a class="western" href="#L1317">Listing 13-17</a>
runs in 2.21 ms,
57% faster than <a class="western" href="#L1316">Listing
13-16</a>. <a class="western" href="#L1316">Listing
13-16</a><i> spends over
one-third of its entire execution time simply calling </i><i><b>IsPrintable</b></i><i>
and returning from that subroutine!</i></font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">While the superior
performance of <a class="western" href="#L1317">Listing
13-17</a>
clearly illustrates the price paid for subroutine calls, that listing
by no means applies all of the optimizations made possible by the
elimination of the calls that plagued <a class="western" href="#L1316">Listing
13-16</a>. It's true that the macro <b>IS_PRINTABLE</b>
eliminates
the subroutine call, but there are still internal branches in
<b>IS_PRINTABLE</b>, and there's still a <b>cmp</b>
instruction that
sets the Zero flag on success. In other words, <a class="western" href="#L1317">Listing
13-17</a> hasn't taken full advantage of moving the code into the
loop; it has simply taken the call and return overhead out of
determining whether a character is printable.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <a name="L1318R"></a><a class="western" href="#L1318">Listing
13-18</a> does take full advantage of moving the test code into
the
loop, by eliminating the macro and thereby eliminating the need to
place a return status in the Zero flag. Instead, <a class="western" href="#L1318">Listing
13-18</a> branches directly to <b>NotPrintable</b>
if a character is
found to be non-printable, eliminating the intermediate conditional
jump that <a class="western" href="#L1317">Listing
13-17</a>
performed. It's also no longer necessary to test the Zero flag to
see whether the character is printable before storing it in the
destination array, since any character that passes the two
comparisons for inclusion in the printable range must be printable. The
upshot is that <a class="western" href="#L1318">Listing
13-18</a>
runs in just 1.74 ms, 27% faster than <a class="western" href="#L1317">Listing
13-17</a> and 100% faster than <a class="western" href="#L1316">Listing
13-16</a>.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <a class="western" href="#L1318">Listing
13-18</a> illustrates two useful optimizations in the case where
a
character is found to be printable. First, there's no need to branch
to the bottom of the loop just to branch back to the top of the loop,
so <a class="western" href="#L1318">Listing 13-18</a>
just branches
directly to the top of the loop after storing each printable
character. The same is done when a non-printable character greater
than 7Eh is detected. The point here is that it's fine to branch
back to the top of a loop from multiple places. Second, there's no
way that a printable character can end a string (zero isn't a
printable character), so we don't bother testing for the terminating
zero after storing a printable character; again, the same is true for
non-printable characters greater than 7Eh. When you duplicate code,
it's not necessary to duplicate any portion of the code that performs
no useful function in the new location.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Whenever you use a
subroutine or a macro, you're surrendering some degree of control
over your code in exchange for ease of programming. In particular,
the use of subroutines involves a direct trade-off of decreased
performance for reduced code size and greater modularity. In
general, ease of programming, reduced code size, and modularity are
highly desirable attributes...but not in time-critical code.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Try
to eliminate calls
from your tight loops and time-critical code. If the code called is
large, that may not be possible, but then you have to ask yourself
what such a large subroutine is doing in your time-critical code in
the first place. It may also be beneficial to eliminate macros in
time-critical code. Whether or not that's the case depends on the
nature of the macros, but at least make sure you understand what code
you're really writing. In this pursuit, it can be useful to generate
a listing file in order to see the code the assembler is actually
generating.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> As
I mentioned above,
there are three objections to moving subroutines into loops: size,
modularity, and ease of programming. Let's quickly address each of
these points.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Sure, code gets bigger
when you move subroutines into loops: performance is often a
balancing of program size and performance. That's why you should
concentrate on applying the techniques in this chapter (and, indeed,
all the performance-enhancing techniques presented in <i>The Zen
of
Assembly Language</i>) to time-critical code, where a few extra
bytes
can buy a great many cycles.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> On
the other hand,
code doesn't really have to be less modular when subroutines are
moved into loops. Macros are just as modular as subroutines, in the
sense that in your code both are one-line entries that perform a
well-defined set of actions. In any case, in discussing moving
subroutine code into loops we're generally talking about moving
relatively few instructions into any given loop, since the
call/return overhead becomes proportionately less significant for
longer subroutines (although never insignificant, if you're really
squeezed for cycles). Modularity shouldn't be a big issue with short
instruction sequences.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Finally, as to ease of
programming: if you want easy programming, program in C or Pascal,
or, better yet, COBOL. Assembler subroutine and macro libraries are
fine for run-of-the-mill code, but when it comes to the
high-performance, time-critical parts of your programs, it's your
ability to write the hard assembler code that will set you apart.
Assembler isn't easy, but any competent programmer can eventually get
almost any application to work in assembler. The Zen of assembler
lies not in making an application work, but in making it work as well
as it possibly can, given the strengths and limitations of the PC. </font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_SMALLER_ISN'T_ALWAYS"></a><a class="western" href="#T1306"><font size="4"><b>SMALLER
ISN'T </b></font><font size="4"><i><b>ALWAYS</b></i></font><font size="4"><b>
BETTER</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">You've no doubt
noticed that this chapter seems to have repeatedly violated the rule
that "smaller is better." Not so, given the true meaning
of the rule. "Smaller is better" applies to instruction
prefetching, where fewer bytes to be fetched means less time waiting
for instruction bytes. Subroutine calls don't fall into this
category, even though they reduce overall program size.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Subroutines merely
allow you to run the same instructions from multiple places in a
program. That reduces program size, since the code only needs to
appear in one place, but there are no fewer bytes to be fetched on
any given call than if the code of the subroutine were to be placed
directly into the calling code. In fact, instruction fetching
becomes <i>more</i> of a problem with subroutines, since
the prefetch
queue is emptied twice, and the call and return instruction bytes
must be fetched, as well.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In
short, while
subroutines are great for reducing program size and have a host of
other virtues as regards program design, modularity, and maintenance,
they don't come under the "smaller is better" rule, and
are, in fact, lousy for performance. Much the same &#8212; smaller
is slower &#8212; can be said of branches of many sorts. Of all the
branching instructions, loops are perhaps the worst "smaller is
slower" offender. We're going to close out this chapter with a
discussion of the potent in-line-code alternative to looping &#8212;
yet another way to trade a few bytes for a great many cycles.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h2 class="western"><font color="#110d06"><font color="#0b0703"><a name="_loop_MAY_NOT"></a><a class="western" href="#T1307"><font style="font-size: 16pt;" size="4"><b>13.7
loop MAY NOT BE BAD, BUT LORD KNOWS IT'S NOT GOOD: IN-LINE CODE</b></font></a></font></font></h2>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> One
of the great
misconceptions of 8088 programming is that <b>loop</b> is
a good
instruction for looping. It's true that <b>loop</b> is
designed
especially for looping. It's also true that <b>loop</b> is
the
8088's best looping instruction. But <i>good</i>?</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> No
way.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> You
see, <b>loop</b>
is a branching instruction, and not an especially fast branching
instruction, at that. The official execution time of <b>loop</b>
is
17 cycles, which makes it just 1 cycle faster than the similar
construct <b>dec cx</b>/<b>jnz</b>, although <b>loop</b>
is also 1
byte shorter. Like all branching instructions, <b>loop</b>
empties
the prefetch queue, so it is effectively even slower than it would
appear to be. I don't see how you can call an instruction that takes
in the neighborhood of 20 cycles just to repeat a loop good. Better
than the obvious alternatives, sure, and pleasantly compact and easy
to use if you don't much care about speed &#8212; but not <i>good</i>.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Look at it this way. Suppose you have a program containing a loop that
zeros the high bit
of each byte in a 100-byte array, as shown in <a name="L1319R"></a><a class="western" href="#L1319">Listing
13-19</a>, which runs in 1023 us. What percent of that overall
execution time do you suppose this program spends just decrementing
CX and branching back to the top of the loop &#8212; that is,
looping? Ten percent?</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> No.
Twenty percent?</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> No.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <i>Thirty</i>
percent?</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> No,
but you're getting
warm...<font color="#000099"> </font><a class="western" href="#L1319">Listing
13-19</a> spends <i>forty-five percent</i> of the
total execution
time looping. (That figure was arrived at by comparing the execution
time of <a name="L1320R"></a><a class="western" href="#L1320">Listing
13-20</a>, which
uses no branches and which we'll get to shortly, to the execution
time of <a class="western" href="#L1319">Listing
13-19</a>.) Yes,
you read that correctly &#8212; in a loop which accesses memory twice
and which contains a second instruction in addition to the
memory-accessing instruction, <b>loop</b> manages to take
nearly
one-half of the total execution time. Appalling?</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> You
bet.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Still, while <b>loop</b>
may not be much faster than other branching instructions, it is
nonetheless <i>somewhat</i> faster, and it's also more
compact. We
know we're losing a great deal of performance to the 8088's abysmal
branching speed, but there doesn't seem to be much we can do about
it.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> But
of course there is
something we can do, as is almost always the case with the 8088. Let's
look at exactly what <b>loop</b> is used for, and then
let's
see if we can produce the same functionality in a different way.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Well, <b>loop</b> is
used to repeat a given sequence of instructions multiple times...and
that's about all. What can we do with that job description?</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Heck, that's <i>easy</i>. We'll eliminate branching and
loop counting entirely by <i>literally</i>
repeating the instructions, as shown in Figure 13.10. </font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_m31ff0de9.jpg" align="bottom" border="0" height="447" width="614"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">Instead
of using <b>loop</b>
to execute the same code, say, 10 times, we'll just line up 10
repetitions of the code inside the loop, and then execute the 10
repetitions one after another. This is known as <i>in-line code</i>,
because the repetitions of the code are lined up in order rather than
being separated by branches. (In-line code is sometimes used to
refer to subroutine code that's brought into the main code,
eliminating a call, a technique we discussed in the last section.
However, I'm going to use the phrase "in-line code" only to
refer to code that's repeated by assembling multiple instances and
running them back-to-back rather than in a loop.)</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <a class="western" href="#L1320">Listing
13-20</a> shows in-line code used to speed up <a class="western" href="#L1319">Listing
13-19</a>. The <b>loop</b> instruction is gone,
replaced with a <b>rept</b>
directive that creates 100 back-to-back instances of the code inside
the loop of <a class="western" href="#L1319">Listing
13-19</a>. The
performance improvement is dramatic: <a class="western" href="#L1320">Listing
13-20</a> runs in 557 us, more than 83% faster than <a class="western" href="#L1319">Listing
13-19</a>.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Often-enormous
improvement in performance is the good news about in-line code.
Often-enormous increase in code size &#8212; depending on the number
of repetitions and the amount of code in the loop &#8212; is the bad
news. <a class="western" href="#L1320">Listing
13-20</a> is nearly
300 bytes larger than <a class="western" href="#L1319">Listing
13-19</a>. On the other hand, we're talking about nearly doubling
performance
by adding those extra bytes. Yes, once again we've encountered the
trade-off between bytes and cycles that pops up so often when we set
out to improve performance: in-line code can be used to speed up
just about any loop, but the cost in bytes ranges from modest to
prohibitively high. Still, when you need flat-out performance,
in-line code is a tried and true way to get a sizable performance
boost.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">In-line code has
another benefit beside eliminating branching. When in-line code is
used, CX (or whatever register would otherwise have been used as a
loop counter) is freed up. An extra 16-bit register is always welcome
in high-performance code.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> You
may well object at
this point that in-line code is fine when the number of repetitions
of a loop is known in advance and is always the same, but how often
is that the case? Not all that often, I admit, but it does happen. For
example, think back to our animation examples in Chapter 11. The
example that used exclusive-or-based animation looped once for each
word exclusive-ored into display memory, and always drew the same
number of words per line. That sounds like an excellent candidate
for in-line code, and in fact it is.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <a name="L1321R"></a><a class="western" href="#L1321">Listing
13-21</a> shows the <b>XorImage</b> subroutine from <a class="western" href="#L1133">Listing
11-33</a> revised to use in-line code to draw each line without
branching. Instead, the four instructions that draw the four words
of the image are duplicated four times, in order to draw a whole line
at a time. This frees up not only CX but also BP, which in <a class="western" href="#L1133">Listing
11-33</a> was used to reload the number of words per line each
time
through the loop. That has a ripple effect which lets us avoid using
BX, saving a <b>push</b> and a <b>pop</b>,
and also allows us to
store the offset from odd lines to even lines in a register for added
speed.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
net effect of the
in-line code in <a class="western" href="#L1321">Listing
13-21</a> is
far from trivial. When this version of <b>XorImage</b> is
substituted for the version in <a class="western" href="#L1133">Listing
11-33</a>, execution time drops from 30.29 seconds to 24.21
seconds,
a 25% improvement in overall performance. Put another way, the <b>loop</b>
instructions in the two loops that draw the even and odd lines in
<a class="western" href="#L1133">Listing 11-33</a>
take up about one
out of every five cycles that the entire program uses! Bear in mind
that we're not talking now about a program that zeros the high bits
of bytes in three-instruction loops; we're talking about a program
that performs complex animation and accesses display memory
heavily...in other words, a program that does many time-consuming
things besides looping.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> To
drive the point
home, let's modify <a class="western" href="#L1134">Listing
11-34</a>
to use in-line code, as well. <a class="western" href="#L1134">Listing
11-34</a> uses <b>rep movsw</b> to draw each line,
so there are no
branches to get rid of during line drawing, and consequently no way
to put in-line code to work there. There is, however, a loop that's
used to repeat the drawing of each pair of rows in the image. That's
not <i>nearly</i> so intensive a loop as the line-drawing
loop was in
<a class="western" href="#L1133">Listing 11-33</a>;
instead of being
repeated once for every word that's drawn, it's repeated just once
every two lines, or 10 words.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Nonetheless, when the
in-line version of <b>BlockDrawImage</b> shown in <a name="L1322R"></a><a class="western" href="#L1322">Listing
13-22</a> is substituted for the version in <a class="western" href="#L1134">Listing
11-34</a>, overall execution time drops from 10.35 seconds to
9.69
seconds, an improvement of nearly 7%. Not earthshaking &#8212; but
in demanding applications such as animation, where every cycle
counts, it's certainly worth expending a few hundred extra bytes to
get that extra speed.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
7% improvement we
got with <a class="western" href="#L1322">Listing
13-22</a> is more
impressive when you consider that the bulk of the work in <a class="western" href="#L1134">Listing
11-34</a> is done with <b>rep movsw</b>. If you take
a moment to
contemplate the knowledge that 7% of overall execution time in
<a class="western" href="#L1134">Listing 11-34</a>
is used by just 20
<b>dec dx</b>/<b>jnz</b> pairs per image draw
(and remember that
cycle-eating display memory is accessed 400 times for every 20 <b>dec
dx</b>/<b>jnz</b> pairs executed), you'll probably
reach the
conclusion that <b>loop</b> really isn't a very good
instruction for
high-performance looping.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> And
you'll be right.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_BRANCHED-TO_IN-LINE_CODE:"></a><a class="western" href="#T1307"><font size="4"><b>BRANCHED-TO
IN-LINE CODE: FLEXIBILITY NEEDED AND FOUND</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">What we've just seen
is "pure" in-line code, where a loop that's always repeated
a fixed number of times is converted to in-line code by simply
repeating the contents of the loop however many times the loop was
repeated. The above animation examples notwithstanding, pure in-line
code isn't used very often. Why? Because loops rarely repeat a fixed
number of times, and pure in-line code isn't flexible enough to
handle a variable number of repetitions. With pure in-line code, if
you put five repetitions of a loop in-line, you'll always get five
repetitions, no more and no less. Most looping applications demand
more flexibility than that.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> As
it turns out,
however, it's no great trick to modify pure in-line code to replace
loops that repeat a variable number of times, so long as you know the
maximum number of times you'll ever want to repeat the loop. The
basic concept is shown in Figure 13.11. </font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_m1b4015f1.jpg" align="bottom" border="0" height="752" width="610"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">The
loop code is
repeated in-line as many times as the maximum possible number of loop
repetitions. Then the specified repetition count is used to jump
right into the in-line code at the distance from the end of the
in-line code that will produce the desired number of repetitions. This
mechanism, known as <i>branched-to in-line code</i>, is
almost
startlingly simple, but powerful nonetheless.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Let's convert the
in-line code example of <a class="western" href="#L1320">Listing
13-20</a> to use branched-to in-line code. <a name="L1323R"></a><a class="western" href="#L1323">Listing
13-23</a> shows this implementation. First, in-line code to
support
up to the maximum possible number of repetitions (in this case, 200)
is created with <b>rept</b>. Then the start offset in the
in-line
code that will result in the desired number of repetitions is
calculated, by multiplying the number of instruction bytes per
repetition by the desired number of repetitions, and subtracting the
result from the offset of the end of the table. As a result, <a class="western" href="#L1323">Listing
13-23</a> can handle any number of repetitions between 0 and 200,
and
does so with just one branch, the <b>jmp cx</b> that
branches into
the in-line code.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
performance price
for the flexibility of <a class="western" href="#L1323">Listing
13-23</a>
is small; the code runs in 584 us, just 27 us slower than <a class="western" href="#L1320">Listing
13-20</a>. Moreover, <a class="western" href="#L1323">Listing
13-23</a>
could be speeded up a bit by multiplying by 3 with a shift-and-add
sequence rather than the notoriously slow <b>mul</b>
instruction; I
used <b>mul</b> in order to illustrate the general case
and because I
didn't want to obscure the workings of branched-to in-line code.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Branched-to in-line
code retains almost all of the performance advantages of in-line
code, without the inflexibility. Branched-to in-line code does
everything <b>loop</b> does, and does it without branching
inside the
loop. Branched-to in-line code is sort of the poor man's <b>rep</b>,
capable of repeating any instruction or sequence of instructions
without branching, just as <b>rep</b> does for string
instructions. It's true that branched-to in-line code doesn't really
eliminate the
prefetch-queue cycle-eater as <b>rep</b> does, since each
instruction
byte in branched-to in-line code must still be fetched. On the other
hand, it's also true that branched-to in-line code eliminates the
constant prefetch-queue flushing of <b>loop</b>, and
that's all to
the good.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In
short, branched-to
in-line code allows repetitive processing based on non-string
instructions to approach its performance limits on the 8088 by
eliminating branching, thereby doing away with not only the time
required to branch but also the nasty prefetch-queue effects of
branching. When you need flat-out speed for repetitive tasks,
branched-to in-line code is often a good bet.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">That's not to say that
branched-to in-line code is perfect. The hitch is that you must allow
for the maximum number of repetitions when setting up branched-to
in-line code. If you're performing checksums on data blocks no
larger than 64 bytes, the maximum size is no problem, but if you're
working with large arrays, the maximum size can easily be either
unknown or so large that the resulting in-line code would simply be
too large to use. For example, the in-line code in <a class="western" href="#L1323">Listing
13-23</a> is 600 bytes long, and would swell to 60,000 bytes long
if
the maximum number of repetitions were 20,000 rather than 200. In-line
code can also become too large to be practical after just a
few repetitions if the code to be repeated is lengthy. Finally,
lengthy branched-to in-line code isn't well-suited for tasks such as
scanning arrays, since the in-line code can easily be too long to
allow the 1-byte displacements of conditional jumps to branch out of
the in-line code when a match is found.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Clearly, branched-to
in-line code is not the ideal solution for all situations. Branched-to
in-line code is great if both the maximum number of
repetitions and the code to be repeated are small, or if performance
is so important that you're willing to expend a great many bytes to
speed up your code. For applications that don't fit within those
parameters, however, a still more flexible in-line solution is
needed.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Which brings us to
partial in-line code.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_PARTIAL_IN-LINE_CODE"></a><a class="western" href="#T1307"><font size="4"><b>PARTIAL
IN-LINE CODE</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <i>Partial
in-line
code</i> is a hybrid of normal looping and pure in-line code.
Partial in-line code performs a few repetitions back-to-back without
branching, as in-line code does, and then loops. As such, partial
in-line code offers much of the performance improvement of in-line
code, along with much of the compactness of normal loops. While
partial in-line code isn't as fast as pure or branched-to in-line
code, it's still fast, and because it's relatively compact, it
overcomes most of the size-related objections to in-line code.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Let's go back to our
familiar example of zeroing the high bit of each byte in an array to
see partial in-line code in action. In <a class="western" href="#L1319">Listing
13-19</a> we saw this example implemented with a loop, in <a class="western" href="#L1320">Listing
13-20</a> we saw it implemented with pure in-line code, and in
<a class="western" href="#L1323">Listing 13-23</a>
we saw it
implemented with branched-to in-line code. <a name="L1324R"></a><a class="western" href="#L1324">Listing
13-24</a> shows yet another version, this time using partial
in-line
code.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
key to <a class="western" href="#L1324">Listing
13-24</a> is that it performs four in-line bit-clears, then
loops. This means that <a class="western" href="#L1324">Listing
13-24</a>
loops just once for every four bits cleared. While that means that
<a class="western" href="#L1324">Listing 13-24</a>
still branches 25
times, that's 75 times fewer than the loop-only version, <a class="western" href="#L1319">Listing
13-19</a>, certainly a vast improvement. And while the <b>ClearHighBits</b>
subroutine is 13 bytes larger in <a class="western" href="#L1324">Listing
13-24</a> than in <a class="western" href="#L1319">Listing
13-19</a>,
it's nearly 300 bytes smaller than in the pure in-line version,
<a class="western" href="#L1320">Listing 13-20</a>.
If <a class="western" href="#L1324">Listing
13-24</a> can run anywhere near as fast as <a class="western" href="#L1320">Listing
13-20</a>, it'll be a winner.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <a class="western" href="#L1324">Listing
13-24</a> is indeed a winner, running in 688 us. That's certainly
slower than pure in-line code &#8212; <a class="western" href="#L1320">Listing
13-20</a> is about 24% faster &#8212; but it's a whole lot faster
than pure looping. <a class="western" href="#L1324">Listing
13-24</a>
outperforms <a class="western" href="#L1319">Listing
13-19</a> by
close to 50% &#8212; <i>at a cost of just 13 bytes</i>. That's a
terrific return for the extra bytes expended, proportionally much
better than the 83% improvement <a class="western" href="#L1320">Listing
13-20</a> brings at a cost of 295 bytes. To put it another way,
in
this example the performance improvement of partial in-line code over
pure looping is about 49%, at a cost of 13 bytes, while the
improvement of pure in-line code over partial in-line code is only
24%, at a cost of 282 bytes.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> If
you need absolute
maximum speed, in-line code is the ticket...but partial in-line code
offers similar performance improvements in a far more generally
usable form. If size is your driving concern, then <b>loop</b>
is
the way to go.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> As
always, no one
approach is perfect in all situations. The three approaches to
handling repetitive code that we've discussed &#8212; in-line code,
partial in-line code, and looping &#8212; give you a solid set of
tools to use for handling repetitive tasks, but it's up to you to
evaluate the trade-offs between performance, size, and program
complexity and then select the proper techniques for your particular
applications. There are no easy answers in top-notch assembler
programming &#8212; but at least now you have a set of tools with
which to craft good solutions.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">There are many, many
ways to use in-line code. We've seen some already, we'll see more
over the remainder of this chapter, and you'll surely discover others
yourself. Whenever you must loop in time-critical code, take a
moment to see if you can't use in-line code in one of its many forms
instead.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
rewards can be
rich indeed.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_PARTIAL_IN-LINE_CODE:"></a><a class="western" href="#T1307"><font size="4"><b>PARTIAL
IN-LINE CODE: LIMITATIONS AND WORKAROUNDS</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
partial in-line
code implementation in <a class="western" href="#L1324">Listing
13-24</a>
is somewhat more flexible than the pure in-line code implementation
in <a class="western" href="#L1320">Listing 13-20</a>,
but not by
much. The partial in-line code in <a class="western" href="#L1324">Listing
13-24</a> is capable of handling only repetition counts that
happen
to be multiples of four, since four repetitions are performed each
time through the loop. That's fine for repetitive tasks that always
involve repetition counts that happen to be multiples of four;
unfortunately, such tasks are the exception rather than the rule. In
order to be generally useful, partial in-line code must be able to
support any number of repetitions at all.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> As
it turns out,
that's not a problem. The flexibility of branched-to in-line code
can easily be coupled with the compact size of partial in-line code. As
an example, let's modify the branched-to in-line code of <a class="western" href="#L1323">Listing
13-23</a> to use partial in-line code.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
basic principle
when branching into partial in-line code is similar to that for
standard branched-to in-line code. The key is still to branch to the
location in the in-line code from which the desired number of
repetitions will occur. The difference with branched-to partial
in-line code is that the branching-to process only needs to handle
any odd repetitions that can't be handled by a full loop, as shown in
Figure 13.12. </font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_m58b4ccfe.jpg" align="bottom" border="0" height="657" width="612"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">In
other words, if
partial in-line code performs <i>n</i> repetitions per
loop and we
want to perform <i>m</i> repetitions, the branching-to
process only
needs to handle <i>m</i> modulo <i>n</i>
repetitions.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> For
example, if we
want to perform 15 repetitions with partial in-line code that
performs 4 repetitions per loop, we need to branch so as to perform
the first 15 modulo 4 = 3 repetitions during the first, partial pass
through the loop. After that, 3 full passes through the loop will
handle the other 12 repetitions.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <a name="L1325R"></a><a class="western" href="#L1325">Listing
13-25</a>, a branched-to partial in-line code version of our
familiar
bit-clearing example, should help to make this clear. The version of
<b>ClearHighBits</b> in <a class="western" href="#L1325">Listing
13-25</a> first calculates the number of repetitions modulo 4.
Since
each pass through the loop performs 4 repetitions, the number of
repetitions modulo 4 is the number of repetitions to be performed on
the first, partial pass through the loop in order to handle
repetition counts that aren't multiples of 4. <a class="western" href="#L1325">Listing
13-25</a> then uses this value to calculate the offset in the
partial
in-line code to branch to in order to cause the correct number of
repetitions to occur on that first pass.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Incidentally,
multiplication by 3 in <a class="western" href="#L1325">Listing
13-25</a>
is performed not with <b>mul</b>, but with a much faster
shift-and-add sequence. As we mentioned earlier, the same could have
been done in <a class="western" href="#L1323">Listing
13-23</a>, but
<b>mul</b> was used there in order to handle the general
case and
avoid obscuring the mechanics of the branching-to process. In the
next chapter we'll see a jump-table-based approach that does away
with the calculation of the target offset in the in-line code
entirely, in favor of simply looking up the target address.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Next, <a class="western" href="#L1325">Listing
13-25</a> divides the repetition count by 4, since 4 repetitions
are
performed each time through the loop. That value must then be
incremented to account for the first pass through the loop &#8212;
and that's it! All we need do is branch to the correct location in
the partial in-line code and let it rip. And rip it does, with
<a class="western" href="#L1325">Listing 13-25</a>
running in just
713 us. Yes, that is indeed considerably slower than the 584 us time
of the branched-to in-line code of <a class="western" href="#L1323">Listing
13-23</a>, but it's much faster than the 1023 us of <a class="western" href="#L1319">Listing
13-19</a>. Then, too, <a class="western" href="#L1325">Listing
13-25</a>
is only 32 bytes larger than <a class="western" href="#L1319">Listing
13-19</a>, while <a class="western" href="#L1323">Listing
13-23</a>
is more than 600 bytes larger.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <a class="western" href="#L1325">Listing
13-25</a>, the branched-to partial in-line code, has an
additional
advantage over <a class="western" href="#L1323">Listing
13-23</a>,
the branched-to in-line code, and that's the ability to handle an
array of <i>any</i> size up to 64 K-1. With in-line code,
the
largest number of repetitions that can be handled is determined by
the number of times the code is physically repeated. Partial in-line
code suffers from no such restriction, since it loops periodically. In
fact, branched-to partial in-line code implementations can handle
any case normal loops can handle, tend to be only a little larger,
and are much faster for all but very small repetition counts.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <a class="western" href="#L1325">Listing
13-25</a> itself isn't <i>quite</i> equivalent to a <b>loop</b>-based
loop. Given an initial count of zero, <b>loop</b> performs
64 K
repetitions, while <a class="western" href="#L1325">Listing
13-25</a>
performs 0 repetitions in the same case. That's not necessarily a
disadvantage; <b>loop</b>-based loops are often preceded
with <b>jcxz</b>
in order to cause zero counts to produce 0 repetitions. However,
<a class="western" href="#L1325">Listing 13-25</a>
can easily be
modified to treat an initial count of zero as 64 K; I chose to
perform 0 repetitions given a zero count in <a class="western" href="#L1325">Listing
13-25</a> only because it made for code that was easier to
explain
and understand. <a name="L1326R"></a><a class="western" href="#L1326">Listing
13-26</a>
shows the <b>ClearHighBits</b> subroutine of <a class="western" href="#L1325">Listing
13-25</a> modified to perform 64 K repetitions given an initial
count
of zero.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">It's worth noting that
the <b>inc ax</b> in <a class="western" href="#L1326">Listing 13-26</a>
could be eliminated if the line:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov dx,offset
InLineBitClearEnd</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">were
changed to:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov dx,offset
InLineBitClearEnd-3</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">This
change has no
effect on overall functionality, because the net effect of <b>inc
ax</b>
in <a class="western" href="#L1326">Listing 13-26</a>
is merely to
subtract 3 from the offset of the end of the partial in-line code. I
omitted this optimization in the interests of making <a class="western" href="#L1326">Listing
13-26</a> comprehensible, but as a general practice arithmetic
should
be performed at assembly time rather than at run time whenever
possible.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> By
the way, there's
nothing special about using 4 repetitions in partial in-line code. 8
repetitions or even 16 could serve as well, and, in fact, speed
increases as the number of partial in-line repetitions increases.
However, size increases proportionately as well, offsetting part of
the advantage of using partial in-line code. Partial in-line code
using 4 repetitions strikes a nice balance between size and speed,
eliminating 75% of the branches without adding too many instruction
bytes.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_PARTIAL_IN-LINE_CODE_1"></a><a class="western" href="#T1307"><font size="4"><b>PARTIAL
IN-LINE CODE AND STRINGS: A GOOD MATCH</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> One
case in which the
poor repetition granularity of partial in-line code (that is, the
inability of partial in-line loops to deal unaided with repetition
counts that aren't exact multiples of the number of repetitions per
partial in-line loop) causes no trouble at all is in handling
zero-terminated strings. Since there is no preset repetition count
for processing such strings, it doesn't matter in the least that the
lengths of the strings won't always be multiples of the number of
repetitions in a single partial in-line loop. When handling
zero-terminated strings, it doesn't matter if the terminating
condition occurs at the start of partial in-line code, the end, or
somewhere in-between, since a conditional jump will branch out
equally well from anywhere in partial in-line code. As a result,
there's no need to branch into partial in-line code when handling
zero-terminated strings.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> As
usual, an example
is the best explanation. Back in <a class="western" href="#L1125">Listing
11-25</a>, we used <b>lodsw</b> and <b>scasw</b>
inside a loop to
find the first difference between two zero-terminated strings. We
used word &#8212; rather than byte-sized string instructions to speed
processing; interestingly, much of the improvement came not from
accessing memory a word at a time but rather from cutting the number
of loops in half, since two bytes were processed per loop. We're
going to use partial in-line code to speed up <a class="western" href="#L1125">Listing
11-25</a> further by eliminating still more branches.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <a name="L1327R"></a><a class="western" href="#L1327">Listing
13-27</a> is our partial in-line version of <a class="western" href="#L1125">Listing
11-25</a>. I've chosen a repetition granularity of 8 repetitions
per
loop both for speed and to show you that granularities other than 4
can be used. There's no need to add code to branch into the partial
in-line code, since there's no repetition count for a zero-terminated
string. Note that I've separated the eighth repetition of the
partial in-line code from the first seven, so that the eighth
repetition can jump directly back to the top of the loop if it
doesn't find the terminating zero. If I lumped all 8 repetitions
together in a <b>rept</b> block, an unconditional jump
would have to
follow the partial in-line code in order to branch back to the top of
the loop. While that would work, it would result in a conditional
jump/unconditional jump pair...and well we know to steer clear of
those when we're striving for top performance.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <a class="western" href="#L1327">Listing
13-27</a> runs in 278 us, 10% faster than <a class="western" href="#L1125">Listing
11-25</a>. Considering how heavily optimized <a class="western" href="#L1125">Listing
11-25</a> already was, what with the use of word-sized string
instructions, that's a healthy improvement. What's more, <a class="western" href="#L1327">Listing
13-27</a> isn't markedly more complicated than <a class="western" href="#L1125">Listing
11-25</a>; actually, the only difference is that the contents of
the
loop are repeated 8 times rather than once.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> As
you can see,
partial in-line code is ideal for the handling of zero-terminated
strings. Once again, partial in-line code is a poor man's <b>rep</b>;
in fact, in string and similar applications, you might think of
partial in-line code as a substitute for the sorely-missed <b>rep</b>
prefix for the flexible but slow <b>lods</b>/<b>stos</b>
and
<b>lods</b>/<b>scas</b> instruction pairs.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_LABELS_AND_IN-LINE"></a><a class="western" href="#T1307"><font size="4"><b>LABELS
AND IN-LINE CODE</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">That just about does
it for our discussion of in-line code. However, there's one more
in-line code item we need to discuss, and that's the use of labels in
in-line code.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Suppose that for some
reason you need to use a label somewhere inside in-line code. For
example, consider the following:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> rept 4</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> lodsb</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> cmp al,'a'</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jb NotUppercase</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> cmp al,'z'</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ja NotUppercase</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> and al,not
20h</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>NotUppercase:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> stosb</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> endm</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">In
this example, the
label <b>NotUppercase</b> is inside in-line code used to
convert 4
characters in a row to uppercase. While the code seems simple
enough, it nonetheless has one serious problem:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> It
won't assemble.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Why
is that? The
problem is that the line defining the label is inside a <b>rept</b>
block, so it's literally assembled multiple times. As it would at
any time, MASM complains when asked to define two labels with the
same name.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
solution should be
straightforward: declare the label local to the <b>rept</b>
block
with the <b>local</b> directive, which exists for just
such
emergencies. For example, the following code should do the trick:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> rept 4</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> local NotUppercase</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> lodsb</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> cmp al,'a'</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jb NotUppercase</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> cmp al,'z'</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ja NotUppercase</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> and al,not
20h</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>NotUppercase:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> stosb</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> endm</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">It
should &#8212; but
it doesn't, at least not with MASM 5.0. While the <b>local</b>
directive does indeed solve our problem when assembled with TASM, it
just doesn't work correctly when assembled with MASM 5.0. There's no
use asking why &#8212; the bugs and quirks of MASM are just a fact of
life in assembler programming.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> So,
what's the
solution to our local label problem when using MASM? One possibility
is counting bytes and jumping relative to the program counter, as in:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> rept 4</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> lodsb</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> cmp al,'a'</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jb $+8</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> cmp al,'z'</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ja $+4</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> and al,not
20h</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> stosb</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> endm</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">It's
not elegant, but
it does work. Another possibility is defining a macro that contains
the code in the <b>rept</b> block, since <b>local</b>
<i>does</i>
work in macros. For example, the following assembles properly under
MASM 5.0:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>MAKE_UPPER macro</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> local NotUppercase</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> lodsb</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> cmp al,'a'</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jb NotUppercase</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> cmp al,'z'</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ja NotUppercase</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> and al,not
20h</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>NotUppercase:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> stosb</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> endm</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> :</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> rept 4</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> MAKE_UPPER</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> endm</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h2 class="western"><font color="#110d06"><font color="#0b0703"><a name="C138"></a><a class="western" href="#T1308"><font style="font-size: 16pt;" size="4"><b>13.8
A NOTE ON SELF-MODIFYING CODE</b></font></a></font></font></h2>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Just so you won't
think I've forgotten about it, let's briefly discuss self-modifying
code. For those of you unfamiliar with this demon of modern
programming, self-modifying code is a once-popular coding technique
whereby a program modifies its own code &#8212; changes its own
instruction bytes &#8212; on the fly in order to alter its operation
without the need for tests and branches. (Remember how back in
Chapter 3 we learned that code is just one kind of data? Self-modifying
code is a logical extension of that concept.) Nowadays, self-modifying
code is strongly frowned-upon, on the
grounds that it makes for hard-to-follow, hard-to debug programs.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">"Frowned upon,
eh?" you think. "Sounds like fertile ground for a little
Zen programming, doesn't it?" Yes, it does. Nonetheless, I
<i>don't</i> recommend that you use self-modifying code, at
least not
self-modifying code in the classic sense. Not because it's
frowned-upon, of course, but rather because I haven't encountered any
cases where in-line code, look-up tables, jump vectors, jumping
through a register or some other 8088 technique didn't serve just
about as well as self-modifying code.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Granted, there may be
a small advantage to, say, directly modifying the displacement in a
<b>jmp</b> instruction rather than jumping to the address
stored in a
word-sized memory variable, but in-line code really <i>is</i>
hard to
debug and follow, and is hard to write, as well (consider the
complexities of simply calculating a jump displacement). I haven't
seen cases where in-line code brings the sort of significant
performance improvement that would justify its drawbacks. That's not
to say such cases don't exist; I'm sure they do. I just haven't
encountered them.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Self-modifying code
has an additional strike against it in the form of the prefetch
queue. If you modify an instruction byte after it's been fetched by
the Bus Interface Unit, it's the original, unmodified byte that's
executed, since that's the byte that the 8088 read. That's
particularly troublesome because the various members of the 8086
family have prefetch queues of differing lengths, so self-modifying
code that works on the PC might not work at all on an AT or a Model
80. A branch always empties the prefetch queue and forces it to
reload, but even that might not be true with future 8086-family
processors.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> To
sum up, my
experience is that in the context of the 8086 family, self-modifying
code offers at best small performance improvements, coupled with
significant risk and other drawbacks. That's not the case with some
other processors, especially those with less-rich instruction sets
and no prefetch queue. However, <i>The Zen of Assembly Language</i>
is concerned only with the 8086 family, and in that context my final
word on self-modifying code of the sort we've been discussing is:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Why
bother?</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> On
the other hand,
I've only been discussing self-modifying code in the classic sense,
where individual instructions are altered. For instance, the operand
to <b>cmp al,</b><i><b>immed8</b></i>
might be modified to change an
inclusion range; in such a case, why not just use <b>cmp al,</b><i><b>reg</b></i>
and load the new range bound into the appropriate register? It's
simpler, easier to follow, and actually slightly faster.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">There's another sort
of self-modifying code, however, that operates on a grander scale.
Consider a program that uses code overlays. Code is swapped in from
disk to memory and then executed; obviously the instruction bytes in
the overlay region are changed, so that's self-modifying code. Or
consider a program that builds custom code for a special, complex
purpose in a buffer and then executes the generated code; that's
self-modifying code as well. Some programs are built out of
loosely-coupled, relocatable blocks of code residing in a heap under
a memory manager, with the blocks moved around memory and to and from
disk as they're needed; that's certainly self-modifying code, in the
sense that the instructions stored at particular memory locations
change constantly. Finally, loadable drivers, such as graphics
drivers for many windowing environments, are self-modifying code of a
sort, since they are loaded as data from the disk into memory by the
driver-based program and then executed.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> My
point is that you
shouldn't think of code as immovable and unchangeable. I've found
that it's not worth the trouble and risk to modify individual
instructions, but in large or complex programs it can be most
worthwhile to treat blocks of code as if they were data. The topic
is a large one, and this is not the place to explore it, but always
keep in mind that even if self-modifying code in its classic sense
isn't a great idea on the 8088, the notion that code is just another
sort of data is a powerful and perfectly valid concept.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_CONCLUSION_1"></a><a class="western" href="#T1308"><font size="4"><b>CONCLUSION</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Who
would have thought
that not-branching could offer such variety, to say nothing of such
substantial performance improvements? You'll find that not-branching
is an excellent exercise for developing your assembler skills,
requiring as it does a complete understanding of what your code needs
to do, thorough knowledge of the 8088 instruction set, the ability to
approach programming problems in non-intuitive ways, knowledge as to
when the effort involved in not-branching is justified by the return,
and a balancing of relative importance of saving bytes and cycles in
a given application.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In
other words,
not-branching is a perfect Zen exercise. Practice it often and well!</font></font></p>
