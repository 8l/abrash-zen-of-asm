<h1 class="western" style="page-break-before: always;"><font color="#110d06"><font color="#0b0703"><a name="_Chapter_11:_"></a><a class="western" href="#TC11"><font size="5"><b>Chapter
11: String Instruction Applications</b></font></a></font></font></h1>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<table style="width: 578px; height: 269px;" border="1" bordercolor="#bfbfbf" cellpadding="4" cellspacing="0" frame="void" rules="groups">
<col width="617"> <tbody>
<tr>
<td bgcolor="#bfbfbf" width="617">
<p class="western"><b>11.1 </b><a class="western" href="#_STRING_HANDLING_WITH">STRING
HANDLING WITH lods AND stos</a></p>
</td>
</tr>
</tbody> <tbody>
<tr>
<td bgcolor="#bfbfbf" width="617">
<p class="western"><b>11.2 </b><a class="western" href="#_BLOCK_HANDLING_WITH">BLOCK
HANDLING WITH movs</a></p>
</td>
</tr>
</tbody> <tbody>
<tr>
<td bgcolor="#bfbfbf" width="617">
<p class="western"><b>11.3 </b><a class="western" href="#_SEARCHING_WITH_scas">SEARCHING
WITH scas</a></p>
</td>
</tr>
</tbody> <tbody>
<tr>
<td bgcolor="#bfbfbf" width="617">
<p class="western"><b>11.4 </b><a class="western" href="#_COMPARING_MEMORY_TO">COMPARING
MEMORY TO MEMORY WITH cmps</a></p>
</td>
</tr>
<tr>
<td bgcolor="#bfbfbf" width="617">
<p class="western"><b>11.5 </b><a class="western" href="#_A_NOTE_ABOUT">A NOTE ABOUT
RETURNING VALUES</a></p>
</td>
</tr>
<tr>
<td bgcolor="#bfbfbf" width="617">
<p class="western"><b>11.6 </b><a class="western" href="#_PUTTING_STRING_INSTRUCTION">PUTTING
STRING INSTRUCTIONS TO WORK IN UNLIKELY PLACES</a></p>
</td>
</tr>
<tr>
<td bgcolor="#bfbfbf" width="617">
<p class="western"><b>11.7 </b><a class="western" href="#_A_NOTE_ON">A NOTE ON HANDLING
BLOCKS LARGER THAN 64 K BYTES</a></p>
</td>
</tr>
</tbody>
</table>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Now
that we've got a
solid understanding of what the string instructions do, let's look at
a few applications to get a sense of what they're particularly good
for. The applications we'll look at include copying arrays,
searching strings for characters, looking up entries in tables,
comparing strings, and animation.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">There's a lot of meat
in this chapter, and a lot of useful code. The code isn't fully
fleshed out, since I'm trying to illustrate basic principles rather
than providing you with a library from A to Z, but that's actually
all to the good. You can build on this code to meet your specific
needs or write your own code from scratch once you understand the ins
and outs of the string instructions. In either case, you'll be
better off with code customized to suit your purposes than you would
be using any one-size-fits-all code I could provide.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">I'll frequently
contrast the string instruction-based implementations with versions
built around non-string instructions. This should give you a greater
appreciation for the string instructions, and may shed new light on
the non-string instructions as well. I'll tell you ahead of time how
the comparisons will turn out: in almost every case the string
instructions will prove to be vastly superior. The lesson we learned
in the last chapter holds true: <i>use the string instructions
to
the hilt!</i> There's nothing like them under the (8088) sun.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Contrasting string and
non-string implementations also reinforces an important point. There
are many, many ways to accomplish any given task on the 8088. It's
knowing which approach to choose that separates the journeyman
programmer from the guru.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h2 class="western"><font color="#110d06"><font color="#0b0703"><a name="_STRING_HANDLING_WITH"></a><a class="western" href="#T1101"><font style="font-size: 16pt;" size="4"><b>11.1
STRING HANDLING WITH lods AND stos</b></font></a></font></font></h2>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <b>lods</b>
is an odd
bird among string instructions, being the only string instruction
that doesn't benefit in the least from <b>rep</b>. While <b>rep</b>
does work with <b>lods</b>, in that it causes <b>lods</b>
to repeat
multiple times, the combination of the two is nonetheless totally
impractical: what good could it possibly do to load AL twice (to say
nothing of 64 K times)? Without <b>rep</b>, <b>lods</b>
is still
better than <b>mov</b>, but not <i>that</i>
much better; <b>lods</b>
certainly doesn't generate the quantum jump in performance that <b>rep
stos</b> and <b>rep movs</b> do. So &#8212; when <i>does</i>
<b>lods</b>
really shine?</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> It
turns out that <b>lods</b>
is what might be called a "synergistic" instruction, at its
best when used with <b>stos</b> (or sometimes <b>scas</b>,
or even
non-string instructions) in a loop. Together, <b>lods</b>
and <b>stos</b>
let you load an array or string element into AL, test and/or modify
it, and then write the element back to either the original array or a
new array, as shown in Figure 11.1.</font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_m585cbb52.jpg" align="bottom" border="0" height="676" width="603"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_m11586983.jpg" align="bottom" border="0" height="639" width="603"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> You
might think of the
<b>lods</b>-process-<b>stos</b> combination as
being a sort of
"meta-<b>movs</b>," whereby you can whip up customized
memory-to-memory moves as needed. Of course, <b>lods</b>/<b>stos</b>
is slower than <b>movs</b> (especially <b>rep movs</b>),
but by the
same token <b>lods</b>/<b>stos</b> is far more
flexible. Besides,
<b>lods</b>/<b>stos</b> isn't <i>that</i>
slow &#8212; <i>all</i> of
the 8088's memory-accessing instructions suffer by comparison with
<b>movs</b>. Placed inside a loop, the <b>lods</b>/<b>stos</b>
combination makes for fairly speedy array and string processing.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> For
example, <a name="L1101R"></a><a class="western" href="#L1101">Listing
11-1</a><font color="#000099"> </font>copies
a string to a new
location, converting all characters to uppercase in the process, by
using a loop containing <b>lods</b> and <b>stos</b>.
<a class="western" href="#L1101">Listing
11-1</a><font color="#000099"> </font>takes
just 773 us to copy and
convert. By contrast, <a name="L1102R"></a><a class="western" href="#L1102">Listing
11-2</a><font color="#000099">,</font>
which uses non-string instructions to perform the same task, takes
921 us to perform the copy and conversion.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> By
the way, <a class="western" href="#L1101">Listing
11-1</a><font color="#000099"> </font>could
just as easily have
converted <b>SourceString</b> to uppercase in place,
rather than
copying the converted text to <b>DestString</b>. This
would be
accomplished simply by loading both DS:SI and ES:DI to point to
<b>SourceString</b>, as shown in <a name="L1103R"></a><a class="western" href="#L1103">Listing
11-3</a><font color="#000099">,</font> which
changes nothing else
from <a class="western" href="#L1101">Listing 11-1</a><font color="#000099">.</font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Why
is this
interesting? It's interesting because two pointers &#8212; DS:SI and
ES:DI &#8212; are used to point to a single array. It's often faster
to maintain two pointers and use <b>lods</b> and <b>stos</b>
than it
is to use a single pointer with non-string instructions, as in
<a name="L1104R"></a><a class="western" href="#L1104">Listing 11-4</a>.
<a class="western" href="#L1103">Listing
11-3</a><font color="#000099"> </font>runs in
771 us, about the same
as <a class="western" href="#L1101">Listing 11-1</a><font color="#000099">
</font>(after all, they're virtually identical). However, <a class="western" href="#L1104">Listing
11-4</a> takes 838 us, even though it uses only one pointer to
point
to the array being converted to uppercase. </font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
<b>lods</b>/<b>stos</b>
pair lies somewhere between the repeated string instructions and the
non-string instructions in terms of performance and flexibility. <b>lods</b>/<b>stos</b>
isn't as fast as any of the repeated string
instructions, both because two instructions are involved and because
it can't be used with a <b>rep</b> prefix but must instead
be placed
in a loop. However, <b>lods</b>/<b>stos</b> is
a good deal more
flexible than any repeated string instruction, since once a memory
operand is loaded into AL or AX it can be tested and manipulated
easily (and often quickly as well, thanks to the accumulator-specific
instructions).</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> On
the other hand, the
<b>lods</b>/<b>stos</b> pair is certainly
faster than non-string
instructions, as <a class="western" href="#L1101">Listings
11-1</a>
through <a class="western" href="#L1104">11-4</a>
illustrate. However, <b>lods</b>/<b>stos</b>
is not as flexible as the non-string
instructions, since DS:SI and ES:DI must be used as pointer registers
and only the accumulator can be loaded from and stored to memory.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> On
balance, the
<b>lods</b>/<b>stos</b> pair overcomes some but
not all of the
limitations of repeated string instructions, and does so at a
substantial performance cost <i>vis-a-vis</i> the repeated
string
instructions. One thing that <b>lods</b>/<b>stos</b>
doesn't do
particularly well is modify memory directly. For example, suppose
that we want to set the high bit of every byte in a 1000-byte array. We
could of course do this with <b>lodsb</b> and <b>stosb</b>,
setting the high bit of each word while it's loaded into AL. <a name="L1105R"></a><a class="western" href="#L1105">Listing
11-5</a>, which does exactly that, takes 10.07 us per word.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">However, we could also
use a plain old <b>or</b> instruction working directly
with a memory
operand to do the same thing, as shown in <a name="L1106R"></a><a class="western" href="#L1106">Listing
11-6</a>. <a class="western" href="#L1106">Listing
11-6</a> is just
as fast as <a class="western" href="#L1105">Listing
11-5</a> at 10.06
us per word, and it's also considerably shorter at 13 rather than 21
bytes, with 1 less byte inside the loop. <b>lods</b>/<b>stos</b>
isn't <i>disastrously</i> worse in this case, but it
certainly isn't
the preferred solution &#8212; and there are plenty of other
situations in which <b>lods</b>/<b>stos</b> is
less than ideal.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> For
instance, when
registers are tight, the extra pointer register <b>lods</b>/<b>stos</b>
takes can be sorely missed. If the accumulator is reserved for some
specific purpose and can't be modified, <b>lods</b>/<b>stos</b>
can't
very well be used. If a pointer to far data is needed by other
instructions in the same routine, the limitation of <b>stos</b>
to
operating in the ES segment would become a burden. In other words,
while the <b>lods</b>/<b>stos</b> pair is more
flexible than the
repeated string instructions, its limitations are significant
nonetheless.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
point is not
simply that the <b>lods</b>/<b>stos</b> pair
is not as flexible as
the non-string instructions. The real point is that you shouldn't
assume you've come up with the best solution just because you've used
string instructions. Yes, I know that I've been touting string
instructions as the greatest thing since sliced bread, and by and
large that's true. However, because the string instructions have a
sharply limited repertoire and often require a good deal of
preliminary set-up, you must consider your alternatives before
concluding that a string instruction-based implementation is best. </font></font></p>
<h2 class="western"><font color="#110d06"><font color="#0b0703"><a name="_BLOCK_HANDLING_WITH"></a><a class="western" href="#T1102"><font style="font-size: 16pt;" size="4"><b>11.2
BLOCK HANDLING WITH movs</b></font></a></font></font></h2>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Simply put, <b>movs</b>
is the king of the block copy. There's no other 8088 instruction
that can hold a candle to <b>movs </b>when it comes to
copying blocks
of data from one area of memory to another. It does take several
instructions to set up for <b>movs</b>, so if you're only
moving a
few bytes and DS:SI and ES:DI don't happen to be pointing to your
source and destination, you might want to use a regular <b>mov</b>.
Whenever you want to move more than a few bytes, though, <b>movs</b>
&#8212; or better yet <b>rep movs</b> &#8212; is the ticket.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Let's look at the
archetypal application for <b>movs</b>, a subroutine which
copies a
block of memory from one memory area to another. What's special
about the subroutine we'll look at is that it handles copying a block
when the destination of the copy overlaps the source. This is a bit
tricky because the direction in which the copy must proceed &#8212;
from the start of the block toward the end, or vice-versa &#8212;
depends on the direction of overlap.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> If
the destination
block overlaps the source block and starts at a lower memory address
than the source block, then the copy can proceed in the normal
direction, from lower to higher addresses, as shown in Figure 11.2.</font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_m4967683f.jpg" align="bottom" border="0" height="592" width="592"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> If
the destination
block overlaps the source block and starts at a <i>higher</i>
address, however, the block must be copied starting at its highest
address and proceeding toward the low end, as shown in Figure 11.3. </font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_4ebb4d6c.jpg" align="bottom" border="0" height="520" width="604"></font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Otherwise, the first
data copied to the destination block would wipe out source data that
had yet to be copied, resulting in a corrupted copy, as shown in
Figure 11.4. </font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_1d07d5b2.jpg" align="bottom" border="0" height="611" width="613"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_4033a736.jpg" align="bottom" border="0" height="635" width="612"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">Finally,
if the blocks
don't overlap, the copy can proceed in either direction, since the
two blocks can't conflict.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
block-copy
subroutine <b>BlockCopyWithOverlap</b> shown in <a class="western" href="#L1107">Listing
11-7</a> handles potential overlap problems exactly as described
above. In cases where the destination block starts at a higher
address than the source block, <b>BlockCopyWithOverlap</b>
performs
an <b>std</b> and uses <b>movs</b> to copy
the source block starting
at the high end and proceeding to the low end. Otherwise, the source
block is copied from the low end to the high end with <b>cld</b>/<b>movs</b>.
<b>BlockCopyWithOverlap</b> is both remarkably compact and
very
fast, clocking in at 5.57 ms for the cases tested in <a name="L1107R"></a><a class="western" href="#L1107">Listing
11-7</a>. The subroutine could actually be more compact still,
but
I've chosen to improve performance at the expense of a few bytes by
copying as much of the block as possible a word rather than a byte at
a time.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">There are two points
of particular interest in <a class="western" href="#L1107">Listing
11-7</a>. First, <b>BlockCopyWithOverlap</b> only
handles blocks that
reside in the same segment, and then only if neither block wraps
around the end of the segment. While it would certainly be possible
to write a version of the subroutine that properly handled both
potentially overlapping copies between different segments and segment
wrapping, neither of those features is usually necessary, and the
additional code would reduce overall performance. If you need such a
routine, write it, but as a general practice don't write extra,
slower code just to handle cases that you can readily avoid.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Second,
<b>BlockCopyWithOverlap</b> nicely illustrates a nasty
aspect of the
use of word-sized string instructions when the Direction flag is set
to 1. The basic problem is this: if you point to the last byte of a
block of memory and perform a word-sized operation, the byte <i>after</i>
the end of the memory block will be accessed along with the last byte
of the block, rather than the last <i>two</i> bytes of the
block, as
shown in Figure 11.5.</font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_3818e417.jpg" align="bottom" border="0" height="551" width="602"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">This problem of
accessing the byte after the end of a memory block can occur with all
word-sized instructions, not just string instructions. However, it's
especially liable to happen with a word-sized string instruction
that's moving its pointer or pointers backward (with the Direction
flag equal to 1) because the temptation is to point to the end of the
block, set the Direction flag, and let the string instruction do its
stuff in repeated word-sized chunks for maximum performance. To
avoid this problem, you must always be sure to point to the last <i>word</i>
rather than byte when you point to the last element in a memory block
and then access memory with a word-sized instruction.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Matters get even more
dicey when byte-and word-sized string instructions are mixed when the
Direction flag is set to 1. This is done in <a class="western" href="#L1107">Listing
11-7</a> in order to use <b>rep movsw</b> to move
the largest
possible portion of odd-length memory blocks. The problem here is
that when a string instruction moves its pointer or pointers from
high addresses to low, the address of the next byte that we want to
access (with <b>lodsb</b>, for example) and the address of
the next
word that we want to access (with <b>lodsw</b>, for
example) differ,
as shown in Figure 11.6. </font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_m44dfcba3.jpg" align="bottom" border="0" height="405" width="608"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> For
a byte-sized
string instruction such as <b>lodsb</b>, we <i>do</i>
want to point
to the end of the array. After that <b>lodsb</b> has
executed with
the Direction flag equal to 1, though, where do the pointers point? To
the address 1 byte &#8212; not 1 word &#8212; lower in memory. Then what happens
when <b>lodsw</b> is executed as the next
instruction, with the intent of accessing the word just above the
last byte of the array? Why, the last byte of the array is
incorrectly accessed again, as shown in Figure 11.7.</font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_m2e2d3526.jpg" align="bottom" border="0" height="570" width="603"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_m7958b160.jpg" align="bottom" border="0" height="542" width="596"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
solution, as shown
in <a class="western" href="#L1107">Listing 11-7</a>,
is fairly
simple. We must perform the initial <b>movsb</b> and then
adjust the
pointers to point 1 byte lower in memory &#8212; to the start of the
next <i>word</i>. Only then can we go ahead with a <b>movsw</b>,
as
shown in Figure 11.8.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_4d73d7f5.jpg" align="bottom" border="0" height="579" width="620"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_madc04c0.jpg" align="bottom" border="0" height="626" width="590"></font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Mind you, all this
<i>only</i> applies when the Direction Flag is 1. When the
Direction
flag is 0, <b>movsb</b> and <b>movsw</b> can
be mixed freely, since
the address of the next byte is the same as the address of the next
word when we're counting from low addresses to high, as shown in
Figure 11.9. </font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_11bb1124.jpg" align="bottom" border="0" height="706" width="611"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><a class="western" href="#L1107">Listing
11-7</a> reflects this, since the pointer adjustments are only
made
when the Direction flag is 1.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <a name="L1108R"></a><a class="western" href="#L1108">Listing
11-8</a> contains a version of <b>BlockCopyWithOverlap</b>
that does
exactly what the version in <a class="western" href="#L1107">Listing
11-7</a> does, but does so without string instructions. While
<a class="western" href="#L1108">Listing 11-8</a>
doesn't <i>look</i>
all that much different from <a class="western" href="#L1107">Listing
11-7</a>, it takes a full 15.16 ms to run -quite change from the
time
of 5.57 ms we measured for <a class="western" href="#L1107">Listing
11-7</a>. Think about it: <a class="western" href="#L1107">Listing
11-7</a> is nearly <i>three times</i> as fast as <a class="western" href="#L1108">Listing
11-8</a>, thanks to <b>movs</b> &#8212; and it's shorter
too.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Enough said.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h2 class="western"><font color="#110d06"><font color="#0b0703"><a name="_SEARCHING_WITH_scas"></a><a class="western" href="#T1103"><font style="font-size: 16pt;" size="4"><b>11.3
SEARCHING WITH scas</b></font></a></font></font></h2>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <b>scas</b>
is often
(but not always, as we shall see) the preferred way to search for
either a given value or the absence of a given value in any array. When
<b>scas</b> is well-matched to the task at hand, it is the
best
choice by a wide margin. For example, suppose that we want to count
the number of times the letter 'A' appears in a text array. <a name="L1109R"></a><a class="western" href="#L1109">Listing
11-9</a>, which uses non-string instructions, counts the number
of
occurrences of 'A' in the sample array in 475 us. <a name="L1110R"></a><a class="western" href="#L1110">Listing
11-10</a>, which does exactly the same thing with <b>repnz
scasb</b>,
finishes in just 203 us. That, my friends, is an improvement of
134%. What's more, <a class="western" href="#L1110">Listing
11-10</a>
is shorter than <a class="western" href="#L1109">Listing
11-9</a>.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Incidentally, <a class="western" href="#L1110">Listing
11-10</a> illustrates the subtlety of the pitfalls associated
with
forgetting that <b>scas</b> repeated zero times (with CX
equal to
zero) doesn't alter the flags. If the <b>jcxz</b>
instruction in
<a class="western" href="#L1110">Listing 11-10</a>
were to be
removed, the code would still work perfectly &#8212; except when the
array being scanned was exactly 64 K bytes long and <i>every</i>
byte
in the array matched the byte being searched for. In that one case,
CX would be zero when <b>repnz scasb</b> was restarted
after the last
match, causing <b>repnz scasb</b> to drop through without
altering
the flags. The Zero flag would be 0 as a result of DX previously
incrementing from 0FFFFh to 0, and so the <b>jnz</b>
branch would not
be taken. Instead, DX would be incremented again, causing a
non-existent match to be counted. The result would be that 1 rather
than 64 K matches would be returned as the match count, an error of
considerable magnitude.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> If
you could be sure
that no array longer than 64 K-1 bytes would ever be passed to
<b>ByteCount</b>, you <i>could</i> eliminate
the <b>jcxz</b> and
speed the code considerably. Trimming the fat from your code until
it's matched exactly to an application's needs is one key to
performance.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_scas_AND_ZERO-TERMINATED"></a><a class="western" href="#T1103"><font size="4"><b>scas
AND ZERO-TERMINATED STRINGS</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Clearly, then, when
you want to find a given byte or word value in a buffer, table, or
array of a known fixed length, it's often best to load up the
registers and let a repeated <b>scas</b> do its stuff.
However, the
same is not always true of searching tasks that require multiple
comparisons for each byte or word, such as a loop that ends when
either the letter 'A' <i>or</i> a zero byte is found.
Alas, <b>scas</b>
can perform just one comparison per memory location, and <b>repz</b>
or <b>repnz</b> can only terminate on the basis of the
Zero flag
setting after that one comparison. This is unfortunate because
multiple comparisons are exactly what we need to handle C-style
strings, which are of no fixed length and are terminated with zeros. <b>rep
scas</b> can still be used in such situations, but its sheer
power is diluted by the workarounds needed to allow it to function
more flexibly than it is normally capable of doing. The choice
between repeated <b>scas</b> instructions and other
approaches then
must be made on a case-by-by case basis, according to the balance
between the extra overhead needed to coax <b>scas</b> into
doing what
is needed and the inherent speed of the instruction.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> For
example, suppose
we need a subroutine that returns either the offset in a string of
the first instance of a selected byte value or the value zero if a
zero byte (marking the end of the string) is encountered before the
desired byte is found. There's no simple way to do this with <b>scasb</b>,
for in this application we have to compare each memory location first
to the desired byte value and then to zero. <b>scasb</b>
can perform
one comparison or the other, but not both.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Now, we <i>could</i>
use <b>rep scasb</b> to find the zero byte at the end of
the string,
so we'd know how long the string was, and then use <b>rep scasb</b>
again with CX set to the length of the string to search for the
selected byte value. Unfortunately, that involves processing <i>every</i>
byte in the string once before even beginning the search. On
average, this double-search approach would read every element of the
string being searched once and would then read one-half of the
elements again, as shown in Figure 11.10. By contrast, an approach
that reads each byte and immediately compares it to both the desired
value <i>and</i> zero would read only one-half of the
elements in the
string, as shown in Figure 11.11. Powerful as repeated <b>scasb</b>
is, could it </font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_35084192.jpg" align="bottom" border="0" height="533" width="606"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_550a7781.jpg" align="bottom" border="0" height="368" width="606"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">possibly
run fast
enough to allow the double-search approach to outperform an approach
that accesses memory only one-third as many times?</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
answer is
yes...conditionally. The double-search approach actually <i>is</i>
slightly faster than a <b>lodsb</b>-based single-search
string-searching approach for the average case. The double-search
approach performs relatively more poorly if matches tend to occur
most frequently in the first half of the strings being searched, and
relatively better if matches tend to occur in the second half of the
strings. Also, the more flexible <b>lodsb</b>-based
approach rapidly
becomes the solution of choice as the termination condition becomes
more complex, as when a case-insensitive search is desired. The same
is true when modification as well as searching of the string is
desired, as when the string is converted to uppercase.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <a name="L1111R"></a><a class="western" href="#L1111">Listing
11-11</a> shows <b>lodsb</b>-based code that
searches a
zero-terminated string for the character 'z'. For the sample string,
which has the first match right in the middle of the string, <a class="western" href="#L1111">Listing
11-11</a> takes 375 us to find the match. <a name="L1112R"></a><a class="western" href="#L1112">Listing
11-12</a> shows <b>repnz scasb</b>-based code that
uses the
double-search approach. For the same sample string as <a class="western" href="#L1111">Listing
11-11</a>, <a class="western" href="#L1112">Listing
11-12</a> takes
just 340 us to find the match, despite having to perform about three
times as many memory accesses as <a class="western" href="#L1111">Listing
11-11</a> &#8212; a tribute to the raw </font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_m748dc944.jpg" align="bottom" border="0" height="515" width="596"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">power
of repeated <b>scas</b>. Finally, <a name="L1113R"></a><a class="western" href="#L1113">Listing 11-13</a>,
which
performs the same search using non-string instructions, takes 419 us
to find the match. </font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> It
is apparent from
<a class="western" href="#L1111">Listings 11-11</a>
and <a class="western" href="#L1112">11-12</a>
that the performance margin between <b>scas</b>-based
string
searching and other approaches is considerably narrower than it was
for array searching, due to the more complex termination conditions.
Given a still more complex termination condition, <b>lods</b>
would
likely become the preferred solution due to its greater flexibility. In
fact, if we're willing to expend a few bytes, the greater
flexibility of <b>lods</b> can be translated into higher
performance
for <a class="western" href="#L1111">Listings 11-11</a>,
as follows.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <a name="L1114R"></a><a class="western" href="#L1114">Listing
11-14</a> shows an interesting variation on <a class="western" href="#L1111">Listings
11-11</a>. Here <b>lodsw</b> rather than <b>lodsb</b>
is used, and
AL and AH, respectively, are checked for the termination conditions.
This technique uses a bit more code, but the replacement of two <b>lodsb</b>
instructions with a single <b>lodsw</b> and the
elimination of every
other branch pays off handsomely, as <a class="western" href="#L1114">Listing
11-14</a> runs in just 325 us, 15% faster than <a class="western" href="#L1111">Listings
11-11</a> and 5% faster than <a class="western" href="#L1112">Listing
11-12</a>. The key here is that <b>lods</b> allows
us leeway in
designing code to work around the slow memory access and slow
branching of the 8088, while <b>scas</b> does not. In
truth, the
flexibility of <b>lods</b> can make for better performance
still
through in-line code...but that's a story for the next few chapters.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_MORE_ON_scas"></a><a class="western" href="#T1103"><font size="4"><b>MORE
ON scas AND ZERO-TERMINATED STRINGS</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">While repeated <b>scas</b>
instructions aren't ideally suited to string searches involving
complex conditions, they <i>do</i> work nicely with
strings whenever
brute force scanning comes into play. One such application is
finding the offset of the <i>last</i> element of some sort
in a
string. For example, <a name="L1115R"></a><a class="western" href="#L1115">Listing
11-15</a>,
which finds the last non-blank element of a string by using <b>lodsw</b>
and remembering the offset of the most recent non-blank character
encountered, takes 907 us to find the last non-blank character of the
sample string, which has the last non-blank character in the middle
of the string. <a name="L1116R"></a><a class="western" href="#L1116">Listing
11-16</a>,
which does the same thing by using <b>repnz scasb</b> to
find the end
of the string and then <b>repz scasw</b> with the
Direction flag set
to 1 to find the first non-blank character scanning backward from the
end of the string, runs in just 386 us.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">That's an <i>amazing</i>
improvement given our earlier results involving the relative speeds
of <b>lodsw</b> and repeated <b>scas</b> in
string applications. The
reason that repeated <b>scas</b> outperforms <b>lodsw</b>
by a
tremendous amount in this case but underperformed it earlier is
simple. The <b>lodsw</b>-based code always has to check
every
character in the string &#8212; right up to the terminating zero &#8212;
when searching for the last non-blank character, as shown in Figure
11.12. </font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">While the <b>scasb</b>-base
code also has to access every character in the string, and then some,
as shown in Figure 11.13, the worst case is that </font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_5957ab35.jpg" align="bottom" border="0" height="450" width="596"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><a class="western" href="#L1116">Listing
11-16</a> accesses string elements no more than twice as many
times
as <a class="western" href="#L1115">Listing 11-15</a>.
In our
earlier example, the <i>best</i> case was a two-to-one
ratio. The
timing results for <a class="western" href="#L1115">Listings
11-15</a>
and <a class="western" href="#L1116">11-16</a>
show that the superior
speed, lack of prefetching, and lack of branching associated with
repeated <b>scas</b> far outweigh any performance loss
resulting from
a memory-access ratio of less than two-to-one.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> By
the way, <a class="western" href="#L1116">Listing
11-16</a> is an excellent example of the need to correct for
pointer
overrun when using the string instructions. No matter which
direction we scan in, it's necessary to undo the last advance of DI
performed by <b>scas</b> in order to point to the byte on
which the
comparison ended.</font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_m677bd9d2.jpg" align="bottom" border="0" height="570" width="619"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_m3835c4f8.jpg" align="bottom" border="0" height="361" width="613"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <a class="western" href="#L1116">Listing
11-16</a> also shows the use of <b>jcxz</b> to guard
against the case
where CX is zero. As you'll recall from the last chapter, repeated
<b>scas</b> doesn't alter the flags when started with CX
equal to
zero. Consequently, we must test for the case of CX equal to zero
before performing <b>repz scasw</b>, and we must treat
that case if
we had never found the terminating condition (a non-blank character).
Otherwise, the leftover flags from an earlier instruction might give
us a false result following a <b>repz scasw</b> which
doesn't change
the flags because it is repeated zero times. In <a name="L1121R"></a><a class="western" href="#L1121">Listing
11-21</a> we'll see that we need to do the same with repeated <b>cmps</b>
as well.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Bear in mind, however,
that there are several ways to solve any problem in assembler. For
example, in <a class="western" href="#L1116">Listing
11-16</a> I've
chosen to use <b>jcxz</b> to guard against the case where
CX is zero,
thereby compensating for the fact that <b>scas</b>
repeated zero
times doesn't change the flags. Rather than thinking defensively,
however, we could actually take advantage of that particular property
of repeated <b>scas</b>. How? We could set the Zero flag
to 1 (the
"match" state) by placing <b>sub dx,dx</b> before <b>repz
scasw</b>. Then if <b>repz scasw</b> is repeated
zero times because
CX is zero the following conditional jump will reach the proper
conclusion, that the desired non-match (a non-blank character) wasn't
found.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> As
it happens, <b>sub
dx,dx</b> isn't particularly faster than <b>jcxz</b>,
and so there's
not much to choose from between the two solutions. With <b>sub
dx,dx</b>
the code is 3 cycles faster when CX isn't zero but is the same number
of bytes in length, and is considerably slower when CX is zero.
(There's really no reason to worry about performance here when CX is
zero, however, since that's a rare case that's always handled
relatively quickly. Rather, our focus should be on losing as little
performance as possible to the test for CX being zero in the more
common case &#8212; when CX <i>isn't</i> zero.) In another
application, though, the desired Zero flag setting might fall out of
the code preceding the repeated <b>cmps</b>, and no extra
code at all
would be required for the test for CX equal to zero. <a name="L1124R"></a><a class="western" href="#L1124">Listing
11-24</a>, which we'll come to shortly, is such a case.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">What's interesting
here is that it's instinctive to use <b>jcxz</b>, which is
after all
a specialized and fast instruction that is clearly present in the
8088's instruction set for just such a purpose as protecting against
repeating a string comparison zero times. The idea of presetting a
flag and letting the comparison drop through without changing the
flag, on the other hand, is anything but intuitive &#8212; but is
just about as effective as <b>jcxz</b>, more so under
certain
circumstances.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Don't let your mind be
constrained by intentions of the designers of the 8088. Think in
terms of what instructions <i>do</i> rather than what they
were
<i>intended</i> to do.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_USING_REPEATED_scasw"></a><a class="western" href="#T1103"><font size="4"><b>USING
REPEATED scasw ON BYTE-SIZED DATA</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <a class="western" href="#L1116">Listing
11-16</a> is also a fine example of how to use repeated <b>scasw</b>
on byte-sized data. You'll recall that one of the rules of repeated
string instruction usage is that word-sized string instructions
should be used wherever possible, due to their faster overall speed. It
turns out, however, that it's rather tricky to apply this rule to
<b>scas</b>.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> For
starters, there's
hardly ever any use for <b>repnz scasw</b> when searching
for a
specific byte value in memory. Why? Well, while we could load up
both AH and AL with the byte we're looking for and then use <b>repnz
scasw</b>, we'd only find cases where the desired byte occurs at
least twice in a row, and then we'd only find such 2-byte cases that
didn't span word boundaries. Unfortunately, there's no way to use
<b>repnz scasw</b> to check whether either AH or AL &#8212; but
not
necessarily both &#8212; matched their respective bytes. With <b>repnz
scasw</b>, if AX doesn't match all 16 bits of memory, the search
will
continue, and individual byte matches will be missed.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> On
the other hand, we
<i>can</i> use <b>repz scasw</b> to search for
the first <i>non-match</i>,
as in <a class="western" href="#L1116">Listing
11-16</a>. Why is it
all right to search a word at a time for non-matches but not matches?
Because if <i>either</i> byte of each word compared with <b>repz
scasw</b> doesn't match the byte of interest (which is stored in
both
AH and AL), then <b>repz scasw</b> will stop, which is
what we want. Of course, there's a bit of cleaning up to do in order to
figure out
which of the 2 bytes was the first non-match, as illustrated by
<a class="western" href="#L1116">Listing 11-16</a>.
Yes, it is a bit
complex and does add a few bytes, but it also speeds things up, and
that's what we're after.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In
short, <b>repz
scasw</b> can be used to boost performance when scanning for
non-matching byte-sized data. However, <b>repnz scasw</b>
is
generally useless when scanning for matching byte-sized data.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_scas_AND_LOOK-UP"></a><a class="western" href="#T1103"><font size="4"><b>scas
AND LOOK-UP TABLES</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> One
common application
for table searching is to get an element number or an offset into a
table that can be used to look up related data or a jump address in
another table. We saw look-up tables in Chapter 7, and we'll see
them again, for they're a potent performance tool.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <b>scas</b>
is often
excellent for look-up code, but the pointer and counter overrun
characteristic of all string instructions make it a bit of a nuisance
to calculate offsets and/or element numbers after repeated <b>scas</b>
instructions. <a name="L1117R"></a><a class="western" href="#L1117">Listing
11-17</a>
shows a subroutine that calculates the offset of a match in a
word-sized table in the process of jumping to the associated routine
from a jump table. Notice that it's necessary to subtract the 2-byte
overrun from the difference between the final value of DI and the
start of the table. The calculation would be the same for a
byte-sized table scanned with <b>scasb</b>, save that <b>scasb</b>
has only a 1-byte overrun and so only 1 would be subtracted from the
difference between DI and the start of the table. </font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Finding the element
number is a slightly different matter. After a repeated <b>scas</b>,
CX contains the number of elements that weren't scanned. Since CX
counts down just once each time <b>scas</b> is repeated,
there's no
difference between <b>scasw</b> and <b>scasb</b>
in this respect.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Well, if CX contains
the number of elements that weren't scanned, then subtracting CX from
the table length in elements must yield the number of elements that
<i>were</i> scanned. Subtracting 1 from that value gives us
the
number of the last element scanned. (The first element is element
number 0, the second element is element number 1, and so on.) <a name="L1118R"></a><a class="western" href="#L1118">Listing 11-18</a>
illustrates the
calculation of the element number found in a look-up table as a step
in the process of jumping to the associated routine from a jump
table, much as in <a class="western" href="#L1117">Listing
11-17</a>.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_CONSIDER_YOUR_OPTIONS"></a><a class="western" href="#T1103"><font size="4"><b>CONSIDER
YOUR OPTIONS</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Don't assume that <b>scas</b>
is the ideal choice even for all memory-searching tasks in which the
search length is known. Suppose that we simply want to know if a
given character is any of, say, four characters: 'A', 'Z', '3', or
'!'. We could do this with <b>repnz scasb</b>, as shown in
<a name="L1119R"></a><a class="western" href="#L1119">Listing
11-19</a>. Alternatively, however, we could simply do it with
four
comparisons and conditional jumps, as shown in <a name="L1120R"></a><a class="western" href="#L1120">Listing
11-20</a>. Even with the prefetch queue cycle-eater doing its
worst,
each compare and conditional jump pair takes no more than 16 cycles
when the jump isn't taken (the jump is taken at most once, on a
match), which stacks up pretty well against the 15 cycle per
comparison and 9 cycle set-up time of <b>repnz scasb</b>.
What's
more, the compare-and-jump approach requires no set-up instructions. In
other words, the less sophisticated approach might well be better
in this case.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
Zen timer bears
this out. <a class="western" href="#L1119">Listing
11-19</a>, which
uses <b>repnz scasb</b>, takes 183 us to perform five
checks, while
<a class="western" href="#L1120">Listing 11-20</a>,
which uses the
compare-and-jump approach, takes just 119 us to perform the same five
checks. <a class="western" href="#L1120">Listing
11-20</a> is not
only 54% faster than <a class="western" href="#L1119">Listing
11-19</a>
but is also 1 byte shorter. (Don't forget to count the look-up table
bytes in <a class="western" href="#L1119">Listing
11-19</a>.)</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Of
course, the
compare-and-jump approach is less flexible than the look-up approach,
since the table length and contents can't be passed as parameters or
changed as the program runs. The compare-and-jump approach also
becomes unwieldy when more entries need to be checked, since 4 bytes
are needed for each additional compare-and-jump entry where the <b>repnz
scasb</b> approach needs just 1. The compare-and-jump approach
finally falls apart when it's no longer possible to short-jump out of
the comparison/jump code and so jumps around jumps must be used, as
in:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> cmp al,'Z'</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jnz $+5</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jmp CharacterFound</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> cmp al,'3'</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">When
jumps around jumps
are used, the comparison time per character goes from 16 to 24
cycles, and <b>rep scasb</b> emerges as the clear favorite.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Nonetheless, <a class="western" href="#L1119">Listings
11-19</a> and <a class="western" href="#L1120">11-20</a>
illustrate
two important points. Point number 1: the repeated string
instructions tend to have a greater advantage when they're repeated
many times, allowing their speed and compact size to offset the
overhead in set-up time and code they require. Point number 2:
specialized as the string instructions are, there are ways to program
the 8088 that are more specialized still. In certain cases, those
specialized approaches can even outperform the string instructions.
Sure, the specialized approaches, such as the compare-and-jump
approach we just saw, are limited and inflexible &#8212; but when you
don't need the flexibility, why pay for it in lost performance?</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h2 class="western"><font color="#110d06"><font color="#0b0703"><a name="_COMPARING_MEMORY_TO"></a><a class="western" href="#T1104"><font style="font-size: 16pt;" size="4"><b>11.4
COMPARING MEMORY TO MEMORY WITH cmps</b></font></a></font></font></h2>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">When <b>cmps</b> does
exactly what you need done it can't be beat, although to an even
greater extent than with <b>scas</b> the cases in which
that is true
are relatively few. <b>cmps</b> is used for applications
in which
byte-for-byte or word-for-word comparisons between two memory blocks
of a known length are performed, most notably array comparisons and
substring searching. Like <b>scas</b>, <b>cmps</b>
is not flexible
enough to work at full power on other comparison tasks, such as
case-insensitive substring searching or the comparison of
zero-terminated strings, although with a bit of thought <b>cmps</b>
can be made to serve adequately in some such applications.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <b>cmps</b>
does just
one thing, but it does far better than any other 8088 instruction or
combination of instructions. The one transcendent ability of <b>cmps</b>
is the direct comparison of two fixed-length blocks of memory. The
obvious use of <b>cmps</b> is in determining whether two
memory
arrays or blocks of memory are the same, and if not, where they
differ. <a class="western" href="#L1121">Listing
11-21</a>, which
runs in 685 us, illustrates <b>repz cmpsw</b> in action. <a name="L1122R"></a><a class="western" href="#L1122">Listing
11-22</a>, which performs exactly the same task as <a class="western" href="#L1121">Listing
11-21</a> but uses <b>lodsw</b> and <b>scasw</b>
instead of <b>cmpsw</b>,
runs in 1298 us. Finally, <a name="L1123R"></a><a class="western" href="#L1123">Listing
11-23</a>, which uses non-string instructions, takes a leisurely
1798
us to complete the task. As you can see, <b>cmps</b> blows
away not
only non-string instructions but also other string instructions under
the right circumstances. (As I've said before, there are many, many
different sequences of assembler code that will work for any given
task. It's the choice of implementation that makes the difference
between adequate code and great code.)</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> By
the way, in
<a class="western" href="#L1121">Listings 11-21</a>
though <a class="western" href="#L1123">11-23</a>
I've used <b>jcxz</b> to make sure the correct result is
returned if
zero-length arrays are compared. If you use this routine in your
code and you can be sure that zero-length arrays will never be passed
as parameters, however, you can save a few bytes and cycles by
eliminating the <b>jcxz</b> check. After all, what sense
does it
make to compare zero-length arrays...and what sense does it make to
waste precious bytes and cycles guarding against a contingency that
can never arise?</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Make the comparison a
bit more complex, however, and <b>cmps</b> comes back to
the pack. Consider the comparison of two zero-terminated strings,
rather than
two fixed-length arrays. As with <b>scas</b> in the last
section,
<b>cmps</b> can be made to work in this application by
first
performing a <b>scasb</b> pass to determine one string
length and
then comparing the strings with <b>cmpsw</b>, but the
double pass
negates much of the superior performance of <b>cmps</b>. <a class="western" href="#L1124">Listing
11-24</a> shows an implementation of this approach, which runs in
364
us for the test strings.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> We
found earlier that
<b>lods</b> works well for string searching when multiple
termination
conditions must be dealt with. That is true of string comparison as
well, particularly since there we can benefit from the combination of
<b>scas</b> and <b>lods</b>. The <b>lodsw</b>/<b>scasw</b>
approach,
shown in <a name="L1125R"></a><a class="western" href="#L1125">Listing
11-25</a>, runs in
just 306 us &#8212; 19% faster than the <b>rep scasb</b>/<b>repz
cmpsw</b>-based <a class="western" href="#L1124">Listing
11-24</a>.
For once, I won't bother with a non-string instruction-based
implementation, since it's perfectly obvious that replacing <b>lodsw</b>
and <b>scasw</b> with non-string sequences such as:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>mov ax,[si]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>inc si</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>inc si</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-left: 40px;"><font color="#110d06"><font color="#0b0703">and:</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>cmp [di],ax</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> :</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>inc di</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>inc di</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">can
only reduce
performance.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <b>cmps</b>
and even
<b>scas</b> become still less suitable if a highly complex
operation
such as case-insensitive string comparison is required. Since both
source and destination must be converted to the same case before
being compared, both must be loaded into the registers for
manipulation, and only <b>lods</b> among the string
instructions will
do us any good at all. <a name="L1126R"></a><a class="western" href="#L1126">Listing
11-26</a> shows code that performs case-insensitive string
comparison. <a class="western" href="#L1126">Listing
11-26</a> takes
869 us to run, which is not very fast by comparison with <a class="western" href="#L1121">Listings
11-21</a> through <a class="western" href="#L1125">11-25</a>.
That's
to be expected, though, given the flexibility required for this
comparison. The more flexibility required for a given task, the less
likely we are to be able to bring the full power of the
highly-specialized string instructions to bear on that task. That
doesn't mean that we shouldn't try to do so, just that we won't
always succeed.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> If
we're willing to
expend 200 extra bytes or so, we can speed <a class="western" href="#L1126">Listing
11-26</a> up considerably with a clever trick. Making sure a
character is uppercase takes a considerable amount of time even when
all calculations are done in the registers, as is the case in <a class="western" href="#L1126">Listing
11-26</a>. Fast as the instructions in the macro <b>TO_UPPER</b>
in
<a class="western" href="#L1126">Listing 11-26</a>
are, two to five
of them are executed every time a byte is made uppercase, and a
time-consuming conditional jump may also be performed.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> So
what's better than
two to five register-only instructions with at most one jump? A
look-up table, that's what. <a name="L1127R"></a><a class="western" href="#L1127">Listing
11-27</a> is a modification of <a class="western" href="#L1126">Listing
11-26</a> that looks up the uppercase version of each character
in
<b>ToUpperTable</b> with a single instruction &#8212; and the
extremely fast and compact <b>xlat</b> instruction, at
that. (It's
possible that <b>mov </b>could be used instead of <b>xlat</b>
to make
an even faster version of <a class="western" href="#L1127">Listing
11-27</a>, since <b>mov</b> can reference any
general-purpose
register while <b>xlat</b> can only load AL. As I've said,
there are
many ways to do anything in assembler.) For most characters there is
no uppercase version, and the same character that we started with is
looked up in <b>ToUpperTable</b>. For the 26 lowercase
characters,
however, the character looked up is the uppercase equivalent. </font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> You
may well be
thinking that it doesn't make much sense to try to speed up code by
<i>adding</i> a memory access, and normally you'd be right.
However,
<b>xlat</b> is very fast &#8212; it's a 1-byte instruction that
executes in 10 cycles &#8212; and it saves us the trouble of fetching
the many instruction bytes of <b>TO_UPPER</b>. (Remember,
instruction
fetches are memory accesses too.) What's more, <b>xlat</b>
eliminates the need for conditional jumps in the uppercase-conversion
process.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Sounds good in theory,
doesn't it? It works just as well in the real world, too. <a class="western" href="#L1127">Listing
11-27</a> runs in just 638 us, a 36% improvement over <a class="western" href="#L1126">Listing
11-26</a>. Of course, <a class="western" href="#L1127">Listing
11-27</a>
is also a good deal larger than <a class="western" href="#L1126">Listing
11-26</a>, owing to the look-up table, and that's a dilemma the
assembler programmer faces frequently on the PC: the choice between
speed and size. More memory, in the form of look-up tables and
in-line code, often means better performance. It's actually
relatively easy to speed up most code by throwing memory at it. The
hard part is knowing where to strike the balance between performance
and size.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Although both look-up
tables and in-line code are discussed elsewhere in this volume, a
broad discussion of the issue of memory versus performance will have
to wait until Volume II of <i>The Zen of Assembly Language</i>.
The
mechanics of translating memory into performance &#8212; the
knowledge aspect, if you will &#8212; is quite simple, but
understanding when that tradeoff can and should be made is more
complex and properly belongs in the discussion of the flexible mind.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_STRING_SEARCHING"></a><a class="western" href="#T1104"><font size="4"><b>STRING
SEARCHING</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Perhaps the single
finest application of <b>cmps</b> is in searching for a
sequence of
bytes within a data buffer. In particular, <b>cmps</b> is
excellent
for finding a particular text sequence in a buffer full of text, as
is the case when implementing a find-string capability in a text
editor.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> One
way to implement
such a searching capability is by simply starting <b>repz cmps</b>
at
each byte of the buffer until either a match is found or the end of
the buffer is reached, as shown in Figure 11.14. </font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_m66cd4d65.jpg" align="bottom" border="0" height="508" width="612"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_mbbd5f8e.jpg" align="bottom" border="0" height="391" width="620"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><a name="L1128R"></a><a class="western" href="#L1128">Listing
11-28</a>, which employs this approach, runs in 2995 us for the
sample search sequence and buffer.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">That's not bad, but
there's a better way to go. Suppose we load the first byte of the
search string into AL and use <b>repnz scasb</b> to find
the next
candidate for the full <b>repz cmps</b> comparison, as
shown in
Figure 11.15. </font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_6a24ea5d.jpg" align="bottom" border="0" height="583" width="608"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_m66772dfb.jpg" align="bottom" border="0" height="391" width="613"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> By
so doing we could
use a fast repeated string instruction to disqualify most of the
potential strings, rather than having to loop and start up <b>repz
cmps</b> at each and every byte in the buffer. Would that make a
difference?</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> It
would indeed! <a name="L1129R"></a><a class="western" href="#L1129">Listing
11-29</a>, which uses the
hybrid <b>repnz scasb</b>/<b>repz cmps</b>
technique, runs in just
719 us for the same search sequence and buffer as <a class="western" href="#L1128">Listing
11-28</a>. Now, the margin between the two techniques could vary
considerably, depending on the contents of the buffer and the search
sequence. Nonetheless, we've just seen an improvement of more than
300% over already-fast string instruction-based code! That
improvement is primarily due to the use of <b>repnz scasb</b>
to
eliminate most of the instruction fetches and branches of <a class="western" href="#L1128">Listing
11-28</a>.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Even when you're using
string instructions, stretch your mind to think of still-better
approaches...</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> As
for non-string
implementations, <a name="L1130R"></a><a class="western" href="#L1130">Listing
11-30</a>,
which performs the same task as do <a class="western" href="#L1128">Listings
11-28</a> and <a class="western" href="#L1129">11-29</a>
but does so
with non-string instructions, takes a full 3812 us to run. It should
be very clear that non-string instructions should be used in
searching applications only when their greater flexibility is
absolutely required.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Make no mistake,
there's more to searching performance than simply using the right
combination of string instructions. The right choice of algorithm is
critical. For a list of several thousand sorted items, a
poorly-coded binary search might well beat the pants off a slick
<b>repnz scasb</b>/<b>repz cmps</b>
implementation. On the other
hand, the <b>repnz scasb</b>/<b>repz cmps</b>
approach is excellent
for searching free-form data of the sort that's found in text
buffers.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
key to searching
performance lies in choosing a good algorithm for your application
<i>and</i> implementing it with the best possible code.
Either the
searching algorithm or the implementation may be the factor that
limits performance. Ideally, a searching algorithm would be chosen
with an eye toward using the strengths of the 8088 &#8212; and that
usually means the string instructions.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_cmps_WITHOUT_rep"></a><a class="western" href="#T1104"><font size="4"><b>cmps
WITHOUT rep</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In
the last chapter I
pointed out that <b>scas</b> and <b>cmps</b>
are slower but more
flexible when they're not repeated. Although <b>repz</b>
and <b>repnz</b>
only allow termination according to the state of the Zero flag, <b>scas</b>
and <b>cmps</b> actually set all the status flags, and we
can take
advantage of that when <b>scas</b> and <b>cmps</b>
aren't repeated. Of course, we should use <b>repz</b> or <b>repnz</b>
whenever we can,
but non-repeated <b>scas</b> and <b>cmps</b>
let us tap the power of
string instructions when <b>repz</b> and <b>repnz</b>
simply won't
do.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> For
instance, suppose
that we're comparing two arrays that contain signed 16-bit values
representing signal measurements. Suppose further that we want to
find the first point at which the waves represented by the arrays
cross. That is, if wave A starts out above wave B, we want to know
when wave A becomes less than or equal to wave B, as shown in Figure
11.16. </font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_56aac57f.jpg" align="bottom" border="0" height="388" width="595"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">If
wave B starts out
above wave A, then we want to know when wave B becomes less than or
equal to wave A.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">There's no way to
perform this comparison with repeated <b>cmps</b>, since
greater-than/less-than comparisons aren't in the limited repertoire
of the <b>rep</b> prefix. However, plain old non-repeated <b>cmpsw</b>
is up to the task, as shown in <a name="L1131R"></a><a class="western" href="#L1131">Listing
11-31</a>, which runs in 1232 us. As shown in <a class="western" href="#L1131">Listing
11-31</a>, we must initially determine which array starts out on
top,
in order to set SI to point to the initially-greater array and DI to
point to the other array. Once that's done, all we need do is
perform a <b>cmpsw</b> on each data point and check
whether that
point is still greater with <b>jg</b>. <b>loop</b>
repeats the
comparison for however many data points there are &#8212; and that's
the whole routine in a very compact package! The 3-instruction,
5-byte loop of <a class="western" href="#L1131">Listing
11-31</a> is
hard to beat for this fairly demanding task.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> By
contrast, <a name="L1132R"></a><a class="western" href="#L1132">Listing
11-32</a>, which performs the same crossing search but does so
with
non-string instructions, has 6 instructions and 13 bytes in the loop
and takes considerably longer &#8212; 1821 us &#8212; to complete the
sample crossing search. Although we were unable to use repeated <b>cmps</b>
for this particular task, we were nonetheless able to improve
performance a great deal by using the string instruction in its
non-repeated form. </font></font></p>
<h2 class="western"><font color="#110d06"><font color="#0b0703"><a name="_A_NOTE_ABOUT"></a><a class="western" href="#T1105"><font style="font-size: 16pt;" size="4"><b>11.5
A NOTE ABOUT RETURNING VALUES</b></font></a></font></font></h2>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Throughout this
chapter I've been returning "not found" statuses by passing
zero pointers (pointers set to zero) back to the calling routine. This
is a commonly used and very flexible means of returning such
statuses, since the same registers that are used to return pointers
when searches are successful can be used to return zero when searches
are not successful. The success or failure of a subroutine can then
be tested with code like:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> call FindCharInString</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> and si,si</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jz CharNotFound</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">Returning
failure
statuses as zero pointers is particularly popular in high-level
languages such as C, although C returns pointers in either AX, DX:AX,
or memory, rather than in SI or DI.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">However, there are
many other ways of returning statuses in assembler. One particularly
effective approach is that of returning success or failure in either
the Zero or Carry flag, so that the calling routine can immediately
jump conditionally upon return from the subroutine, without the need
for any anding, oring, or comparing of any sort. This works out
especially well when the proper setting of a flag falls out of the
normal functioning of a subroutine. For example, consider the
following subroutine, which returns the Zero flag set to 1 if the
character in AL is whitespace:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>Whitespace:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> cmp al,'
' ;space</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jz WhitespaceDone</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> cmp al,9 ;tab</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jz WhitespaceDone</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> and al,al ;zero
byte</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b>WhitespaceDone:</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> ret</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">The
key point here is
that the Zero flag is automatically set by the comparisons preceding
the <b>ret</b>. Any test for whitespace would have to
perform the
same comparisons, so practically speaking we didn't have to write a
single extra line of code to return the subroutine's status in the
Zero flag. Because the return status is in a flag rather than a
register, <b>Whitespace</b> could be called and the
outcome handled
with a very short sequence of instructions, as follows:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> mov al,[Char]</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> call Whitespace</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in; margin-top: 0em; margin-left: 40px;"><font color="#110d06"><font color="#0b0703"><font color="#890000"><b> jnz NotWhitespace</b></font></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
particular example
isn't important here. What is important is that you realize that in
assembler (unlike high-level languages) there are many ways to return
statuses, and that it's possible to save a great deal of code and/or
time by taking advantage of that. Now is not the time to pursue the
topic further, but we'll return to the issues of passing values and
statuses both to and from assembler subroutines in Volume II of <i>The
Zen of Assembly Language</i>.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h2 class="western"><font color="#110d06"><font color="#0b0703"><a name="_PUTTING_STRING_INSTRUCTIONS"></a><a class="western" href="#T1106"><font style="font-size: 16pt;" size="4"><b>11.6
PUTTING STRING INSTRUCTIONS TO WORK IN UNLIKELY PLACES</b></font></a></font></font></h2>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">I've said several
times that string instructions are so powerful that you should try to
use them even when they don't seem especially well-matched to a
particular application. Now I'm going to back that up with an
unlikely application in which the string instructions have served me
well over the years: animation.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">This section is
actually a glimpse into the future. Volume II of <i>The Zen of
Assembly Language</i> will take up the topic of animation in much
greater detail, since animation truly falls in the category of the
flexible mind rather than knowledge. Still, animation is such a
wonderful example of what the string instructions can do that we'll
spend a bit of time on it here and now. It'll be a whirlwind look,
with few details and nothing more than a quick glance at theory, for
the focus isn't on animation <i>per se</i>. What's
important is not
that you understand how animation works, but rather that you get a
feel for the miracles string instructions can perform in places where
you wouldn't think they could serve at all.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_ANIMATION_BASICS"></a><a class="western" href="#T1106"><font size="4"><b>ANIMATION
BASICS</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Animation involves
erasing and redrawing one or more images quickly enough to fool the
eye into perceiving motion, as shown in Figure 11.17. </font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_b77fd4b.jpg" align="bottom" border="0" height="692" width="603"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">Animation
is a marginal
application for the PC, by which I mean that the 8088 barely has
enough horsepower to support decent animation under the best of
circumstances. What <i>that</i> means is that the Zen of
assembler
is an absolute must for PC animation.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Traditionally,
microcomputer animation has been performed by exclusive-oring images
into display memory; that is, by drawing images by inserting the bits
that control their pixels into display memory with the <b>xor</b>
instruction. When an image is first exclusive-ored into display
memory at a given location, the image becomes visible. A second
exclusive-oring of the image at the same location then erases the
image. Why? That's simply the nature of the exclusive-or operation.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Consider this. When
you exclusive-or a 1 bit with another bit once, the other bit is
flipped. When you exclusive-or the same 1 bit with that other bit
again, the other bit is again flipped &#8212; <i>right back to its
original state</i>, as shown in Figure 11. 18. </font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_148fb7e8.jpg" align="bottom" border="0" height="699" width="612"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703">After
all, a bit only
has two possible states, so a double flip must restore the bit back
to the state in which it started. Since exclusive-oring a 0 bit with
another bit never affects the other bit, exclusive-oring a target bit
twice with either a 1 or a 0 bit always leaves the target bit in its
original state.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Why
is exclusive-oring
so popular for animation? Simply because no matter how many images
overlap, the second exclusive-or of an image always erases it without
interfering with any other images. In other words, the perfect
reversibility of the exclusive-or operation means that you could
exclusive-or each of 10 images once at the same location, drawing the
images right on top of each other, then exclusive-or them all again
at the same place &#8212; and they would all be erased. With
exclusive-oring, the drawing or erasing of one image never interferes
with the drawing or erasing of other images it overlaps.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> If
you're catching all
this, great. If not, don't worry. I'm not going to spend time
explaining animation now &#8212; better we should wait until Volume
II, when we have the time to do it right. The important point is
that exclusive-oring is a popular animation technique, primarily
because it eliminates the complications of drawing and erasing
overlapping images.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <a name="L1133R"></a><a class="western" href="#L1133">Listing
11-33</a>, which bounces 10 images around the screen, illustrates
animation based on exclusive-oring. When run on an Enhanced Graphics
Adapter (EGA), <a class="western" href="#L1133">Listing
11-33</a>
takes 30.29 seconds to move and redraw every image 500 times. (Note
that the long-period Zen timer was used to time <a class="western" href="#L1133">Listing
11-33</a>, since we can't perform much animation within the 54 ms
maximum period of the precision Zen timer.)</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <a class="western" href="#L1133">Listing
11-33</a> isn't a general-purpose animation program. I've kept
complications to a minimum in order to show basic exclusive-or
animation. <a class="western" href="#L1133">Listing
11-33</a> allows
us to observe the fundamental strengths and weaknesses (primarily the
latter) of the exclusive-or approach.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">When you run <a class="western" href="#L1133">Listing
11-33</a>, you'll see why exclusive-oring is less than ideal.
While
overlapping images don't interfere with each other so far as drawing
and erasing go, they do produce some unattractive on-screen effects. In
particular, unintended colors and patterns often result when
multiple images are exclusive-ored into the same bytes of display
memory. Another problem is that exclusive-ored images flicker
because they're constantly being erased and redrawn. (Each image
could instead be redrawn at its new location before being erased at
the old location, but the overlap effects characteristic of
exclusive-oring would still cause flicker.) That's not all, though.
There's a still more serious problem with exclusive-or based
animation...</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Exclusive-oring is
slow.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
problem isn't that
the <b>xor</b> instruction itself is particular slow;
rather, it's
that the <b>xor</b> instruction isn't a string
instruction. <b>xor</b>
can't be repeated with <b>rep</b>, it doesn't advance its
pointers
automatically, and it just isn't as speedy as, say, <b>movs</b>.
Still, neither <b>movs</b> nor any other string
instruction can
perform exclusive-or operations, so it would seem we're stuck.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">We're hardly stuck,
though. On the contrary, we're bound for glory!</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_STRING_INSTRUCTION-BASED_ANIMATION"></a><a class="western" href="#T1106"><font size="4"><b>STRING
INSTRUCTION-BASED ANIMATION</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> If
string instructions
can't perform exclusive-oring, then we'll just have to figure out a
way to animate without exclusive-oring. As it turns out, there's a
<i>very</i> nice way to do this. I learned this approach
from Dan
Illowsky, who developed it before string instructions even existed,
way back in the early days of the Apple II.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">First, we'll give each
image a small blank fringe. Then we'll make it a rule never to move
an image by more than the width of its fringe before redrawing it.
Finally we'll draw images by simply copying them to display memory,
destroying whatever they overwrite, as shown in Figure 11.19. Now,
what does that do for us?</font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_m3203705c.jpg" align="bottom" border="0" height="635" width="596"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;" align="center"><font color="#110d06"><font color="#0b0703"><img src="ZOA_html_721bcf54.jpg" align="bottom" border="0" height="200" width="601"></font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> <i>Amazing</i>
things. For starters, each image will, as it is redrawn, automatically
erase
its former incarnation. That means that there's no flicker, since
images are never really erased, but only drawn over themselves. There
are also no color effects when images overlap, since only the
image that was drawn most recently at any given pixel is visible.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In
short, this sort of
animation (which I'll call "block-move animation") actually
looks considerably better than animation based on exclusive-oring.
That's just frosting on the cake, though &#8212; the big payoff is
speed. With block-move animation we suddenly don't need to
exclusive-or anymore &#8212; in fact, <b>rep movs</b> will work
beautifully to draw a whole line of an image in a single instruction.
We also don't need to draw each image twice per move &#8212; once to
erase the image at its old location and once to draw it at its new
location &#8212; as we did with exclusive-oring, since the act of
drawing the image at a new location serves to erase the old image as
well. But wait, there's more! <b>xor</b> accesses a given
byte of
memory twice per draw, once to read the original byte and once to
write the modified byte back to memory. With block-move animation,
on the other hand, we simply write each byte of an image to memory
once and we're done with that byte. In other words, between the
elimination of a separate erasing step and the replacement of
read-<b>xor</b>-write with a single write, block-move
animation
accesses display memory only about one-third as many times as
exclusive-or animation. (The ratio isn't quite 1 to 4 because the
blank fringe makes block-move animation images somewhat larger.)</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Are
alarm bells going
off in your head? They should be. Think back to our journey beneath
the programming interface. Think of the cycle-eaters. Ah, you've got
it! <i>Exclusive-or animation loses about three times as much
performance to the display adapter cycle-eater as does block-move
animation.</i> What's more, block-move animation uses the
blindingly
fast <b>movs</b> instruction. To top it off, block-move
animation
loses almost nothing to the prefetch queue cycle-eater or the 8088's
slow branching speed, thanks to the <b>rep</b> prefix.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Sounds almost too good
to be true, doesn't it? It is true, though: block-move animation
relies almost exclusively on one of the two most powerful
instructions of the 8088 (<b>cmps</b> being the other), and
avoids
the gaping maws of the prefetch queue and display adapter
cycle-eaters in the process. Which leaves only one question:</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> How
fast <i>is</i>
block-move animation? </font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Remember, theory is
fine, but we don't trust any code until we've timed it. <a name="L1134R"></a><a class="western" href="#L1134">Listing
11-34</a> performs the same animation as <a class="western" href="#L1134">Listing
11-34</a>, but with block-move rather than exclusive-or
animation. Happily, <a class="western" href="#L1134">Listing
11-34</a> lives up
to its advance billing, finishing in just 10.35 seconds when run on
an EGA. <i>Block-move animation is close to three times as fast
as
exclusive-oring in this application</i> &#8212; and it looks better,
too. (You can slow down the animation in order to observe the
differences between the two sorts of animation more closely by
setting <b>DELAY</b> to a higher value in each listing.)</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Let's not underplay
the appearance issue just because the performance advantage of
block-move animation is so great. If you possibly can, enter and run
<a class="western" href="#L1133">Listings 11-33</a>
and <a class="western" href="#L1134">11-34</a>.
The visual impact of block-move animation's flicker-free, high-speed
animation is startling. It's hard to imagine that any programmer
would go back to exclusive-oring after seeing block-move animation in
action.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">That's not to say that
block-move animation is perfect. Unlike exclusive-oring, block-move
animation wipes out the background unless the background is
explicitly redrawn after each image is moved. Block-move animation
does produce flicker and fringe effects when images overlap. Block-move
animation also limits the maximum distance by which an
image can move before it's redrawn to the width of its fringe.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> If
block-move
animation isn't perfect, however, it's <i>much</i> better
than
exclusive-oring. What's really noteworthy, however, is that we
looked at an application &#8212; animation &#8212; without
preconceived ideas about the best implementation, and came up with an
approach that merged the application's needs with one of the
strengths of the PC &#8212; the string instructions &#8212; while
avoiding the cycle-eaters. In the end, we not only improved
performance remarkably but also got better animation, in the process
turning a seeming minus &#8212; the limitations of the string
instructions &#8212; into a big plus. All in all, what we've just
done is the Zen of assembler working on all levels: knowledge,
flexible mind, and implementation.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Try
to use the string
instructions for all your time-critical code, even when you think
they just don't fit. Sometimes they don't &#8212; but you can never
be sure unless you try...and if they <i>can</i> be made to
fit, it
will pay off <i>big</i>.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_NOTES_ON_THE_1"></a><a class="western" href="#T1106"><font size="4"><b>NOTES
ON THE ANIMATION IMPLEMENTATIONS</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">Spend as much time as
you wish perusing <a class="western" href="#L1133">Listings
11-33</a>
and <a class="western" href="#L1134">11-34</a>,
but <i>do not worry</i>
if they don't make complete sense to you right now. The point of
this exercise was to illustrate the use of the string instructions in
an unusual application, not to get you started with animation. In
Volume II of <i>The Zen of Assembly Language</i> we'll
return to
animation in a big way.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
animation listings
are not full-featured, flexible implementations, nor were they meant
to be. My intent in creating these programs was to contrast the
basic operation and raw performance of exclusive-or and block-move
animation. Consequently, I've structured the two listings along much
the same lines, and while the code is fast, I've avoided further
optimizations (notably the use of in-line code) that would have
complicated matters. We'll see those additional optimizations in
Volume II.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> One
interesting point
to be made about the animation listings is that I've assumed in the
drawing routines that images always start on even rows of the screen
and are always an even number of rows in height. Many people would
consider the routines to be incomplete, since they lack the extra
code needed to handle the complications of odd start rows and odd
heights in 320x200 4-color graphics mode. Of course, that extra code
would slow performance and increase program size, but would be deemed
necessary in any "full" animation implementation.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> Is
the handling of odd
start rows and odd heights really necessary, though? Not if you can
structure your application so that images can always start on even
rows and can always be of even heights, and that's actually easy to
do. No one will ever notice whether images move 1 or 2 pixels at a
time; the nature of animation is such that the motion of an image
appears just as smooth in either case. And why should there be a
need for odd image heights? If necessary, images of odd height could
be padded out with an extra line. In fact, an extra line can often
be used to improve the appearance of an image.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> In
short, "full"
animation implementations will not only run slower than the
implementation in <a class="western" href="#L1133">Listings
11-33</a>
and <a class="western" href="#L1134">11-34</a>
but may not even yield
any noticeable benefits. The lesson is this: only add features that
slow your code when you're sure you need them. High-performance
assembler programming is partly an art of eliminating everything but
the essentials.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> By
the way, <a class="western" href="#L1133">Listings
11-33</a> and <a class="western" href="#L1134">11-34</a>
move images
a full 4 pixels at a time horizontally, and that's a bit <i>too</i>
far. 2 pixels is a far more visually attractive distance by which to
move animated images, especially those that move slowly. However,
because each byte of 320x200 4-color mode display memory controls 4
pixels, alignment of images to start in columns that aren't multiples
of 4 is more difficult, although not really that hard once you get
the hang of it. Since our goal in this section was to contrast
block-move and exclusive-or animation, I didn't add the extra code
and complications required to bit-align the images. We will discuss
bit-alignment of images at length in Volume II, however.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h2 class="western"><font color="#110d06"><font color="#0b0703"><a name="_A_NOTE_ON"></a><a class="western" href="#T1107"><font style="font-size: 16pt;" size="4"><b>11.7
A NOTE ON HANDLING BLOCKS LARGER THAN 64 K BYTES</b></font></a></font></font></h2>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> All
the string
instruction-based code we've seen in this chapter handles only blocks
or strings that are 64 K bytes in length or shorter. There's a very
good reason for this, of course &#8212; the infernal segmented
architecture of the 8088 &#8212; but there are nonetheless times when
larger memory blocks are needed.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> I'm
going to save the
topic of handling blocks larger than 64 K bytes for Volume II of <i>The
Zen of Assembly Language</i>. Why? Well, the trick with code that
handles larger memory blocks isn't getting it to work; that's
relatively easy if you're willing to perform 32-bit arithmetic and
reload the segment registers before each memory access. No, the
trick is getting code that handles large memory blocks to work
reasonably fast.</font></font></p>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">We've seen that a key
to assembler programming lies in converting difficult problems from
approaches ill-suited to the 8088 to ones that the 8088 can handle
well, and this is no exception. In this particular application, we
need to convert the task at hand from one of independently addressing
every byte in the 8088's 1-megabyte address space to one of handling
a series of blocks that are each no larger than 64 K bytes, so that
we can process up to 64 K bytes at a time very rapidly without
touching the segment registers.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"> The
concept is simple,
but the implementation is not so simple and requires the flexible
mind...and that's why the handling of memory blocks larger than 64 K
bytes will have to wait until Volume II.</font></font></p>
<p class="western" style="margin-bottom: 0in;"><font color="#110d06"><font color="#0b0703"><br>
</font></font></p>
<h3 class="western"><font color="#110d06"><font color="#0b0703"><a name="_CONCLUSION"></a>&nbsp;<a class="western" href="#T1107"><font size="4"><b>CONCLUSION</b></font></a></font></font></h3>
<p class="western" style="margin-bottom: 0in;">
<font color="#110d06"><font color="#0b0703">This chapter had two
objectives. First, I wanted you to get a sense of how and when the
string instructions can best be applied. Second, I wanted you to
heighten your regard for these instructions, which are the best the
8088 has to offer. With any luck, this chapter has both broadened
your horizons for string instruction applications and increased your
respect for these unique and uniquely powerful members of the 8088's
instruction set.</font></font></p>
